
MCU2 ATM.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002c34  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000722  00800060  00002c34  00002cc8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000ad  00800782  00800782  000033ea  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000033ea  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000341c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000588  00000000  00000000  00003458  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005e53  00000000  00000000  000039e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000015ff  00000000  00000000  00009833  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000303e  00000000  00000000  0000ae32  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001098  00000000  00000000  0000de70  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001f23  00000000  00000000  0000ef08  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004203  00000000  00000000  00010e2b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004c8  00000000  00000000  0001502e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 a1 11 	jmp	0x2342	; 0x2342 <__vector_1>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 76 12 	jmp	0x24ec	; 0x24ec <__vector_11>
      30:	0c 94 e2 11 	jmp	0x23c4	; 0x23c4 <__vector_12>
      34:	0c 94 31 13 	jmp	0x2662	; 0x2662 <__vector_13>
      38:	0c 94 05 13 	jmp	0x260a	; 0x260a <__vector_14>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	17 e0       	ldi	r17, 0x07	; 7
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e3       	ldi	r30, 0x34	; 52
      68:	fc e2       	ldi	r31, 0x2C	; 44
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 38       	cpi	r26, 0x82	; 130
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	28 e0       	ldi	r18, 0x08	; 8
      78:	a2 e8       	ldi	r26, 0x82	; 130
      7a:	b7 e0       	ldi	r27, 0x07	; 7
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 32       	cpi	r26, 0x2F	; 47
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 8a 0e 	call	0x1d14	; 0x1d14 <main>
      8a:	0c 94 18 16 	jmp	0x2c30	; 0x2c30 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <EXTI0_Handler>:
	
}
void EXTI0_Handler(void)
{ 
	/* update the card insertion state */
	CardinsertionState =Inserted;
      92:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
	/* move the card motor towards the ATM */
	CardMotorRight();
      96:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <CardMotorRight>
	/* disable interrupt */
	EXTI0_Disable();
      9a:	0e 94 9a 11 	call	0x2334	; 0x2334 <EXTI0_Disable>
      9e:	08 95       	ret

000000a0 <APP_GetTemperature>:
	
}
uint8_t APP_GetTemperature(void)
{
      a0:	cf 93       	push	r28
      a2:	df 93       	push	r29
      a4:	1f 92       	push	r1
      a6:	cd b7       	in	r28, 0x3d	; 61
      a8:	de b7       	in	r29, 0x3e	; 62
	uint8_t u8_Temp;
	TempSensorGetTemp(&u8_Temp);
      aa:	ce 01       	movw	r24, r28
      ac:	01 96       	adiw	r24, 0x01	; 1
      ae:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <TempSensorGetTemp>
	return u8_Temp;
}
      b2:	89 81       	ldd	r24, Y+1	; 0x01
      b4:	0f 90       	pop	r0
      b6:	df 91       	pop	r29
      b8:	cf 91       	pop	r28
      ba:	08 95       	ret

000000bc <APP_CommandCompare>:
}

enCompareCommand_t APP_CommandCompare(void)
 {
	 uint8_t u8_counter=0;
	 while(AdminCommand[u8_counter] !=  '\0' && Command[u8_counter] != '\r')
      bc:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <AdminCommand>
      c0:	88 23       	and	r24, r24
      c2:	e9 f0       	breq	.+58     	; 0xfe <APP_CommandCompare+0x42>
      c4:	90 91 15 08 	lds	r25, 0x0815	; 0x800815 <Command>
      c8:	9d 30       	cpi	r25, 0x0D	; 13
      ca:	d9 f0       	breq	.+54     	; 0x102 <APP_CommandCompare+0x46>
	 {
		 if (AdminCommand[u8_counter]==Command[u8_counter])
      cc:	89 17       	cp	r24, r25
      ce:	29 f0       	breq	.+10     	; 0xda <APP_CommandCompare+0x1e>
			 u8_counter++;
			 continue;
		 }
		 else
		 {
			 return NOT_EQUAL;
      d0:	81 e0       	ldi	r24, 0x01	; 1
      d2:	08 95       	ret
enCompareCommand_t APP_CommandCompare(void)
 {
	 uint8_t u8_counter=0;
	 while(AdminCommand[u8_counter] !=  '\0' && Command[u8_counter] != '\r')
	 {
		 if (AdminCommand[u8_counter]==Command[u8_counter])
      d4:	38 13       	cpse	r19, r24
      d6:	17 c0       	rjmp	.+46     	; 0x106 <APP_CommandCompare+0x4a>
      d8:	01 c0       	rjmp	.+2      	; 0xdc <APP_CommandCompare+0x20>
      da:	20 e0       	ldi	r18, 0x00	; 0
		 {
			 u8_counter++;
      dc:	2f 5f       	subi	r18, 0xFF	; 255
}

enCompareCommand_t APP_CommandCompare(void)
 {
	 uint8_t u8_counter=0;
	 while(AdminCommand[u8_counter] !=  '\0' && Command[u8_counter] != '\r')
      de:	82 2f       	mov	r24, r18
      e0:	90 e0       	ldi	r25, 0x00	; 0
      e2:	fc 01       	movw	r30, r24
      e4:	ea 59       	subi	r30, 0x9A	; 154
      e6:	ff 4f       	sbci	r31, 0xFF	; 255
      e8:	30 81       	ld	r19, Z
      ea:	33 23       	and	r19, r19
      ec:	71 f0       	breq	.+28     	; 0x10a <APP_CommandCompare+0x4e>
      ee:	fc 01       	movw	r30, r24
      f0:	eb 5e       	subi	r30, 0xEB	; 235
      f2:	f7 4f       	sbci	r31, 0xF7	; 247
      f4:	80 81       	ld	r24, Z
      f6:	8d 30       	cpi	r24, 0x0D	; 13
      f8:	69 f7       	brne	.-38     	; 0xd4 <APP_CommandCompare+0x18>
		 else
		 {
			 return NOT_EQUAL;
		 }
	 }
	 return EQUAL;
      fa:	80 e0       	ldi	r24, 0x00	; 0
      fc:	08 95       	ret
      fe:	80 e0       	ldi	r24, 0x00	; 0
     100:	08 95       	ret
     102:	80 e0       	ldi	r24, 0x00	; 0
     104:	08 95       	ret
			 u8_counter++;
			 continue;
		 }
		 else
		 {
			 return NOT_EQUAL;
     106:	81 e0       	ldi	r24, 0x01	; 1
     108:	08 95       	ret
		 }
	 }
	 return EQUAL;
     10a:	80 e0       	ldi	r24, 0x00	; 0
 }
     10c:	08 95       	ret

0000010e <APP_Delay_ms>:

/* delay function in msec */
void APP_Delay_ms(uint32_t u32_Timemsec)
{
     10e:	8f 92       	push	r8
     110:	9f 92       	push	r9
     112:	af 92       	push	r10
     114:	bf 92       	push	r11
     116:	cf 92       	push	r12
     118:	df 92       	push	r13
     11a:	ef 92       	push	r14
     11c:	ff 92       	push	r15
	uint32_t u32_counter =0;
	for (u32_counter=0;u32_counter<u32_Timemsec;u32_counter++)
     11e:	61 15       	cp	r22, r1
     120:	71 05       	cpc	r23, r1
     122:	81 05       	cpc	r24, r1
     124:	91 05       	cpc	r25, r1
     126:	b1 f0       	breq	.+44     	; 0x154 <APP_Delay_ms+0x46>
     128:	4b 01       	movw	r8, r22
     12a:	5c 01       	movw	r10, r24
     12c:	c1 2c       	mov	r12, r1
     12e:	d1 2c       	mov	r13, r1
     130:	76 01       	movw	r14, r12
	{  
		/* this function takes timer id and number of ticks so if fck 1mega */
		/* the timer time base will be  1micro so we pass 1000 micro to represent 1 msec*/ 
		GptStart_Sync(0,1000);
     132:	48 ee       	ldi	r20, 0xE8	; 232
     134:	53 e0       	ldi	r21, 0x03	; 3
     136:	60 e0       	ldi	r22, 0x00	; 0
     138:	70 e0       	ldi	r23, 0x00	; 0
     13a:	80 e0       	ldi	r24, 0x00	; 0
     13c:	0e 94 22 12 	call	0x2444	; 0x2444 <GptStart_Sync>

/* delay function in msec */
void APP_Delay_ms(uint32_t u32_Timemsec)
{
	uint32_t u32_counter =0;
	for (u32_counter=0;u32_counter<u32_Timemsec;u32_counter++)
     140:	8f ef       	ldi	r24, 0xFF	; 255
     142:	c8 1a       	sub	r12, r24
     144:	d8 0a       	sbc	r13, r24
     146:	e8 0a       	sbc	r14, r24
     148:	f8 0a       	sbc	r15, r24
     14a:	8c 14       	cp	r8, r12
     14c:	9d 04       	cpc	r9, r13
     14e:	ae 04       	cpc	r10, r14
     150:	bf 04       	cpc	r11, r15
     152:	79 f7       	brne	.-34     	; 0x132 <APP_Delay_ms+0x24>
	{  
		/* this function takes timer id and number of ticks so if fck 1mega */
		/* the timer time base will be  1micro so we pass 1000 micro to represent 1 msec*/ 
		GptStart_Sync(0,1000);
	}
}
     154:	ff 90       	pop	r15
     156:	ef 90       	pop	r14
     158:	df 90       	pop	r13
     15a:	cf 90       	pop	r12
     15c:	bf 90       	pop	r11
     15e:	af 90       	pop	r10
     160:	9f 90       	pop	r9
     162:	8f 90       	pop	r8
     164:	08 95       	ret

00000166 <APP_APPToTerminalResponse>:

/* Send Message to the terminal */
void APP_APPToTerminalResponse(uint8_t *pString)
{
     166:	cf 93       	push	r28
     168:	df 93       	push	r29
     16a:	ec 01       	movw	r28, r24
	/* Disable UART RXC interrupts */
	USART_RxInterruptDiable();
     16c:	0e 94 ff 12 	call	0x25fe	; 0x25fe <USART_RxInterruptDiable>
	
	while(*pString !='\0')
     170:	88 81       	ld	r24, Y
     172:	88 23       	and	r24, r24
     174:	39 f0       	breq	.+14     	; 0x184 <APP_APPToTerminalResponse+0x1e>
     176:	21 96       	adiw	r28, 0x01	; 1
	{
		USART_Transmit(*pString);
     178:	90 e0       	ldi	r25, 0x00	; 0
     17a:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <USART_Transmit>
void APP_APPToTerminalResponse(uint8_t *pString)
{
	/* Disable UART RXC interrupts */
	USART_RxInterruptDiable();
	
	while(*pString !='\0')
     17e:	89 91       	ld	r24, Y+
     180:	81 11       	cpse	r24, r1
     182:	fa cf       	rjmp	.-12     	; 0x178 <APP_APPToTerminalResponse+0x12>
	{
		USART_Transmit(*pString);
		pString++;
	}
	/* Enable UART RXC  interrupts */
	USART_RxInterruptEnable();
     184:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <USART_RxInterruptEnable>
}
     188:	df 91       	pop	r29
     18a:	cf 91       	pop	r28
     18c:	08 95       	ret

0000018e <APP_GetCardData>:

ATM_ERRORS_t APP_GetCardData(void)
{
     18e:	0f 93       	push	r16
     190:	1f 93       	push	r17
     192:	cf 93       	push	r28
     194:	df 93       	push	r29
     196:	ca ed       	ldi	r28, 0xDA	; 218
     198:	d7 e0       	ldi	r29, 0x07	; 7
     19a:	06 ef       	ldi	r16, 0xF6	; 246
     19c:	17 e0       	ldi	r17, 0x07	; 7
	uint8_t u8_received=0;	
	/* receive the Card Data frame that contains PAN & PIN & Card holder name */
	
	for(u8counter=0;u8counter<CARD_BUFFER_SIZE;u8counter++)
	{
	MCAL_SPIMasterReceive(&CardReceivedBuffer[u8counter]);
     19e:	ce 01       	movw	r24, r28
     1a0:	0e 94 d9 11 	call	0x23b2	; 0x23b2 <MCAL_SPIMasterReceive>
     1a4:	21 96       	adiw	r28, 0x01	; 1
	
	/* receive Data from the Card */
	uint8_t u8_received=0;	
	/* receive the Card Data frame that contains PAN & PIN & Card holder name */
	
	for(u8counter=0;u8counter<CARD_BUFFER_SIZE;u8counter++)
     1a6:	c0 17       	cp	r28, r16
     1a8:	d1 07       	cpc	r29, r17
     1aa:	c9 f7       	brne	.-14     	; 0x19e <APP_GetCardData+0x10>
	{
	MCAL_SPIMasterReceive(&CardReceivedBuffer[u8counter]);
	
	}	
		
}
     1ac:	df 91       	pop	r29
     1ae:	cf 91       	pop	r28
     1b0:	1f 91       	pop	r17
     1b2:	0f 91       	pop	r16
     1b4:	08 95       	ret

000001b6 <APP_ExtractDataFromFrame>:

ATM_ERRORS_t APP_ExtractDataFromFrame(void)
{
     1b6:	cf 93       	push	r28
     1b8:	df 93       	push	r29
	uint8_t u8_counter1=0;
	uint8_t u8_counter2=0;
	/* extract the Card state */
	if (CardReceivedBuffer[1]==55)
     1ba:	80 91 db 07 	lds	r24, 0x07DB	; 0x8007db <CardReceivedBuffer+0x1>
     1be:	87 33       	cpi	r24, 0x37	; 55
     1c0:	21 f4       	brne	.+8      	; 0x1ca <APP_ExtractDataFromFrame+0x14>
	{
		CardState = Initialized;
     1c2:	81 e0       	ldi	r24, 0x01	; 1
     1c4:	80 93 83 07 	sts	0x0783, r24	; 0x800783 <CardState>
     1c8:	12 c0       	rjmp	.+36     	; 0x1ee <APP_ExtractDataFromFrame+0x38>
	}
	else
	{
		CardState =NOT_Initialized;
     1ca:	10 92 83 07 	sts	0x0783, r1	; 0x800783 <CardState>
     1ce:	0f c0       	rjmp	.+30     	; 0x1ee <APP_ExtractDataFromFrame+0x38>
	/* Extract Card Holder Name */
	u8_counter2 =0;
	/* Name Data starts from the index 2 and end at index 11 in the frame */
	for (u8_counter1=2;u8_counter1<=11;u8_counter1++)
	{
		 Name_buffer[u8_counter2] = CardReceivedBuffer[u8_counter1];
     1d0:	8d 91       	ld	r24, X+
     1d2:	89 93       	st	Y+, r24
	}
	
	/* Extract Card Holder Name */
	u8_counter2 =0;
	/* Name Data starts from the index 2 and end at index 11 in the frame */
	for (u8_counter1=2;u8_counter1<=11;u8_counter1++)
     1d4:	ae 17       	cp	r26, r30
     1d6:	bf 07       	cpc	r27, r31
     1d8:	d9 f7       	brne	.-10     	; 0x1d0 <APP_ExtractDataFromFrame+0x1a>
     1da:	a6 ef       	ldi	r26, 0xF6	; 246
     1dc:	b7 e0       	ldi	r27, 0x07	; 7
     1de:	20 ef       	ldi	r18, 0xF0	; 240
     1e0:	37 e0       	ldi	r19, 0x07	; 7
	/* Extract the PAN from the frame */
	/*PAN Data starts from the index 12 and end at index 21 in the frame */
	u8_counter2 =0;
	for (u8_counter1=12;u8_counter1<=21;u8_counter1++)
	{
		PAN_buffer[u8_counter2] = CardReceivedBuffer[u8_counter1];
     1e2:	81 91       	ld	r24, Z+
     1e4:	8d 93       	st	X+, r24
		
	}
	/* Extract the PAN from the frame */
	/*PAN Data starts from the index 12 and end at index 21 in the frame */
	u8_counter2 =0;
	for (u8_counter1=12;u8_counter1<=21;u8_counter1++)
     1e6:	2e 17       	cp	r18, r30
     1e8:	3f 07       	cpc	r19, r31
     1ea:	d9 f7       	brne	.-10     	; 0x1e2 <APP_ExtractDataFromFrame+0x2c>
     1ec:	07 c0       	rjmp	.+14     	; 0x1fc <APP_ExtractDataFromFrame+0x46>
     1ee:	ac ed       	ldi	r26, 0xDC	; 220
     1f0:	b7 e0       	ldi	r27, 0x07	; 7
     1f2:	cc ec       	ldi	r28, 0xCC	; 204
     1f4:	d7 e0       	ldi	r29, 0x07	; 7
     1f6:	e6 ee       	ldi	r30, 0xE6	; 230
     1f8:	f7 e0       	ldi	r31, 0x07	; 7
     1fa:	ea cf       	rjmp	.-44     	; 0x1d0 <APP_ExtractDataFromFrame+0x1a>
	/* Extract the PIN from the frame */
	/*PAN Data starts from the index 12 and end at index 21 in the frame */
	u8_counter2 =0;
	for (u8_counter1=22;u8_counter1<=25;u8_counter1++)
	{
		PIN_buffer[u8_counter2] = CardReceivedBuffer[u8_counter1];
     1fc:	e0 e0       	ldi	r30, 0x00	; 0
     1fe:	f8 e0       	ldi	r31, 0x08	; 8
     200:	aa ed       	ldi	r26, 0xDA	; 218
     202:	b7 e0       	ldi	r27, 0x07	; 7
     204:	56 96       	adiw	r26, 0x16	; 22
     206:	8c 91       	ld	r24, X
     208:	56 97       	sbiw	r26, 0x16	; 22
     20a:	80 83       	st	Z, r24
     20c:	57 96       	adiw	r26, 0x17	; 23
     20e:	8c 91       	ld	r24, X
     210:	57 97       	sbiw	r26, 0x17	; 23
     212:	81 83       	std	Z+1, r24	; 0x01
     214:	58 96       	adiw	r26, 0x18	; 24
     216:	8c 91       	ld	r24, X
     218:	58 97       	sbiw	r26, 0x18	; 24
     21a:	82 83       	std	Z+2, r24	; 0x02
     21c:	59 96       	adiw	r26, 0x19	; 25
     21e:	8c 91       	ld	r24, X
     220:	83 83       	std	Z+3, r24	; 0x03
		u8_counter2++;
		
	}
	/* inset \0 at the end of the PIN */
	PIN_buffer[4]='\0';
     222:	14 82       	std	Z+4, r1	; 0x04
	
}
     224:	80 e0       	ldi	r24, 0x00	; 0
     226:	df 91       	pop	r29
     228:	cf 91       	pop	r28
     22a:	08 95       	ret

0000022c <APP_getPasswordFromUser>:

ATM_ERRORS_t APP_getPasswordFromUser(void)
{
     22c:	cf 93       	push	r28
	uint8_t u8_key;
	uint8_t u8counter=0;
     22e:	c0 e0       	ldi	r28, 0x00	; 0
	while(1)
	{
		u8_key=keyPad_GetKey();
     230:	0e 94 39 0b 	call	0x1672	; 0x1672 <keyPad_GetKey>
		/* nothing is pressed */
		if(u8_key =='A')
     234:	81 34       	cpi	r24, 0x41	; 65
     236:	e1 f3       	breq	.-8      	; 0x230 <APP_getPasswordFromUser+0x4>
		{
			continue;
		}
		else
		{
			UserPass[u8counter]= u8_key;
     238:	ec 2f       	mov	r30, r28
     23a:	f0 e0       	ldi	r31, 0x00	; 0
     23c:	ea 52       	subi	r30, 0x2A	; 42
     23e:	f8 4f       	sbci	r31, 0xF8	; 248
     240:	80 83       	st	Z, r24
			LCD_display_charcter('*');
     242:	8a e2       	ldi	r24, 0x2A	; 42
     244:	0e 94 ba 0c 	call	0x1974	; 0x1974 <LCD_display_charcter>
			u8counter++;
     248:	cf 5f       	subi	r28, 0xFF	; 255
			
	}
	
	if (u8counter==4)
     24a:	c4 30       	cpi	r28, 0x04	; 4
     24c:	89 f7       	brne	.-30     	; 0x230 <APP_getPasswordFromUser+0x4>
	}	
		
}
	
	
}
     24e:	cf 91       	pop	r28
     250:	08 95       	ret

00000252 <APP_CheckPasswordOfUser>:
{
	uint8_t u8_counter=0;
	uint8_t u8_flag=0;
	for(u8_counter=0;u8_counter<4;u8_counter++)
	{
		if (PIN_buffer[u8_counter]==UserPass[u8_counter])
     252:	90 91 00 08 	lds	r25, 0x0800	; 0x800800 <PIN_buffer>
     256:	80 91 d6 07 	lds	r24, 0x07D6	; 0x8007d6 <UserPass>
     25a:	98 13       	cpse	r25, r24
     25c:	0f c0       	rjmp	.+30     	; 0x27c <APP_CheckPasswordOfUser+0x2a>
     25e:	e1 e0       	ldi	r30, 0x01	; 1
     260:	f8 e0       	ldi	r31, 0x08	; 8
     262:	a7 ed       	ldi	r26, 0xD7	; 215
     264:	b7 e0       	ldi	r27, 0x07	; 7
     266:	24 e0       	ldi	r18, 0x04	; 4
     268:	38 e0       	ldi	r19, 0x08	; 8
     26a:	91 91       	ld	r25, Z+
     26c:	8d 91       	ld	r24, X+
     26e:	98 13       	cpse	r25, r24
     270:	07 c0       	rjmp	.+14     	; 0x280 <APP_CheckPasswordOfUser+0x2e>

ATM_ERRORS_t APP_CheckPasswordOfUser(void)
{
	uint8_t u8_counter=0;
	uint8_t u8_flag=0;
	for(u8_counter=0;u8_counter<4;u8_counter++)
     272:	e2 17       	cp	r30, r18
     274:	f3 07       	cpc	r31, r19
     276:	c9 f7       	brne	.-14     	; 0x26a <APP_CheckPasswordOfUser+0x18>
}

ATM_ERRORS_t APP_CheckPasswordOfUser(void)
{
	uint8_t u8_counter=0;
	uint8_t u8_flag=0;
     278:	90 e0       	ldi	r25, 0x00	; 0
     27a:	03 c0       	rjmp	.+6      	; 0x282 <APP_CheckPasswordOfUser+0x30>
		{
			continue;
		}
		else
		{
			u8_flag=1;
     27c:	91 e0       	ldi	r25, 0x01	; 1
     27e:	01 c0       	rjmp	.+2      	; 0x282 <APP_CheckPasswordOfUser+0x30>
     280:	91 e0       	ldi	r25, 0x01	; 1
     282:	81 e0       	ldi	r24, 0x01	; 1
     284:	91 30       	cpi	r25, 0x01	; 1
     286:	09 f4       	brne	.+2      	; 0x28a <APP_CheckPasswordOfUser+0x38>
     288:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
	{
		return NO_ERROR;
	}
}
     28a:	08 95       	ret

0000028c <DiplayAmountLCD>:

ATM_ERRORS_t DiplayAmountLCD(void)
{
     28c:	0f 93       	push	r16
     28e:	1f 93       	push	r17
     290:	cf 93       	push	r28
     292:	df 93       	push	r29
     294:	c4 ec       	ldi	r28, 0xC4	; 196
     296:	d7 e0       	ldi	r29, 0x07	; 7
     298:	0c ec       	ldi	r16, 0xCC	; 204
     29a:	17 e0       	ldi	r17, 0x07	; 7
	uint8_t u8_counter =0;
	for (u8_counter=0;u8_counter<8;u8_counter++)
	{
		LCD_display_charcter(AmountBuffer[u8_counter]);
     29c:	89 91       	ld	r24, Y+
     29e:	0e 94 ba 0c 	call	0x1974	; 0x1974 <LCD_display_charcter>
}

ATM_ERRORS_t DiplayAmountLCD(void)
{
	uint8_t u8_counter =0;
	for (u8_counter=0;u8_counter<8;u8_counter++)
     2a2:	c0 17       	cp	r28, r16
     2a4:	d1 07       	cpc	r29, r17
     2a6:	d1 f7       	brne	.-12     	; 0x29c <DiplayAmountLCD+0x10>
	{
		LCD_display_charcter(AmountBuffer[u8_counter]);
	}
	
}
     2a8:	df 91       	pop	r29
     2aa:	cf 91       	pop	r28
     2ac:	1f 91       	pop	r17
     2ae:	0f 91       	pop	r16
     2b0:	08 95       	ret

000002b2 <APP_GetUserAmount>:

ATM_ERRORS_t APP_GetUserAmount(void)
{
     2b2:	0f 93       	push	r16
     2b4:	1f 93       	push	r17
     2b6:	cf 93       	push	r28
     2b8:	df 93       	push	r29
     2ba:	91 e0       	ldi	r25, 0x01	; 1
     2bc:	80 e0       	ldi	r24, 0x00	; 0
		if (u8_counter==5)
		{
		 AmountBuffer[u8_counter]= '.';
		 continue;	
		}
		AmountBuffer[u8_counter]='x';
     2be:	28 e7       	ldi	r18, 0x78	; 120
	/* display amount format xxxxx.xx */
	for (u8_counter=0;u8_counter<8;u8_counter++)
	{
		if (u8_counter==5)
		{
		 AmountBuffer[u8_counter]= '.';
     2c0:	a4 ec       	ldi	r26, 0xC4	; 196
     2c2:	b7 e0       	ldi	r27, 0x07	; 7
     2c4:	3e e2       	ldi	r19, 0x2E	; 46
     2c6:	02 c0       	rjmp	.+4      	; 0x2cc <APP_GetUserAmount+0x1a>
     2c8:	8f 5f       	subi	r24, 0xFF	; 255
     2ca:	9f 5f       	subi	r25, 0xFF	; 255
	uint8_t u8_counter =0;
	uint8_t u8_flag =0;
	/* display amount format xxxxx.xx */
	for (u8_counter=0;u8_counter<8;u8_counter++)
	{
		if (u8_counter==5)
     2cc:	85 30       	cpi	r24, 0x05	; 5
     2ce:	21 f4       	brne	.+8      	; 0x2d8 <APP_GetUserAmount+0x26>
		{
		 AmountBuffer[u8_counter]= '.';
     2d0:	15 96       	adiw	r26, 0x05	; 5
     2d2:	3c 93       	st	X, r19
     2d4:	15 97       	sbiw	r26, 0x05	; 5
     2d6:	f8 cf       	rjmp	.-16     	; 0x2c8 <APP_GetUserAmount+0x16>
		 continue;	
		}
		AmountBuffer[u8_counter]='x';
     2d8:	e8 2f       	mov	r30, r24
     2da:	f0 e0       	ldi	r31, 0x00	; 0
     2dc:	ec 53       	subi	r30, 0x3C	; 60
     2de:	f8 4f       	sbci	r31, 0xF8	; 248
     2e0:	20 83       	st	Z, r18
ATM_ERRORS_t APP_GetUserAmount(void)
{
	uint8_t u8_counter =0;
	uint8_t u8_flag =0;
	/* display amount format xxxxx.xx */
	for (u8_counter=0;u8_counter<8;u8_counter++)
     2e2:	98 30       	cpi	r25, 0x08	; 8
     2e4:	88 f3       	brcs	.-30     	; 0x2c8 <APP_GetUserAmount+0x16>
		 AmountBuffer[u8_counter]= '.';
		 continue;	
		}
		AmountBuffer[u8_counter]='x';
	}
	LCD_clear_screen();
     2e6:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
	LCD_display_String("Enter amount :");
     2ea:	8a e7       	ldi	r24, 0x7A	; 122
     2ec:	90 e0       	ldi	r25, 0x00	; 0
     2ee:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
	LCD_GoTo_xy(1,0);
     2f2:	60 e0       	ldi	r22, 0x00	; 0
     2f4:	81 e0       	ldi	r24, 0x01	; 1
     2f6:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LCD_GoTo_xy>
	DiplayAmountLCD();
     2fa:	0e 94 46 01 	call	0x28c	; 0x28c <DiplayAmountLCD>
	uint8_t u8_key;
	u8_counter=0;
     2fe:	c0 e0       	ldi	r28, 0x00	; 0
		}
		else
		{
			if (u8_counter ==5)
			{
				AmountBuffer[u8_counter] ='.';
     300:	04 ec       	ldi	r16, 0xC4	; 196
     302:	17 e0       	ldi	r17, 0x07	; 7
     304:	de e2       	ldi	r29, 0x2E	; 46
	{
		
		
		
		
		u8_key=keyPad_GetKey();
     306:	0e 94 39 0b 	call	0x1672	; 0x1672 <keyPad_GetKey>
		
		
		/* nothing is pressed */
		if(u8_key =='A')
     30a:	81 34       	cpi	r24, 0x41	; 65
     30c:	e1 f3       	breq	.-8      	; 0x306 <APP_GetUserAmount+0x54>
			
			continue;
		}
		else
		{
			if (u8_counter ==5)
     30e:	c5 30       	cpi	r28, 0x05	; 5
     310:	59 f4       	brne	.+22     	; 0x328 <APP_GetUserAmount+0x76>
			{
				AmountBuffer[u8_counter] ='.';
     312:	f8 01       	movw	r30, r16
     314:	d5 83       	std	Z+5, r29	; 0x05
				u8_counter++;
				AmountBuffer[u8_counter]= u8_key;
     316:	86 83       	std	Z+6, r24	; 0x06
				LCD_GoTo_xy(1,0);
     318:	60 e0       	ldi	r22, 0x00	; 0
     31a:	81 e0       	ldi	r24, 0x01	; 1
     31c:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LCD_GoTo_xy>
				DiplayAmountLCD();
     320:	0e 94 46 01 	call	0x28c	; 0x28c <DiplayAmountLCD>
				u8_counter++;
     324:	c7 e0       	ldi	r28, 0x07	; 7
				continue;
     326:	ef cf       	rjmp	.-34     	; 0x306 <APP_GetUserAmount+0x54>
			}
			else
			{
				AmountBuffer[u8_counter]= u8_key;
     328:	ec 2f       	mov	r30, r28
     32a:	f0 e0       	ldi	r31, 0x00	; 0
     32c:	ec 53       	subi	r30, 0x3C	; 60
     32e:	f8 4f       	sbci	r31, 0xF8	; 248
     330:	80 83       	st	Z, r24
				LCD_GoTo_xy(1,0);
     332:	60 e0       	ldi	r22, 0x00	; 0
     334:	81 e0       	ldi	r24, 0x01	; 1
     336:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LCD_GoTo_xy>
				DiplayAmountLCD();
     33a:	0e 94 46 01 	call	0x28c	; 0x28c <DiplayAmountLCD>
				u8_counter++;
     33e:	cf 5f       	subi	r28, 0xFF	; 255
			}
			
			
		}
		
		if (u8_counter==8)
     340:	c8 30       	cpi	r28, 0x08	; 8
     342:	09 f7       	brne	.-62     	; 0x306 <APP_GetUserAmount+0x54>
     344:	e4 ec       	ldi	r30, 0xC4	; 196
     346:	f7 e0       	ldi	r31, 0x07	; 7
     348:	81 e0       	ldi	r24, 0x01	; 1
     34a:	02 c0       	rjmp	.+4      	; 0x350 <APP_GetUserAmount+0x9e>
     34c:	8f 5f       	subi	r24, 0xFF	; 255
     34e:	31 96       	adiw	r30, 0x01	; 1
		{
			u8_counter=0;
			for(u8_counter=0;u8_counter<8;u8_counter++)
			{   
				/* the dot */
				if (u8_counter ==5)
     350:	86 30       	cpi	r24, 0x06	; 6
     352:	e1 f3       	breq	.-8      	; 0x34c <APP_GetUserAmount+0x9a>
				{
					continue;
				}
				/* check entering non numeric values */
				if (AmountBuffer[u8_counter] >57 || AmountBuffer[u8_counter] < 48 )
     354:	90 81       	ld	r25, Z
     356:	90 53       	subi	r25, 0x30	; 48
     358:	9a 30       	cpi	r25, 0x0A	; 10
     35a:	20 f4       	brcc	.+8      	; 0x364 <APP_GetUserAmount+0xb2>
		}
		
		if (u8_counter==8)
		{
			u8_counter=0;
			for(u8_counter=0;u8_counter<8;u8_counter++)
     35c:	88 30       	cpi	r24, 0x08	; 8
     35e:	b0 f3       	brcs	.-20     	; 0x34c <APP_GetUserAmount+0x9a>
}

ATM_ERRORS_t APP_GetUserAmount(void)
{
	uint8_t u8_counter =0;
	uint8_t u8_flag =0;
     360:	90 e0       	ldi	r25, 0x00	; 0
     362:	01 c0       	rjmp	.+2      	; 0x366 <APP_GetUserAmount+0xb4>
					continue;
				}
				/* check entering non numeric values */
				if (AmountBuffer[u8_counter] >57 || AmountBuffer[u8_counter] < 48 )
				{
					u8_flag =1;
     364:	91 e0       	ldi	r25, 0x01	; 1
     366:	81 e0       	ldi	r24, 0x01	; 1
     368:	91 30       	cpi	r25, 0x01	; 1
     36a:	09 f4       	brne	.+2      	; 0x36e <APP_GetUserAmount+0xbc>
     36c:	80 e0       	ldi	r24, 0x00	; 0
		}
	
	}
	
	
}
     36e:	df 91       	pop	r29
     370:	cf 91       	pop	r28
     372:	1f 91       	pop	r17
     374:	0f 91       	pop	r16
     376:	08 95       	ret

00000378 <APP_floatTostringconvert>:

void APP_floatTostringconvert(float fLoatAmount, uint8_t *string)
{
     378:	cf 92       	push	r12
     37a:	df 92       	push	r13
     37c:	ef 92       	push	r14
     37e:	ff 92       	push	r15
     380:	0f 93       	push	r16
     382:	1f 93       	push	r17
     384:	cf 93       	push	r28
     386:	df 93       	push	r29
     388:	6b 01       	movw	r12, r22
     38a:	7c 01       	movw	r14, r24
     38c:	8a 01       	movw	r16, r20
	/* fraction part */
	float fractionPart;
	/* fraction part to integer */
	int Fint ;
	
	integerPart = (int)fLoatAmount;
     38e:	0e 94 42 14 	call	0x2884	; 0x2884 <__fixsfsi>
     392:	d6 2f       	mov	r29, r22
     394:	c7 2f       	mov	r28, r23
	fractionPart = fLoatAmount - integerPart;
	/* take 2 numbers after dot */ //ex .25 will be 25
	Fint =(int) (fractionPart*100.0);
     396:	07 2e       	mov	r0, r23
     398:	00 0c       	add	r0, r0
     39a:	88 0b       	sbc	r24, r24
     39c:	99 0b       	sbc	r25, r25
     39e:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <__floatsisf>
     3a2:	9b 01       	movw	r18, r22
     3a4:	ac 01       	movw	r20, r24
     3a6:	c7 01       	movw	r24, r14
     3a8:	b6 01       	movw	r22, r12
     3aa:	0e 94 5e 13 	call	0x26bc	; 0x26bc <__subsf3>
     3ae:	20 e0       	ldi	r18, 0x00	; 0
     3b0:	30 e0       	ldi	r19, 0x00	; 0
     3b2:	48 ec       	ldi	r20, 0xC8	; 200
     3b4:	52 e4       	ldi	r21, 0x42	; 66
     3b6:	0e 94 2f 15 	call	0x2a5e	; 0x2a5e <__mulsf3>
     3ba:	0e 94 42 14 	call	0x2884	; 0x2884 <__fixsfsi>
	
	int u8_counter =4;
	
	string[7]= (Fint%10)+48;
     3be:	cb 01       	movw	r24, r22
     3c0:	6a e0       	ldi	r22, 0x0A	; 10
     3c2:	70 e0       	ldi	r23, 0x00	; 0
     3c4:	0e 94 ac 15 	call	0x2b58	; 0x2b58 <__divmodhi4>
     3c8:	80 5d       	subi	r24, 0xD0	; 208
     3ca:	f8 01       	movw	r30, r16
     3cc:	87 83       	std	Z+7, r24	; 0x07
	string[6]= (Fint/10)+48;
     3ce:	60 5d       	subi	r22, 0xD0	; 208
     3d0:	66 83       	std	Z+6, r22	; 0x06
	string[5]='.';
     3d2:	8e e2       	ldi	r24, 0x2E	; 46
     3d4:	85 83       	std	Z+5, r24	; 0x05
     3d6:	35 96       	adiw	r30, 0x05	; 5
     3d8:	98 01       	movw	r18, r16
	for(u8_counter=4;u8_counter>=0;u8_counter--)
	{
		string[u8_counter] =(integerPart %10)+48;
     3da:	0a e0       	ldi	r16, 0x0A	; 10
     3dc:	10 e0       	ldi	r17, 0x00	; 0
     3de:	8d 2f       	mov	r24, r29
     3e0:	9c 2f       	mov	r25, r28
     3e2:	b8 01       	movw	r22, r16
     3e4:	0e 94 ac 15 	call	0x2b58	; 0x2b58 <__divmodhi4>
     3e8:	80 5d       	subi	r24, 0xD0	; 208
     3ea:	82 93       	st	-Z, r24
		integerPart =(integerPart/10);
     3ec:	d6 2f       	mov	r29, r22
     3ee:	c7 2f       	mov	r28, r23
	int u8_counter =4;
	
	string[7]= (Fint%10)+48;
	string[6]= (Fint/10)+48;
	string[5]='.';
	for(u8_counter=4;u8_counter>=0;u8_counter--)
     3f0:	e2 17       	cp	r30, r18
     3f2:	f3 07       	cpc	r31, r19
     3f4:	a1 f7       	brne	.-24     	; 0x3de <APP_floatTostringconvert+0x66>
		string[u8_counter] =(integerPart %10)+48;
		integerPart =(integerPart/10);
	}
	
	
}
     3f6:	df 91       	pop	r29
     3f8:	cf 91       	pop	r28
     3fa:	1f 91       	pop	r17
     3fc:	0f 91       	pop	r16
     3fe:	ff 90       	pop	r15
     400:	ef 90       	pop	r14
     402:	df 90       	pop	r13
     404:	cf 90       	pop	r12
     406:	08 95       	ret

00000408 <APP_CalPower>:

uint32_t APP_CalPower(uint8_t base , uint8_t power)
{
     408:	cf 92       	push	r12
     40a:	df 92       	push	r13
     40c:	ef 92       	push	r14
     40e:	ff 92       	push	r15
     410:	f6 2f       	mov	r31, r22
	uint8_t u8_counter=0;
	uint32_t u32_result=1;
	if (power ==0)
     412:	66 23       	and	r22, r22
     414:	a9 f0       	breq	.+42     	; 0x440 <APP_CalPower+0x38>
     416:	61 e0       	ldi	r22, 0x01	; 1
     418:	70 e0       	ldi	r23, 0x00	; 0
     41a:	40 e0       	ldi	r20, 0x00	; 0
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	e1 e0       	ldi	r30, 0x01	; 1
	}
	else
	{
		for(u8_counter=1;u8_counter<=power;u8_counter++)
		{
			u32_result =u32_result * base;
     420:	c8 2e       	mov	r12, r24
     422:	d1 2c       	mov	r13, r1
     424:	e1 2c       	mov	r14, r1
     426:	f1 2c       	mov	r15, r1
     428:	26 2f       	mov	r18, r22
     42a:	37 2f       	mov	r19, r23
     42c:	59 2f       	mov	r21, r25
     42e:	c7 01       	movw	r24, r14
     430:	b6 01       	movw	r22, r12
     432:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <__mulsi3>
     436:	48 2f       	mov	r20, r24
	{
		return 1;
	}
	else
	{
		for(u8_counter=1;u8_counter<=power;u8_counter++)
     438:	ef 5f       	subi	r30, 0xFF	; 255
     43a:	fe 17       	cp	r31, r30
     43c:	a8 f7       	brcc	.-22     	; 0x428 <APP_CalPower+0x20>
     43e:	04 c0       	rjmp	.+8      	; 0x448 <APP_CalPower+0x40>
{
	uint8_t u8_counter=0;
	uint32_t u32_result=1;
	if (power ==0)
	{
		return 1;
     440:	61 e0       	ldi	r22, 0x01	; 1
     442:	70 e0       	ldi	r23, 0x00	; 0
     444:	80 e0       	ldi	r24, 0x00	; 0
     446:	90 e0       	ldi	r25, 0x00	; 0
		{
			u32_result =u32_result * base;
		}
	}
	return u32_result;
}
     448:	ff 90       	pop	r15
     44a:	ef 90       	pop	r14
     44c:	df 90       	pop	r13
     44e:	cf 90       	pop	r12
     450:	08 95       	ret

00000452 <APP_stringToFloat>:

float APP_stringToFloat(uint8_t *string,uint8_t u8size)
{
     452:	8f 92       	push	r8
     454:	9f 92       	push	r9
     456:	af 92       	push	r10
     458:	bf 92       	push	r11
     45a:	cf 92       	push	r12
     45c:	df 92       	push	r13
     45e:	ef 92       	push	r14
     460:	ff 92       	push	r15
     462:	0f 93       	push	r16
     464:	1f 93       	push	r17
     466:	cf 93       	push	r28
     468:	df 93       	push	r29
     46a:	7c 01       	movw	r14, r24
     46c:	8c 01       	movw	r16, r24
     46e:	dc ef       	ldi	r29, 0xFC	; 252
     470:	d6 0f       	add	r29, r22
     472:	0f 2e       	mov	r0, r31
     474:	f7 ef       	ldi	r31, 0xF7	; 247
     476:	df 2e       	mov	r13, r31
     478:	f0 2d       	mov	r31, r0
     47a:	d6 0e       	add	r13, r22
	float fvalue;
	float fractionPart;
	uint8_t u8_counter =0;
	uint32_t integerPart=0 ;
     47c:	81 2c       	mov	r8, r1
     47e:	91 2c       	mov	r9, r1
     480:	54 01       	movw	r10, r8
	uint8_t intPartSize = u8size -3 ;  // in our case 5 
	for(u8_counter=0;u8_counter<5;u8_counter++)
	{
		integerPart =integerPart +( (string[u8_counter]-48)*(APP_CalPower(10,(intPartSize-u8_counter-1)))  ) ;
     482:	f8 01       	movw	r30, r16
     484:	c1 91       	ld	r28, Z+
     486:	8f 01       	movw	r16, r30
     488:	6d 2f       	mov	r22, r29
     48a:	8a e0       	ldi	r24, 0x0A	; 10
     48c:	0e 94 04 02 	call	0x408	; 0x408 <APP_CalPower>
     490:	9b 01       	movw	r18, r22
     492:	ac 01       	movw	r20, r24
     494:	ac 2f       	mov	r26, r28
     496:	b0 e0       	ldi	r27, 0x00	; 0
     498:	d0 97       	sbiw	r26, 0x30	; 48
     49a:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <__mulshisi3>
     49e:	86 0e       	add	r8, r22
     4a0:	97 1e       	adc	r9, r23
     4a2:	a8 1e       	adc	r10, r24
     4a4:	b9 1e       	adc	r11, r25
     4a6:	d1 50       	subi	r29, 0x01	; 1
	float fvalue;
	float fractionPart;
	uint8_t u8_counter =0;
	uint32_t integerPart=0 ;
	uint8_t intPartSize = u8size -3 ;  // in our case 5 
	for(u8_counter=0;u8_counter<5;u8_counter++)
     4a8:	dd 11       	cpse	r29, r13
     4aa:	eb cf       	rjmp	.-42     	; 0x482 <APP_stringToFloat+0x30>
	}
	fractionPart =( ((string[6]-48)*10) +(string[7]-48) ) /100.0;
	
	fvalue = integerPart + fractionPart;
	
	return fvalue;
     4ac:	f7 01       	movw	r30, r14
     4ae:	86 81       	ldd	r24, Z+6	; 0x06
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	c0 97       	sbiw	r24, 0x30	; 48
     4b4:	bc 01       	movw	r22, r24
     4b6:	66 0f       	add	r22, r22
     4b8:	77 1f       	adc	r23, r23
     4ba:	88 0f       	add	r24, r24
     4bc:	99 1f       	adc	r25, r25
     4be:	88 0f       	add	r24, r24
     4c0:	99 1f       	adc	r25, r25
     4c2:	88 0f       	add	r24, r24
     4c4:	99 1f       	adc	r25, r25
     4c6:	86 0f       	add	r24, r22
     4c8:	97 1f       	adc	r25, r23
     4ca:	67 81       	ldd	r22, Z+7	; 0x07
     4cc:	70 e0       	ldi	r23, 0x00	; 0
     4ce:	60 53       	subi	r22, 0x30	; 48
     4d0:	71 09       	sbc	r23, r1
     4d2:	68 0f       	add	r22, r24
     4d4:	79 1f       	adc	r23, r25
     4d6:	07 2e       	mov	r0, r23
     4d8:	00 0c       	add	r0, r0
     4da:	88 0b       	sbc	r24, r24
     4dc:	99 0b       	sbc	r25, r25
     4de:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <__floatsisf>
     4e2:	20 e0       	ldi	r18, 0x00	; 0
     4e4:	30 e0       	ldi	r19, 0x00	; 0
     4e6:	48 ec       	ldi	r20, 0xC8	; 200
     4e8:	52 e4       	ldi	r21, 0x42	; 66
     4ea:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <__divsf3>
     4ee:	6b 01       	movw	r12, r22
     4f0:	7c 01       	movw	r14, r24
     4f2:	c5 01       	movw	r24, r10
     4f4:	b4 01       	movw	r22, r8
     4f6:	0e 94 78 14 	call	0x28f0	; 0x28f0 <__floatunsisf>
     4fa:	9b 01       	movw	r18, r22
     4fc:	ac 01       	movw	r20, r24
     4fe:	c7 01       	movw	r24, r14
     500:	b6 01       	movw	r22, r12
     502:	0e 94 5f 13 	call	0x26be	; 0x26be <__addsf3>
	
	
}
     506:	df 91       	pop	r29
     508:	cf 91       	pop	r28
     50a:	1f 91       	pop	r17
     50c:	0f 91       	pop	r16
     50e:	ff 90       	pop	r15
     510:	ef 90       	pop	r14
     512:	df 90       	pop	r13
     514:	cf 90       	pop	r12
     516:	bf 90       	pop	r11
     518:	af 90       	pop	r10
     51a:	9f 90       	pop	r9
     51c:	8f 90       	pop	r8
     51e:	08 95       	ret

00000520 <APP_userPassHandler>:

ATM_ERRORS_t APP_userPassHandler(void)
{
     520:	cf 92       	push	r12
     522:	df 92       	push	r13
     524:	ef 92       	push	r14
     526:	ff 92       	push	r15
     528:	cf 93       	push	r28
     52a:	c1 2c       	mov	r12, r1
     52c:	d1 2c       	mov	r13, r1
     52e:	76 01       	movw	r14, r12
     530:	68 94       	set
     532:	c1 f8       	bld	r12, 1
	
	/* 3 Trial entering wrong password */
	
	for(u8_Counter=0;u8_Counter<3;u8_Counter++)
	{
		LCD_clear_screen();
     534:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
		LCD_display_String("Enter Password :");
     538:	89 e8       	ldi	r24, 0x89	; 137
     53a:	90 e0       	ldi	r25, 0x00	; 0
     53c:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
		LCD_GoTo_xy(1,0);
     540:	60 e0       	ldi	r22, 0x00	; 0
     542:	81 e0       	ldi	r24, 0x01	; 1
     544:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LCD_GoTo_xy>
		APP_getPasswordFromUser();
     548:	0e 94 16 01 	call	0x22c	; 0x22c <APP_getPasswordFromUser>
		
		if (APP_CheckPasswordOfUser()==NO_ERROR)
     54c:	0e 94 29 01 	call	0x252	; 0x252 <APP_CheckPasswordOfUser>
     550:	c8 2f       	mov	r28, r24
     552:	81 30       	cpi	r24, 0x01	; 1
     554:	29 f1       	breq	.+74     	; 0x5a0 <APP_userPassHandler+0x80>
			
			u8_flag=1;
			break;
			
		}
		LCD_clear_screen();
     556:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
		LCD_display_String("Wrong password");
     55a:	8a e9       	ldi	r24, 0x9A	; 154
     55c:	90 e0       	ldi	r25, 0x00	; 0
     55e:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
		LCD_GoTo_xy(1,0);
     562:	60 e0       	ldi	r22, 0x00	; 0
     564:	81 e0       	ldi	r24, 0x01	; 1
     566:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LCD_GoTo_xy>
		LCD_display_String("remaining try:");
     56a:	89 ea       	ldi	r24, 0xA9	; 169
     56c:	90 e0       	ldi	r25, 0x00	; 0
     56e:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
		LCD_DisplayInteger(3-u8_Counter-1);
     572:	c7 01       	movw	r24, r14
     574:	b6 01       	movw	r22, r12
     576:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <LCD_DisplayInteger>
		APP_Delay_ms(1000);
     57a:	68 ee       	ldi	r22, 0xE8	; 232
     57c:	73 e0       	ldi	r23, 0x03	; 3
     57e:	80 e0       	ldi	r24, 0x00	; 0
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
     586:	81 e0       	ldi	r24, 0x01	; 1
     588:	c8 1a       	sub	r12, r24
     58a:	d1 08       	sbc	r13, r1
     58c:	e1 08       	sbc	r14, r1
     58e:	f1 08       	sbc	r15, r1
	
	
	
	/* 3 Trial entering wrong password */
	
	for(u8_Counter=0;u8_Counter<3;u8_Counter++)
     590:	8f ef       	ldi	r24, 0xFF	; 255
     592:	c8 16       	cp	r12, r24
     594:	d8 06       	cpc	r13, r24
     596:	e8 06       	cpc	r14, r24
     598:	f8 06       	cpc	r15, r24
     59a:	61 f6       	brne	.-104    	; 0x534 <APP_userPassHandler+0x14>
		APP_Delay_ms(1000);
		return NO_ERROR;
	}
	else
	{
		return ERROR ;
     59c:	c0 e0       	ldi	r28, 0x00	; 0
     59e:	0c c0       	rjmp	.+24     	; 0x5b8 <APP_userPassHandler+0x98>
		APP_Delay_ms(1000);
		
	}
	if (u8_flag==1)
	{
		LCD_clear_screen();
     5a0:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
		LCD_display_String("Correct password");
     5a4:	88 eb       	ldi	r24, 0xB8	; 184
     5a6:	90 e0       	ldi	r25, 0x00	; 0
     5a8:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
		APP_Delay_ms(1000);
     5ac:	68 ee       	ldi	r22, 0xE8	; 232
     5ae:	73 e0       	ldi	r23, 0x03	; 3
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
	{
		return ERROR ;
		 /* 3 trial wrong pass */
		
	}
}
     5b8:	8c 2f       	mov	r24, r28
     5ba:	cf 91       	pop	r28
     5bc:	ff 90       	pop	r15
     5be:	ef 90       	pop	r14
     5c0:	df 90       	pop	r13
     5c2:	cf 90       	pop	r12
     5c4:	08 95       	ret

000005c6 <APP_GetMaxAmountFromDB>:

ATM_ERRORS_t APP_GetMaxAmountFromDB(void)
{
     5c6:	cf 93       	push	r28
     5c8:	df 93       	push	r29
	uint8_t u8_counter =0;
	uint16_t StartAdd = 2; // max amount starts from add 2 in DB
     5ca:	c2 e0       	ldi	r28, 0x02	; 2
     5cc:	d0 e0       	ldi	r29, 0x00	; 0
	for (u8_counter=0;u8_counter<8;u8_counter++)
	{
		APP_Delay_ms(20);
     5ce:	64 e1       	ldi	r22, 0x14	; 20
     5d0:	70 e0       	ldi	r23, 0x00	; 0
     5d2:	80 e0       	ldi	r24, 0x00	; 0
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
		ECUAL_EEPROMRead(StartAdd,&MAXamountBuffer[u8_counter]);
     5da:	be 01       	movw	r22, r28
     5dc:	6d 5f       	subi	r22, 0xFD	; 253
     5de:	77 4f       	sbci	r23, 0xF7	; 247
     5e0:	ce 01       	movw	r24, r28
     5e2:	0e 94 b8 0a 	call	0x1570	; 0x1570 <ECUAL_EEPROMRead>
		StartAdd++;
     5e6:	21 96       	adiw	r28, 0x01	; 1

ATM_ERRORS_t APP_GetMaxAmountFromDB(void)
{
	uint8_t u8_counter =0;
	uint16_t StartAdd = 2; // max amount starts from add 2 in DB
	for (u8_counter=0;u8_counter<8;u8_counter++)
     5e8:	ca 30       	cpi	r28, 0x0A	; 10
     5ea:	d1 05       	cpc	r29, r1
     5ec:	81 f7       	brne	.-32     	; 0x5ce <APP_GetMaxAmountFromDB+0x8>
		APP_Delay_ms(20);
		ECUAL_EEPROMRead(StartAdd,&MAXamountBuffer[u8_counter]);
		StartAdd++;
	}
	
}
     5ee:	df 91       	pop	r29
     5f0:	cf 91       	pop	r28
     5f2:	08 95       	ret

000005f4 <APP_checkMaxamount>:

ATM_ERRORS_t APP_checkMaxamount(void)
{
     5f4:	cf 92       	push	r12
     5f6:	df 92       	push	r13
     5f8:	ef 92       	push	r14
     5fa:	ff 92       	push	r15
     5fc:	cf 93       	push	r28
	float fuserAmount ;
	float fMaxAmount ;
	
	/* get max amount from Data base */
	APP_GetMaxAmountFromDB();
     5fe:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <APP_GetMaxAmountFromDB>
	
	 fuserAmount = APP_stringToFloat(AmountBuffer,8);
     602:	68 e0       	ldi	r22, 0x08	; 8
     604:	84 ec       	ldi	r24, 0xC4	; 196
     606:	97 e0       	ldi	r25, 0x07	; 7
     608:	0e 94 29 02 	call	0x452	; 0x452 <APP_stringToFloat>
     60c:	6b 01       	movw	r12, r22
     60e:	7c 01       	movw	r14, r24
	 fMaxAmount =  APP_stringToFloat(MAXamountBuffer,8);
     610:	68 e0       	ldi	r22, 0x08	; 8
     612:	85 e0       	ldi	r24, 0x05	; 5
     614:	98 e0       	ldi	r25, 0x08	; 8
     616:	0e 94 29 02 	call	0x452	; 0x452 <APP_stringToFloat>
     61a:	9b 01       	movw	r18, r22
     61c:	ac 01       	movw	r20, r24
     61e:	c1 e0       	ldi	r28, 0x01	; 1
     620:	c7 01       	movw	r24, r14
     622:	b6 01       	movw	r22, r12
     624:	0e 94 2a 15 	call	0x2a54	; 0x2a54 <__gesf2>
     628:	18 16       	cp	r1, r24
     62a:	0c f0       	brlt	.+2      	; 0x62e <APP_checkMaxamount+0x3a>
     62c:	c0 e0       	ldi	r28, 0x00	; 0
	 {
		 return NO_ERROR;
	 }
	 
	
}
     62e:	81 e0       	ldi	r24, 0x01	; 1
     630:	8c 27       	eor	r24, r28
     632:	cf 91       	pop	r28
     634:	ff 90       	pop	r15
     636:	ef 90       	pop	r14
     638:	df 90       	pop	r13
     63a:	cf 90       	pop	r12
     63c:	08 95       	ret

0000063e <APP_checkBalance>:

ATM_ERRORS_t APP_checkBalance(void)
{
     63e:	cf 92       	push	r12
     640:	df 92       	push	r13
     642:	ef 92       	push	r14
     644:	ff 92       	push	r15
     646:	cf 93       	push	r28
     648:	e8 eb       	ldi	r30, 0xB8	; 184
     64a:	f7 e0       	ldi	r31, 0x07	; 7
     64c:	a1 e9       	ldi	r26, 0x91	; 145
     64e:	b7 e0       	ldi	r27, 0x07	; 7
     650:	20 ec       	ldi	r18, 0xC0	; 192
     652:	37 e0       	ldi	r19, 0x07	; 7
	
	/* Get Balance from the Customer Data Buffer */
	for(u8_counter=0;u8_counter<8;u8_counter++)
	{       
		/* Balance starts from index 11 in the customer buffer */
		BalanceBuffer[u8_counter]= CustomerData[u8_counter+11];
     654:	81 91       	ld	r24, Z+
     656:	8d 93       	st	X+, r24
ATM_ERRORS_t APP_checkBalance(void)
{
	uint8_t u8_counter =0;
	
	/* Get Balance from the Customer Data Buffer */
	for(u8_counter=0;u8_counter<8;u8_counter++)
     658:	e2 17       	cp	r30, r18
     65a:	f3 07       	cpc	r31, r19
     65c:	d9 f7       	brne	.-10     	; 0x654 <APP_checkBalance+0x16>
	{       
		/* Balance starts from index 11 in the customer buffer */
		BalanceBuffer[u8_counter]= CustomerData[u8_counter+11];
	}
	 /* convert strings to float numbers */
	fBalance =APP_stringToFloat(BalanceBuffer,8);
     65e:	68 e0       	ldi	r22, 0x08	; 8
     660:	81 e9       	ldi	r24, 0x91	; 145
     662:	97 e0       	ldi	r25, 0x07	; 7
     664:	0e 94 29 02 	call	0x452	; 0x452 <APP_stringToFloat>
     668:	6b 01       	movw	r12, r22
     66a:	7c 01       	movw	r14, r24
     66c:	60 93 0d 08 	sts	0x080D, r22	; 0x80080d <fBalance>
     670:	70 93 0e 08 	sts	0x080E, r23	; 0x80080e <fBalance+0x1>
     674:	80 93 0f 08 	sts	0x080F, r24	; 0x80080f <fBalance+0x2>
     678:	90 93 10 08 	sts	0x0810, r25	; 0x800810 <fBalance+0x3>
	fAmount = APP_stringToFloat(AmountBuffer,8);
     67c:	68 e0       	ldi	r22, 0x08	; 8
     67e:	84 ec       	ldi	r24, 0xC4	; 196
     680:	97 e0       	ldi	r25, 0x07	; 7
     682:	0e 94 29 02 	call	0x452	; 0x452 <APP_stringToFloat>
     686:	9b 01       	movw	r18, r22
     688:	ac 01       	movw	r20, r24
     68a:	60 93 c0 07 	sts	0x07C0, r22	; 0x8007c0 <fAmount>
     68e:	70 93 c1 07 	sts	0x07C1, r23	; 0x8007c1 <fAmount+0x1>
     692:	80 93 c2 07 	sts	0x07C2, r24	; 0x8007c2 <fAmount+0x2>
     696:	90 93 c3 07 	sts	0x07C3, r25	; 0x8007c3 <fAmount+0x3>
     69a:	c1 e0       	ldi	r28, 0x01	; 1
     69c:	c7 01       	movw	r24, r14
     69e:	b6 01       	movw	r22, r12
     6a0:	0e 94 2a 15 	call	0x2a54	; 0x2a54 <__gesf2>
     6a4:	18 16       	cp	r1, r24
     6a6:	0c f0       	brlt	.+2      	; 0x6aa <APP_checkBalance+0x6c>
     6a8:	c0 e0       	ldi	r28, 0x00	; 0
	}
	else
	{
		return ERROR;
	}
}
     6aa:	8c 2f       	mov	r24, r28
     6ac:	cf 91       	pop	r28
     6ae:	ff 90       	pop	r15
     6b0:	ef 90       	pop	r14
     6b2:	df 90       	pop	r13
     6b4:	cf 90       	pop	r12
     6b6:	08 95       	ret

000006b8 <APP_GetCustomerID>:

uint16_t APP_GetCustomerID(void)
{
	uint16_t u16_CustomerID ;
	u16_CustomerID =(uint8_t)(CustomerData[0]);
     6b8:	ed ea       	ldi	r30, 0xAD	; 173
     6ba:	f7 e0       	ldi	r31, 0x07	; 7
     6bc:	80 81       	ld	r24, Z
	u16_CustomerID |=((CustomerData[1])<<8);
	return u16_CustomerID;
     6be:	21 81       	ldd	r18, Z+1	; 0x01
     6c0:	90 e0       	ldi	r25, 0x00	; 0
}
     6c2:	92 2b       	or	r25, r18
     6c4:	08 95       	ret

000006c6 <DisplayNewBalanceLCD>:

void DisplayNewBalanceLCD(void)
{ 
     6c6:	0f 93       	push	r16
     6c8:	1f 93       	push	r17
     6ca:	cf 93       	push	r28
     6cc:	df 93       	push	r29
	uint8_t u8_counter ;
	LCD_clear_screen();
     6ce:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
	LCD_display_String("The New Balance is:");
     6d2:	89 ec       	ldi	r24, 0xC9	; 201
     6d4:	90 e0       	ldi	r25, 0x00	; 0
     6d6:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
     6da:	c1 e9       	ldi	r28, 0x91	; 145
     6dc:	d7 e0       	ldi	r29, 0x07	; 7
     6de:	09 e9       	ldi	r16, 0x99	; 153
     6e0:	17 e0       	ldi	r17, 0x07	; 7
	for(u8_counter=0;u8_counter<8;u8_counter++)
	{
		LCD_display_charcter(BalanceBuffer[u8_counter]);
     6e2:	89 91       	ld	r24, Y+
     6e4:	0e 94 ba 0c 	call	0x1974	; 0x1974 <LCD_display_charcter>
void DisplayNewBalanceLCD(void)
{ 
	uint8_t u8_counter ;
	LCD_clear_screen();
	LCD_display_String("The New Balance is:");
	for(u8_counter=0;u8_counter<8;u8_counter++)
     6e8:	c0 17       	cp	r28, r16
     6ea:	d1 07       	cpc	r29, r17
     6ec:	d1 f7       	brne	.-12     	; 0x6e2 <DisplayNewBalanceLCD+0x1c>
	{
		LCD_display_charcter(BalanceBuffer[u8_counter]);
	}
	APP_Delay_ms(2000);
     6ee:	60 ed       	ldi	r22, 0xD0	; 208
     6f0:	77 e0       	ldi	r23, 0x07	; 7
     6f2:	80 e0       	ldi	r24, 0x00	; 0
     6f4:	90 e0       	ldi	r25, 0x00	; 0
     6f6:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
}
     6fa:	df 91       	pop	r29
     6fc:	cf 91       	pop	r28
     6fe:	1f 91       	pop	r17
     700:	0f 91       	pop	r16
     702:	08 95       	ret

00000704 <APP_ApproveTransaction>:

ATM_ERRORS_t APP_ApproveTransaction(void)
{
     704:	ef 92       	push	r14
     706:	ff 92       	push	r15
     708:	0f 93       	push	r16
     70a:	1f 93       	push	r17
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29

	uint8_t u8_counter =0;
	uint16_t u16_CustomerID ;
	/* subtract the amount from the balance */
	fBalance = fBalance -fAmount ;
     710:	20 91 c0 07 	lds	r18, 0x07C0	; 0x8007c0 <fAmount>
     714:	30 91 c1 07 	lds	r19, 0x07C1	; 0x8007c1 <fAmount+0x1>
     718:	40 91 c2 07 	lds	r20, 0x07C2	; 0x8007c2 <fAmount+0x2>
     71c:	50 91 c3 07 	lds	r21, 0x07C3	; 0x8007c3 <fAmount+0x3>
     720:	60 91 0d 08 	lds	r22, 0x080D	; 0x80080d <fBalance>
     724:	70 91 0e 08 	lds	r23, 0x080E	; 0x80080e <fBalance+0x1>
     728:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <fBalance+0x2>
     72c:	90 91 10 08 	lds	r25, 0x0810	; 0x800810 <fBalance+0x3>
     730:	0e 94 5e 13 	call	0x26bc	; 0x26bc <__subsf3>
     734:	60 93 0d 08 	sts	0x080D, r22	; 0x80080d <fBalance>
     738:	70 93 0e 08 	sts	0x080E, r23	; 0x80080e <fBalance+0x1>
     73c:	80 93 0f 08 	sts	0x080F, r24	; 0x80080f <fBalance+0x2>
     740:	90 93 10 08 	sts	0x0810, r25	; 0x800810 <fBalance+0x3>
	/* convert the new balance to string format */
	 APP_floatTostringconvert(fBalance,BalanceBuffer);
     744:	41 e9       	ldi	r20, 0x91	; 145
     746:	57 e0       	ldi	r21, 0x07	; 7
     748:	0e 94 bc 01 	call	0x378	; 0x378 <APP_floatTostringconvert>
	 
	 /* store the Customer Balance buffer for the current customer ID */
	 
	    /* Get the customer ID  */
	   u16_CustomerID = APP_GetCustomerID();
     74c:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <APP_GetCustomerID>
	 /* calculate start Address */
	 /* 2 bytes for total num of customer + 8 for max amount + 11 from start of customer data to start of his balance */
	 uint16_t u16_StratAdress ;     
	 u16_StratAdress = (((u16_CustomerID -1)*CustomerDataBuffersize)+21);
     750:	23 e1       	ldi	r18, 0x13	; 19
     752:	ac 01       	movw	r20, r24
     754:	24 9f       	mul	r18, r20
     756:	c0 01       	movw	r24, r0
     758:	25 9f       	mul	r18, r21
     75a:	90 0d       	add	r25, r0
     75c:	11 24       	eor	r1, r1
     75e:	ec 01       	movw	r28, r24
     760:	22 96       	adiw	r28, 0x02	; 2
     762:	01 e9       	ldi	r16, 0x91	; 145
     764:	17 e0       	ldi	r17, 0x07	; 7
     766:	0f 2e       	mov	r0, r31
     768:	f9 e9       	ldi	r31, 0x99	; 153
     76a:	ef 2e       	mov	r14, r31
     76c:	f7 e0       	ldi	r31, 0x07	; 7
     76e:	ff 2e       	mov	r15, r31
     770:	f0 2d       	mov	r31, r0
	 /* store the new balance */
	 for(u8_counter=0;u8_counter<8;u8_counter++)
	 {
		 APP_Delay_ms(20);
     772:	64 e1       	ldi	r22, 0x14	; 20
     774:	70 e0       	ldi	r23, 0x00	; 0
     776:	80 e0       	ldi	r24, 0x00	; 0
     778:	90 e0       	ldi	r25, 0x00	; 0
     77a:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
		 ECUAL_EEPROMWrite(u16_StratAdress,BalanceBuffer[u8_counter]);
     77e:	f8 01       	movw	r30, r16
     780:	61 91       	ld	r22, Z+
     782:	8f 01       	movw	r16, r30
     784:	ce 01       	movw	r24, r28
     786:	0e 94 98 0a 	call	0x1530	; 0x1530 <ECUAL_EEPROMWrite>
		 u16_StratAdress++;
     78a:	21 96       	adiw	r28, 0x01	; 1
	 /* calculate start Address */
	 /* 2 bytes for total num of customer + 8 for max amount + 11 from start of customer data to start of his balance */
	 uint16_t u16_StratAdress ;     
	 u16_StratAdress = (((u16_CustomerID -1)*CustomerDataBuffersize)+21);
	 /* store the new balance */
	 for(u8_counter=0;u8_counter<8;u8_counter++)
     78c:	0e 15       	cp	r16, r14
     78e:	1f 05       	cpc	r17, r15
     790:	81 f7       	brne	.-32     	; 0x772 <APP_ApproveTransaction+0x6e>
		 ECUAL_EEPROMWrite(u16_StratAdress,BalanceBuffer[u8_counter]);
		 u16_StratAdress++;
	 }
	 
	 return NO_ERROR;
}
     792:	81 e0       	ldi	r24, 0x01	; 1
     794:	df 91       	pop	r29
     796:	cf 91       	pop	r28
     798:	1f 91       	pop	r17
     79a:	0f 91       	pop	r16
     79c:	ff 90       	pop	r15
     79e:	ef 90       	pop	r14
     7a0:	08 95       	ret

000007a2 <APP_ReceiveFromTerminal>:
	}
}

/* Receive Message From the terminal */
 uint8_t APP_ReceiveFromTerminal(void)
{
     7a2:	ef 92       	push	r14
     7a4:	ff 92       	push	r15
     7a6:	0f 93       	push	r16
     7a8:	1f 93       	push	r17
     7aa:	cf 93       	push	r28
	/* counter */
	uint8_t u8_counter = 0;
	/* string size */
	uint8_t u8_STRSize=0;
	/* start receiving */
	USART_Receive(&TerminalBuffer[u8_counter]);
     7ac:	89 e9       	ldi	r24, 0x99	; 153
     7ae:	97 e0       	ldi	r25, 0x07	; 7
     7b0:	0e 94 d7 12 	call	0x25ae	; 0x25ae <USART_Receive>
	
	/* check ENTER Key is pressed that is an indicator to the end of string */
	while(TerminalBuffer[u8_counter] != '\r')
     7b4:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <TerminalBuffer>
     7b8:	8d 30       	cpi	r24, 0x0D	; 13
     7ba:	79 f0       	breq	.+30     	; 0x7da <APP_ReceiveFromTerminal+0x38>
     7bc:	c0 e0       	ldi	r28, 0x00	; 0
	{
		u8_counter++;
     7be:	cf 5f       	subi	r28, 0xFF	; 255
		USART_Receive(&TerminalBuffer[u8_counter]);
     7c0:	ec 2e       	mov	r14, r28
     7c2:	f1 2c       	mov	r15, r1
     7c4:	87 01       	movw	r16, r14
     7c6:	07 56       	subi	r16, 0x67	; 103
     7c8:	18 4f       	sbci	r17, 0xF8	; 248
     7ca:	c8 01       	movw	r24, r16
     7cc:	0e 94 d7 12 	call	0x25ae	; 0x25ae <USART_Receive>
	uint8_t u8_STRSize=0;
	/* start receiving */
	USART_Receive(&TerminalBuffer[u8_counter]);
	
	/* check ENTER Key is pressed that is an indicator to the end of string */
	while(TerminalBuffer[u8_counter] != '\r')
     7d0:	f8 01       	movw	r30, r16
     7d2:	80 81       	ld	r24, Z
     7d4:	8d 30       	cpi	r24, 0x0D	; 13
     7d6:	99 f7       	brne	.-26     	; 0x7be <APP_ReceiveFromTerminal+0x1c>
     7d8:	03 c0       	rjmp	.+6      	; 0x7e0 <APP_ReceiveFromTerminal+0x3e>
     7da:	e1 2c       	mov	r14, r1
     7dc:	f1 2c       	mov	r15, r1
 uint8_t APP_ReceiveFromTerminal(void)
{
	
	 
	/* counter */
	uint8_t u8_counter = 0;
     7de:	c0 e0       	ldi	r28, 0x00	; 0
	/* ENTER key is pressed in the terminal */
	if (TerminalBuffer[u8_counter] == '\r')
	{
		/* close the string by adding null indicator */
		
		TerminalBuffer[u8_counter] = '\0';
     7e0:	f7 01       	movw	r30, r14
     7e2:	e7 56       	subi	r30, 0x67	; 103
     7e4:	f8 4f       	sbci	r31, 0xF8	; 248
     7e6:	10 82       	st	Z, r1
	}
	u8_STRSize =(u8_counter+1);
	/* return string size */
	return u8_STRSize ;
}
     7e8:	81 e0       	ldi	r24, 0x01	; 1
     7ea:	8c 0f       	add	r24, r28
     7ec:	cf 91       	pop	r28
     7ee:	1f 91       	pop	r17
     7f0:	0f 91       	pop	r16
     7f2:	ff 90       	pop	r15
     7f4:	ef 90       	pop	r14
     7f6:	08 95       	ret

000007f8 <APP_ReceiveBalance>:


ATM_ERRORS_t APP_ReceiveBalance(void)
{
     7f8:	cf 93       	push	r28
     7fa:	df 93       	push	r29
		for (u8_counter=0;u8_counter<8;u8_counter++)
		{
			/* check the dot */
			if (u8_counter==5)
			{
				if (TerminalBuffer[u8_counter]=='.')
     7fc:	c9 e9       	ldi	r28, 0x99	; 153
     7fe:	d7 e0       	ldi	r29, 0x07	; 7
	uint8_t u8_flag =0;
	while(1)
	{
		u8_flag=0;
		
		APP_APPToTerminalResponse("please Enter Customer Balance in format xxxxx.xx\r");
     800:	8d ed       	ldi	r24, 0xDD	; 221
     802:	90 e0       	ldi	r25, 0x00	; 0
     804:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
		u8_SIZE=APP_ReceiveFromTerminal();
     808:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <APP_ReceiveFromTerminal>
		if (u8_SIZE >9 || u8_SIZE< 9)
     80c:	89 30       	cpi	r24, 0x09	; 9
     80e:	29 f0       	breq	.+10     	; 0x81a <APP_ReceiveBalance+0x22>
		{
			APP_APPToTerminalResponse("Invalid Balance Formate ,Balance must be in format xxxxx.xx\r");
     810:	8f e0       	ldi	r24, 0x0F	; 15
     812:	91 e0       	ldi	r25, 0x01	; 1
     814:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
			u8_flag =1;
			continue;
     818:	f3 cf       	rjmp	.-26     	; 0x800 <APP_ReceiveBalance+0x8>
		for (u8_counter=0;u8_counter<8;u8_counter++)
		{
			/* check the dot */
			if (u8_counter==5)
			{
				if (TerminalBuffer[u8_counter]=='.')
     81a:	2d 81       	ldd	r18, Y+5	; 0x05
     81c:	a9 e9       	ldi	r26, 0x99	; 153
     81e:	b7 e0       	ldi	r27, 0x07	; 7
     820:	fd 01       	movw	r30, r26
     822:	91 e0       	ldi	r25, 0x01	; 1
     824:	02 c0       	rjmp	.+4      	; 0x82a <APP_ReceiveBalance+0x32>
     826:	9f 5f       	subi	r25, 0xFF	; 255
     828:	31 96       	adiw	r30, 0x01	; 1
		}
		/* check that Balance contains only numbers except the dot sign in the index 5 */
		for (u8_counter=0;u8_counter<8;u8_counter++)
		{
			/* check the dot */
			if (u8_counter==5)
     82a:	96 30       	cpi	r25, 0x06	; 6
     82c:	39 f4       	brne	.+14     	; 0x83c <APP_ReceiveBalance+0x44>
			{
				if (TerminalBuffer[u8_counter]=='.')
     82e:	2e 32       	cpi	r18, 0x2E	; 46
     830:	d1 f3       	breq	.-12     	; 0x826 <APP_ReceiveBalance+0x2e>
				{
					continue;
				}
				else{
						APP_APPToTerminalResponse("Invalid Balance Formate ,Balance must be in format xxxxx.xx\r");
     832:	8f e0       	ldi	r24, 0x0F	; 15
     834:	91 e0       	ldi	r25, 0x01	; 1
     836:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
						u8_flag =1;
						break;
     83a:	e2 cf       	rjmp	.-60     	; 0x800 <APP_ReceiveBalance+0x8>
				    }
			}
			/* check if the Balance within numeric characters range or not */
			if (TerminalBuffer[u8_counter] >57 || TerminalBuffer[u8_counter] < 48 )
     83c:	80 81       	ld	r24, Z
     83e:	80 53       	subi	r24, 0x30	; 48
     840:	8a 30       	cpi	r24, 0x0A	; 10
     842:	28 f0       	brcs	.+10     	; 0x84e <APP_ReceiveBalance+0x56>
			{
				APP_APPToTerminalResponse("Invalid Balance Formate , Balance must not contain any characters\r");
     844:	8c e4       	ldi	r24, 0x4C	; 76
     846:	91 e0       	ldi	r25, 0x01	; 1
     848:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
				u8_flag =1;
				break;
     84c:	d9 cf       	rjmp	.-78     	; 0x800 <APP_ReceiveBalance+0x8>
			APP_APPToTerminalResponse("Invalid Balance Formate ,Balance must be in format xxxxx.xx\r");
			u8_flag =1;
			continue;
		}
		/* check that Balance contains only numbers except the dot sign in the index 5 */
		for (u8_counter=0;u8_counter<8;u8_counter++)
     84e:	98 30       	cpi	r25, 0x08	; 8
     850:	50 f3       	brcs	.-44     	; 0x826 <APP_ReceiveBalance+0x2e>
     852:	e8 eb       	ldi	r30, 0xB8	; 184
     854:	f7 e0       	ldi	r31, 0x07	; 7
     856:	20 ec       	ldi	r18, 0xC0	; 192
     858:	37 e0       	ldi	r19, 0x07	; 7
		{
			/* store to data buffer */
			for(u8_counter=0;u8_counter<8;u8_counter++)
			{
				/* Balance starts at index 10 to index 18 in the CustomerData buffer */
				CustomerData[u8_counter+11] = TerminalBuffer[u8_counter];
     85a:	8d 91       	ld	r24, X+
     85c:	81 93       	st	Z+, r24
			continue;
		}
		else if (u8_flag==0)
		{
			/* store to data buffer */
			for(u8_counter=0;u8_counter<8;u8_counter++)
     85e:	e2 17       	cp	r30, r18
     860:	f3 07       	cpc	r31, r19
     862:	d9 f7       	brne	.-10     	; 0x85a <APP_ReceiveBalance+0x62>
		
		
		
	}
	
}
     864:	81 e0       	ldi	r24, 0x01	; 1
     866:	df 91       	pop	r29
     868:	cf 91       	pop	r28
     86a:	08 95       	ret

0000086c <APP_UpdateMaxAmount>:

ATM_ERRORS_t APP_UpdateMaxAmount(void)
{
     86c:	0f 93       	push	r16
     86e:	1f 93       	push	r17
     870:	cf 93       	push	r28
     872:	df 93       	push	r29
		for (u8_counter=0;u8_counter<8;u8_counter++)
		{
			/* check the dot */
			if (u8_counter==5)
			{
				if (TerminalBuffer[u8_counter]=='.')
     874:	c9 e9       	ldi	r28, 0x99	; 153
     876:	d7 e0       	ldi	r29, 0x07	; 7
	uint8_t u8_flag =0;
	while(1)
	{
		u8_flag=0;
		
		APP_APPToTerminalResponse("please Enter Max amount in format xxxxx.xx\r");
     878:	8f e8       	ldi	r24, 0x8F	; 143
     87a:	91 e0       	ldi	r25, 0x01	; 1
     87c:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
		u8_SIZE=APP_ReceiveFromTerminal();
     880:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <APP_ReceiveFromTerminal>
		if (u8_SIZE >9 || u8_SIZE< 9)
     884:	89 30       	cpi	r24, 0x09	; 9
     886:	29 f0       	breq	.+10     	; 0x892 <APP_UpdateMaxAmount+0x26>
		{
			APP_APPToTerminalResponse("Invalid amount Formate ,amount must be in format xxxxx.xx\r");
     888:	8b eb       	ldi	r24, 0xBB	; 187
     88a:	91 e0       	ldi	r25, 0x01	; 1
     88c:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
			u8_flag =1;
			continue;
     890:	f3 cf       	rjmp	.-26     	; 0x878 <APP_UpdateMaxAmount+0xc>
		for (u8_counter=0;u8_counter<8;u8_counter++)
		{
			/* check the dot */
			if (u8_counter==5)
			{
				if (TerminalBuffer[u8_counter]=='.')
     892:	2d 81       	ldd	r18, Y+5	; 0x05
     894:	09 e9       	ldi	r16, 0x99	; 153
     896:	17 e0       	ldi	r17, 0x07	; 7
     898:	f8 01       	movw	r30, r16
     89a:	91 e0       	ldi	r25, 0x01	; 1
     89c:	02 c0       	rjmp	.+4      	; 0x8a2 <APP_UpdateMaxAmount+0x36>
     89e:	9f 5f       	subi	r25, 0xFF	; 255
     8a0:	31 96       	adiw	r30, 0x01	; 1
		}
		/* check that amount contains only numbers except the dot sign in the index 5 */
		for (u8_counter=0;u8_counter<8;u8_counter++)
		{
			/* check the dot */
			if (u8_counter==5)
     8a2:	96 30       	cpi	r25, 0x06	; 6
     8a4:	39 f4       	brne	.+14     	; 0x8b4 <APP_UpdateMaxAmount+0x48>
			{
				if (TerminalBuffer[u8_counter]=='.')
     8a6:	2e 32       	cpi	r18, 0x2E	; 46
     8a8:	d1 f3       	breq	.-12     	; 0x89e <APP_UpdateMaxAmount+0x32>
				{
					continue;
				}
				else{
					APP_APPToTerminalResponse("Invalid amount Formate ,amount must be in format xxxxx.xx\r");
     8aa:	8b eb       	ldi	r24, 0xBB	; 187
     8ac:	91 e0       	ldi	r25, 0x01	; 1
     8ae:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
					u8_flag =1;
					break;
     8b2:	e2 cf       	rjmp	.-60     	; 0x878 <APP_UpdateMaxAmount+0xc>
				}
			}
			/* check if the amount within numeric characters range or not */
			if (TerminalBuffer[u8_counter] >57 || TerminalBuffer[u8_counter] < 48 )
     8b4:	80 81       	ld	r24, Z
     8b6:	80 53       	subi	r24, 0x30	; 48
     8b8:	8a 30       	cpi	r24, 0x0A	; 10
     8ba:	28 f0       	brcs	.+10     	; 0x8c6 <APP_UpdateMaxAmount+0x5a>
			{
				APP_APPToTerminalResponse("Invalid amount Formate , amount must not contain any characters\r");
     8bc:	86 ef       	ldi	r24, 0xF6	; 246
     8be:	91 e0       	ldi	r25, 0x01	; 1
     8c0:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
				u8_flag =1;
				break;
     8c4:	d9 cf       	rjmp	.-78     	; 0x878 <APP_UpdateMaxAmount+0xc>
			APP_APPToTerminalResponse("Invalid amount Formate ,amount must be in format xxxxx.xx\r");
			u8_flag =1;
			continue;
		}
		/* check that amount contains only numbers except the dot sign in the index 5 */
		for (u8_counter=0;u8_counter<8;u8_counter++)
     8c6:	98 30       	cpi	r25, 0x08	; 8
     8c8:	50 f3       	brcs	.-44     	; 0x89e <APP_UpdateMaxAmount+0x32>
     8ca:	c2 e0       	ldi	r28, 0x02	; 2
     8cc:	d0 e0       	ldi	r29, 0x00	; 0
			uint16_t u16_address=2;
			/* store to data buffer */
			for(u8_counter=0;u8_counter<8;u8_counter++)
			{
				/* Max amount will be stored from the address 0x0002 to 0x0009 */
				ECUAL_EEPROMWrite(u16_address,TerminalBuffer[u8_counter]);
     8ce:	f8 01       	movw	r30, r16
     8d0:	61 91       	ld	r22, Z+
     8d2:	8f 01       	movw	r16, r30
     8d4:	ce 01       	movw	r24, r28
     8d6:	0e 94 98 0a 	call	0x1530	; 0x1530 <ECUAL_EEPROMWrite>
				u16_address++;
     8da:	21 96       	adiw	r28, 0x01	; 1
				APP_Delay_ms(50);
     8dc:	62 e3       	ldi	r22, 0x32	; 50
     8de:	70 e0       	ldi	r23, 0x00	; 0
     8e0:	80 e0       	ldi	r24, 0x00	; 0
     8e2:	90 e0       	ldi	r25, 0x00	; 0
     8e4:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
		}
		else if (u8_flag==0)
		{
			uint16_t u16_address=2;
			/* store to data buffer */
			for(u8_counter=0;u8_counter<8;u8_counter++)
     8e8:	ca 30       	cpi	r28, 0x0A	; 10
     8ea:	d1 05       	cpc	r29, r1
     8ec:	81 f7       	brne	.-32     	; 0x8ce <APP_UpdateMaxAmount+0x62>
		}
		
		
		
	}
}
     8ee:	81 e0       	ldi	r24, 0x01	; 1
     8f0:	df 91       	pop	r29
     8f2:	cf 91       	pop	r28
     8f4:	1f 91       	pop	r17
     8f6:	0f 91       	pop	r16
     8f8:	08 95       	ret

000008fa <APP_receivePAN>:

ATM_ERRORS_t APP_receivePAN(void)
{
     8fa:	ef 92       	push	r14
     8fc:	ff 92       	push	r15
     8fe:	0f 93       	push	r16
     900:	1f 93       	push	r17
     902:	cf 93       	push	r28
     904:	df 93       	push	r29
	uint8_t u8_counter=0;
	uint8_t u8_SIZE =0;
	uint8_t u8_flag =0;
	while(1)
	{
		u8_flag=0;
     906:	e1 2c       	mov	r14, r1
	
	  u8_SIZE=APP_ReceiveFromTerminal();
	  if (u8_SIZE >10 || u8_SIZE< 10)
	  {
		  APP_APPToTerminalResponse("Invalid PAN Formate , PAN must be 9 numbers\r");
		  u8_flag =1;
     908:	ff 24       	eor	r15, r15
     90a:	f3 94       	inc	r15
	  }
	  /* check that PAN contains only numbers */
	  for (u8_counter=0;u8_counter<9;u8_counter++)
	  {
		   /* check if the PAN within numeric characters or not */
		   if (TerminalBuffer[u8_counter] >57 || TerminalBuffer[u8_counter] < 48 )
     90c:	09 e9       	ldi	r16, 0x99	; 153
     90e:	17 e0       	ldi	r17, 0x07	; 7
     910:	c2 ea       	ldi	r28, 0xA2	; 162
     912:	d7 e0       	ldi	r29, 0x07	; 7
	uint8_t u8_flag =0;
	while(1)
	{
		u8_flag=0;
	
	APP_APPToTerminalResponse("please Enter Customer PAN Number\r");
     914:	87 e3       	ldi	r24, 0x37	; 55
     916:	92 e0       	ldi	r25, 0x02	; 2
     918:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	
	  u8_SIZE=APP_ReceiveFromTerminal();
     91c:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <APP_ReceiveFromTerminal>
	  if (u8_SIZE >10 || u8_SIZE< 10)
     920:	8a 30       	cpi	r24, 0x0A	; 10
     922:	31 f0       	breq	.+12     	; 0x930 <APP_receivePAN+0x36>
	  {
		  APP_APPToTerminalResponse("Invalid PAN Formate , PAN must be 9 numbers\r");
     924:	89 e5       	ldi	r24, 0x59	; 89
     926:	92 e0       	ldi	r25, 0x02	; 2
     928:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
		  u8_flag =1;
     92c:	9f 2d       	mov	r25, r15
     92e:	01 c0       	rjmp	.+2      	; 0x932 <APP_receivePAN+0x38>
	uint8_t u8_counter=0;
	uint8_t u8_SIZE =0;
	uint8_t u8_flag =0;
	while(1)
	{
		u8_flag=0;
     930:	9e 2d       	mov	r25, r14
	  }
	  /* check that PAN contains only numbers */
	  for (u8_counter=0;u8_counter<9;u8_counter++)
	  {
		   /* check if the PAN within numeric characters or not */
		   if (TerminalBuffer[u8_counter] >57 || TerminalBuffer[u8_counter] < 48 )
     932:	f8 01       	movw	r30, r16
     934:	80 81       	ld	r24, Z
     936:	80 53       	subi	r24, 0x30	; 48
     938:	8a 30       	cpi	r24, 0x0A	; 10
     93a:	30 f4       	brcc	.+12     	; 0x948 <APP_receivePAN+0x4e>
     93c:	ea e9       	ldi	r30, 0x9A	; 154
     93e:	f7 e0       	ldi	r31, 0x07	; 7
     940:	81 91       	ld	r24, Z+
     942:	80 53       	subi	r24, 0x30	; 48
     944:	8a 30       	cpi	r24, 0x0A	; 10
     946:	28 f0       	brcs	.+10     	; 0x952 <APP_receivePAN+0x58>
		   {
			   APP_APPToTerminalResponse("Invalid PAN Formate , PAN must not contain any characters\r");
     948:	86 e8       	ldi	r24, 0x86	; 134
     94a:	92 e0       	ldi	r25, 0x02	; 2
     94c:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
     950:	e1 cf       	rjmp	.-62     	; 0x914 <APP_receivePAN+0x1a>
	  {
		  APP_APPToTerminalResponse("Invalid PAN Formate , PAN must be 9 numbers\r");
		  u8_flag =1;
	  }
	  /* check that PAN contains only numbers */
	  for (u8_counter=0;u8_counter<9;u8_counter++)
     952:	ec 17       	cp	r30, r28
     954:	fd 07       	cpc	r31, r29
     956:	a1 f7       	brne	.-24     	; 0x940 <APP_receivePAN+0x46>
	  
	  if (u8_flag==1)
	  {
		  continue;
	  }
	  else if (u8_flag==0)
     958:	91 11       	cpse	r25, r1
     95a:	dc cf       	rjmp	.-72     	; 0x914 <APP_receivePAN+0x1a>
     95c:	a9 e9       	ldi	r26, 0x99	; 153
     95e:	b7 e0       	ldi	r27, 0x07	; 7
     960:	ef ea       	ldi	r30, 0xAF	; 175
     962:	f7 e0       	ldi	r31, 0x07	; 7
     964:	28 eb       	ldi	r18, 0xB8	; 184
     966:	37 e0       	ldi	r19, 0x07	; 7
	  {
		  /* store to data buffer */
		  for(u8_counter=0;u8_counter<9;u8_counter++)
		  {   
			  /* PAN starts at index 2 to index 10 in the CustomerData buffer */
			  CustomerData[u8_counter+2] = TerminalBuffer[u8_counter];
     968:	8d 91       	ld	r24, X+
     96a:	81 93       	st	Z+, r24
		  continue;
	  }
	  else if (u8_flag==0)
	  {
		  /* store to data buffer */
		  for(u8_counter=0;u8_counter<9;u8_counter++)
     96c:	e2 17       	cp	r30, r18
     96e:	f3 07       	cpc	r31, r19
     970:	d9 f7       	brne	.-10     	; 0x968 <APP_receivePAN+0x6e>
	  }
	 
	  
	  
	}
}
     972:	81 e0       	ldi	r24, 0x01	; 1
     974:	df 91       	pop	r29
     976:	cf 91       	pop	r28
     978:	1f 91       	pop	r17
     97a:	0f 91       	pop	r16
     97c:	ff 90       	pop	r15
     97e:	ef 90       	pop	r14
     980:	08 95       	ret

00000982 <APP_NumberofStoredCustomers>:
	
}


uint16_t APP_NumberofStoredCustomers(void)
{
     982:	0f 93       	push	r16
     984:	1f 93       	push	r17
     986:	cf 93       	push	r28
     988:	df 93       	push	r29
     98a:	00 d0       	rcall	.+0      	; 0x98c <APP_NumberofStoredCustomers+0xa>
     98c:	cd b7       	in	r28, 0x3d	; 61
     98e:	de b7       	in	r29, 0x3e	; 62
	uint16_t u16_CustomersNumber =0;
	uint16_t u6_temp =0;
     990:	1a 82       	std	Y+2, r1	; 0x02
     992:	19 82       	std	Y+1, r1	; 0x01
	/* Read the first 2 locations in the memory that represents the number of customers */
	/* first byte */
	ECUAL_EEPROMRead(0,&u6_temp);
     994:	be 01       	movw	r22, r28
     996:	6f 5f       	subi	r22, 0xFF	; 255
     998:	7f 4f       	sbci	r23, 0xFF	; 255
     99a:	80 e0       	ldi	r24, 0x00	; 0
     99c:	90 e0       	ldi	r25, 0x00	; 0
     99e:	0e 94 b8 0a 	call	0x1570	; 0x1570 <ECUAL_EEPROMRead>
	u16_CustomersNumber=u6_temp;
     9a2:	09 81       	ldd	r16, Y+1	; 0x01
     9a4:	1a 81       	ldd	r17, Y+2	; 0x02
	APP_Delay_ms(50);
     9a6:	62 e3       	ldi	r22, 0x32	; 50
     9a8:	70 e0       	ldi	r23, 0x00	; 0
     9aa:	80 e0       	ldi	r24, 0x00	; 0
     9ac:	90 e0       	ldi	r25, 0x00	; 0
     9ae:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
	/*second byte */
	ECUAL_EEPROMRead(1,&u6_temp);
     9b2:	be 01       	movw	r22, r28
     9b4:	6f 5f       	subi	r22, 0xFF	; 255
     9b6:	7f 4f       	sbci	r23, 0xFF	; 255
     9b8:	81 e0       	ldi	r24, 0x01	; 1
     9ba:	90 e0       	ldi	r25, 0x00	; 0
     9bc:	0e 94 b8 0a 	call	0x1570	; 0x1570 <ECUAL_EEPROMRead>
	u16_CustomersNumber |=(u6_temp<<8);
     9c0:	80 e0       	ldi	r24, 0x00	; 0
     9c2:	90 e0       	ldi	r25, 0x00	; 0
     9c4:	99 81       	ldd	r25, Y+1	; 0x01
	
	return u16_CustomersNumber;
}
     9c6:	80 2b       	or	r24, r16
     9c8:	91 2b       	or	r25, r17
     9ca:	0f 90       	pop	r0
     9cc:	0f 90       	pop	r0
     9ce:	df 91       	pop	r29
     9d0:	cf 91       	pop	r28
     9d2:	1f 91       	pop	r17
     9d4:	0f 91       	pop	r16
     9d6:	08 95       	ret

000009d8 <APP_DisplayTotNumOfCustomers>:
}
					


void APP_DisplayTotNumOfCustomers(void)
{  
     9d8:	ef 92       	push	r14
     9da:	ff 92       	push	r15
     9dc:	0f 93       	push	r16
     9de:	1f 93       	push	r17
     9e0:	cf 93       	push	r28
     9e2:	df 93       	push	r29
     9e4:	00 d0       	rcall	.+0      	; 0x9e6 <APP_DisplayTotNumOfCustomers+0xe>
     9e6:	00 d0       	rcall	.+0      	; 0x9e8 <APP_DisplayTotNumOfCustomers+0x10>
     9e8:	1f 92       	push	r1
     9ea:	cd b7       	in	r28, 0x3d	; 61
     9ec:	de b7       	in	r29, 0x3e	; 62
	uint16_t u16_CustomesNumber;
	uint8_t u8_counter ;
	uint8_t string[5]={0,0,0,0,0};
     9ee:	fe 01       	movw	r30, r28
     9f0:	31 96       	adiw	r30, 0x01	; 1
     9f2:	85 e0       	ldi	r24, 0x05	; 5
     9f4:	df 01       	movw	r26, r30
     9f6:	1d 92       	st	X+, r1
     9f8:	8a 95       	dec	r24
     9fa:	e9 f7       	brne	.-6      	; 0x9f6 <APP_DisplayTotNumOfCustomers+0x1e>
	string[4]='\r';
     9fc:	8d e0       	ldi	r24, 0x0D	; 13
     9fe:	8d 83       	std	Y+5, r24	; 0x05
	/* to display we have to Convert 2 bytes number to string */
	
	/* first read Total number */
	u16_CustomesNumber = APP_NumberofStoredCustomers();
     a00:	0e 94 c1 04 	call	0x982	; 0x982 <APP_NumberofStoredCustomers>
     a04:	ac 01       	movw	r20, r24
	if (u16_CustomesNumber==0)
     a06:	89 2b       	or	r24, r25
     a08:	19 f4       	brne	.+6      	; 0xa10 <APP_DisplayTotNumOfCustomers+0x38>
	{
		string[0]='0';
     a0a:	80 e3       	ldi	r24, 0x30	; 48
     a0c:	89 83       	std	Y+1, r24	; 0x01
     a0e:	30 c0       	rjmp	.+96     	; 0xa70 <APP_DisplayTotNumOfCustomers+0x98>
	}
	while(u16_CustomesNumber !=0)
	{
		 /* we add 48 to save at char form */
		string[u8_counter]= ( (u16_CustomesNumber % 10 ) + 48 ) ;
     a10:	e1 e0       	ldi	r30, 0x01	; 1
     a12:	f0 e0       	ldi	r31, 0x00	; 0
     a14:	ec 0f       	add	r30, r28
     a16:	fd 1f       	adc	r31, r29
     a18:	e1 0f       	add	r30, r17
     a1a:	f1 1d       	adc	r31, r1
     a1c:	9a 01       	movw	r18, r20
     a1e:	ad ec       	ldi	r26, 0xCD	; 205
     a20:	bc ec       	ldi	r27, 0xCC	; 204
     a22:	0e 94 e2 15 	call	0x2bc4	; 0x2bc4 <__umulhisi3>
     a26:	96 95       	lsr	r25
     a28:	87 95       	ror	r24
     a2a:	96 95       	lsr	r25
     a2c:	87 95       	ror	r24
     a2e:	96 95       	lsr	r25
     a30:	87 95       	ror	r24
     a32:	9c 01       	movw	r18, r24
     a34:	22 0f       	add	r18, r18
     a36:	33 1f       	adc	r19, r19
     a38:	88 0f       	add	r24, r24
     a3a:	99 1f       	adc	r25, r25
     a3c:	88 0f       	add	r24, r24
     a3e:	99 1f       	adc	r25, r25
     a40:	88 0f       	add	r24, r24
     a42:	99 1f       	adc	r25, r25
     a44:	82 0f       	add	r24, r18
     a46:	93 1f       	adc	r25, r19
     a48:	9a 01       	movw	r18, r20
     a4a:	28 1b       	sub	r18, r24
     a4c:	39 0b       	sbc	r19, r25
     a4e:	c9 01       	movw	r24, r18
     a50:	80 5d       	subi	r24, 0xD0	; 208
     a52:	80 83       	st	Z, r24
		u16_CustomesNumber = u16_CustomesNumber /10;
     a54:	9a 01       	movw	r18, r20
     a56:	0e 94 e2 15 	call	0x2bc4	; 0x2bc4 <__umulhisi3>
     a5a:	ac 01       	movw	r20, r24
     a5c:	56 95       	lsr	r21
     a5e:	47 95       	ror	r20
     a60:	56 95       	lsr	r21
     a62:	47 95       	ror	r20
     a64:	56 95       	lsr	r21
     a66:	47 95       	ror	r20
		u8_counter--;
     a68:	11 50       	subi	r17, 0x01	; 1
	u16_CustomesNumber = APP_NumberofStoredCustomers();
	if (u16_CustomesNumber==0)
	{
		string[0]='0';
	}
	while(u16_CustomesNumber !=0)
     a6a:	41 15       	cp	r20, r1
     a6c:	51 05       	cpc	r21, r1
     a6e:	81 f6       	brne	.-96     	; 0xa10 <APP_DisplayTotNumOfCustomers+0x38>
     a70:	8e 01       	movw	r16, r28
     a72:	0f 5f       	subi	r16, 0xFF	; 255
     a74:	1f 4f       	sbci	r17, 0xFF	; 255
     a76:	7e 01       	movw	r14, r28
     a78:	36 e0       	ldi	r19, 0x06	; 6
     a7a:	e3 0e       	add	r14, r19
     a7c:	f1 1c       	adc	r15, r1
		u16_CustomesNumber = u16_CustomesNumber /10;
		u8_counter--;
	}
	for(u8_counter=0;u8_counter<5;u8_counter++)
	{
		USART_Transmit(string[u8_counter]);
     a7e:	d8 01       	movw	r26, r16
     a80:	8d 91       	ld	r24, X+
     a82:	8d 01       	movw	r16, r26
     a84:	90 e0       	ldi	r25, 0x00	; 0
     a86:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <USART_Transmit>
		 /* we add 48 to save at char form */
		string[u8_counter]= ( (u16_CustomesNumber % 10 ) + 48 ) ;
		u16_CustomesNumber = u16_CustomesNumber /10;
		u8_counter--;
	}
	for(u8_counter=0;u8_counter<5;u8_counter++)
     a8a:	0e 15       	cp	r16, r14
     a8c:	1f 05       	cpc	r17, r15
     a8e:	b9 f7       	brne	.-18     	; 0xa7e <APP_DisplayTotNumOfCustomers+0xa6>
	{
		USART_Transmit(string[u8_counter]);
	}
	
}
     a90:	0f 90       	pop	r0
     a92:	0f 90       	pop	r0
     a94:	0f 90       	pop	r0
     a96:	0f 90       	pop	r0
     a98:	0f 90       	pop	r0
     a9a:	df 91       	pop	r29
     a9c:	cf 91       	pop	r28
     a9e:	1f 91       	pop	r17
     aa0:	0f 91       	pop	r16
     aa2:	ff 90       	pop	r15
     aa4:	ef 90       	pop	r14
     aa6:	08 95       	ret

00000aa8 <APP_CustomerMemlocstart>:
}
uint16_t APP_CustomerMemlocstart(uint16_t u16_CustomersNumber)
{
	uint16_t u16_StartMemoryloc;
	/* check if the memory is full */
	if (u16_CustomersNumber>=MAX_NUMBER_CUSTOMERS)
     aa8:	8c 3d       	cpi	r24, 0xDC	; 220
     aaa:	25 e0       	ldi	r18, 0x05	; 5
     aac:	92 07       	cpc	r25, r18
     aae:	38 f0       	brcs	.+14     	; 0xabe <APP_CustomerMemlocstart+0x16>
	{
		APP_APPToTerminalResponse("Memory is Full\r");
     ab0:	81 ec       	ldi	r24, 0xC1	; 193
     ab2:	92 e0       	ldi	r25, 0x02	; 2
     ab4:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
		return ERROR;          // it is a unique return value that will not affect the start loc
     ab8:	80 e0       	ldi	r24, 0x00	; 0
     aba:	90 e0       	ldi	r25, 0x00	; 0
     abc:	08 95       	ret
		                   // because even if there is no Customer data the start add will be larger than 0
	}
	else
	{    
		/* 2 bytes for Customers Number 8 bytes for max amount =10 and Number of customer by 19 byte per customer data */ 
		u16_StartMemoryloc=((u16_CustomersNumber*CustomerDataBuffersize)+10);
     abe:	43 e1       	ldi	r20, 0x13	; 19
     ac0:	48 9f       	mul	r20, r24
     ac2:	90 01       	movw	r18, r0
     ac4:	49 9f       	mul	r20, r25
     ac6:	30 0d       	add	r19, r0
     ac8:	11 24       	eor	r1, r1
		return u16_StartMemoryloc;
     aca:	c9 01       	movw	r24, r18
     acc:	0a 96       	adiw	r24, 0x0a	; 10
	}
	
}
     ace:	08 95       	ret

00000ad0 <APP_StoreCustomerDataEEPROM>:

uint8_t APP_StoreCustomerDataEEPROM(void)
{
     ad0:	af 92       	push	r10
     ad2:	bf 92       	push	r11
     ad4:	cf 92       	push	r12
     ad6:	df 92       	push	r13
     ad8:	ef 92       	push	r14
     ada:	ff 92       	push	r15
     adc:	0f 93       	push	r16
     ade:	1f 93       	push	r17
     ae0:	cf 93       	push	r28
     ae2:	df 93       	push	r29
	uint8_t u8_counter =0;
	uint16_t u16_CustomersNumber ;
	uint16_t u16_StartLocation ;
	/* Get the total Number of Customers */
	u16_CustomersNumber=APP_NumberofStoredCustomers();
     ae4:	0e 94 c1 04 	call	0x982	; 0x982 <APP_NumberofStoredCustomers>
     ae8:	5c 01       	movw	r10, r24
	
	/* Check if Memory is full and if not Get the New Customer Address Location */
	u16_StartLocation =APP_CustomerMemlocstart(u16_CustomersNumber);
     aea:	0e 94 54 05 	call	0xaa8	; 0xaa8 <APP_CustomerMemlocstart>
	
	/* check if the  Memory is Full */
	if (u16_StartLocation==0)
     aee:	00 97       	sbiw	r24, 0x00	; 0
     af0:	d1 f1       	breq	.+116    	; 0xb66 <APP_StoreCustomerDataEEPROM+0x96>
	else
	{
		/* store New customer Data with his ID into EEPROM */
		/* first store ID into the buffer */
		/* increment the customer number that represents the new customer ID */
		u16_CustomersNumber++;
     af2:	2f ef       	ldi	r18, 0xFF	; 255
     af4:	a2 1a       	sub	r10, r18
     af6:	b2 0a       	sbc	r11, r18
		CustomerData[0]=(uint8_t)u16_CustomersNumber;
     af8:	ed ea       	ldi	r30, 0xAD	; 173
     afa:	f7 e0       	ldi	r31, 0x07	; 7
     afc:	a0 82       	st	Z, r10
		CustomerData[1]=(uint8_t)(u16_CustomersNumber>>8);
     afe:	b1 82       	std	Z+1, r11	; 0x01
     b00:	0f 2e       	mov	r0, r31
     b02:	f0 ec       	ldi	r31, 0xC0	; 192
     b04:	cf 2e       	mov	r12, r31
     b06:	f7 e0       	ldi	r31, 0x07	; 7
     b08:	df 2e       	mov	r13, r31
     b0a:	f0 2d       	mov	r31, r0
     b0c:	ef 01       	movw	r28, r30
     b0e:	9c 01       	movw	r18, r24
     b10:	2d 5a       	subi	r18, 0xAD	; 173
     b12:	37 40       	sbci	r19, 0x07	; 7
     b14:	79 01       	movw	r14, r18
     b16:	87 01       	movw	r16, r14
     b18:	0c 0f       	add	r16, r28
     b1a:	1d 1f       	adc	r17, r29
		/* store the whole customer data block */
		
		for(u8_counter=0;u8_counter<19;u8_counter++)
		{
			/* Delay */
			APP_Delay_ms(30);
     b1c:	6e e1       	ldi	r22, 0x1E	; 30
     b1e:	70 e0       	ldi	r23, 0x00	; 0
     b20:	80 e0       	ldi	r24, 0x00	; 0
     b22:	90 e0       	ldi	r25, 0x00	; 0
     b24:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
			ECUAL_EEPROMWrite(u16_StartLocation,CustomerData[u8_counter]);
     b28:	69 91       	ld	r22, Y+
     b2a:	c8 01       	movw	r24, r16
     b2c:	0e 94 98 0a 	call	0x1530	; 0x1530 <ECUAL_EEPROMWrite>
		CustomerData[0]=(uint8_t)u16_CustomersNumber;
		CustomerData[1]=(uint8_t)(u16_CustomersNumber>>8);
		
		/* store the whole customer data block */
		
		for(u8_counter=0;u8_counter<19;u8_counter++)
     b30:	cc 15       	cp	r28, r12
     b32:	dd 05       	cpc	r29, r13
     b34:	81 f7       	brne	.-32     	; 0xb16 <APP_StoreCustomerDataEEPROM+0x46>
		}
		
		
		/* Increment the total number of Customers */
		u16_CustomersNumber =u16_CustomersNumber;
		APP_Delay_ms(30);
     b36:	6e e1       	ldi	r22, 0x1E	; 30
     b38:	70 e0       	ldi	r23, 0x00	; 0
     b3a:	80 e0       	ldi	r24, 0x00	; 0
     b3c:	90 e0       	ldi	r25, 0x00	; 0
     b3e:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
		ECUAL_EEPROMWrite(0,((uint8_t)u16_CustomersNumber));
     b42:	6a 2d       	mov	r22, r10
     b44:	80 e0       	ldi	r24, 0x00	; 0
     b46:	90 e0       	ldi	r25, 0x00	; 0
     b48:	0e 94 98 0a 	call	0x1530	; 0x1530 <ECUAL_EEPROMWrite>
		APP_Delay_ms(30);
     b4c:	6e e1       	ldi	r22, 0x1E	; 30
     b4e:	70 e0       	ldi	r23, 0x00	; 0
     b50:	80 e0       	ldi	r24, 0x00	; 0
     b52:	90 e0       	ldi	r25, 0x00	; 0
     b54:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
		ECUAL_EEPROMWrite(1,((uint8_t)(u16_CustomersNumber>>8)));	
     b58:	6b 2d       	mov	r22, r11
     b5a:	81 e0       	ldi	r24, 0x01	; 1
     b5c:	90 e0       	ldi	r25, 0x00	; 0
     b5e:	0e 94 98 0a 	call	0x1530	; 0x1530 <ECUAL_EEPROMWrite>
		return NO_ERROR;
     b62:	81 e0       	ldi	r24, 0x01	; 1
     b64:	01 c0       	rjmp	.+2      	; 0xb68 <APP_StoreCustomerDataEEPROM+0x98>
	u16_StartLocation =APP_CustomerMemlocstart(u16_CustomersNumber);
	
	/* check if the  Memory is Full */
	if (u16_StartLocation==0)
	{
		return ERROR;
     b66:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	
	
	
}
     b68:	df 91       	pop	r29
     b6a:	cf 91       	pop	r28
     b6c:	1f 91       	pop	r17
     b6e:	0f 91       	pop	r16
     b70:	ff 90       	pop	r15
     b72:	ef 90       	pop	r14
     b74:	df 90       	pop	r13
     b76:	cf 90       	pop	r12
     b78:	bf 90       	pop	r11
     b7a:	af 90       	pop	r10
     b7c:	08 95       	ret

00000b7e <APP_ClearTotalNumberOfCustomers>:

void APP_ClearTotalNumberOfCustomers(void)
{
	ECUAL_EEPROMWrite(0,0);
     b7e:	60 e0       	ldi	r22, 0x00	; 0
     b80:	80 e0       	ldi	r24, 0x00	; 0
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	0e 94 98 0a 	call	0x1530	; 0x1530 <ECUAL_EEPROMWrite>
	APP_Delay_ms(50);
     b88:	62 e3       	ldi	r22, 0x32	; 50
     b8a:	70 e0       	ldi	r23, 0x00	; 0
     b8c:	80 e0       	ldi	r24, 0x00	; 0
     b8e:	90 e0       	ldi	r25, 0x00	; 0
     b90:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
	ECUAL_EEPROMWrite(1,0);
     b94:	60 e0       	ldi	r22, 0x00	; 0
     b96:	81 e0       	ldi	r24, 0x01	; 1
     b98:	90 e0       	ldi	r25, 0x00	; 0
     b9a:	0e 94 98 0a 	call	0x1530	; 0x1530 <ECUAL_EEPROMWrite>
     b9e:	08 95       	ret

00000ba0 <APP_ReadCustomerDataByID>:
}

uint8_t APP_ReadCustomerDataByID(uint16_t u16_CustomerID)
{
     ba0:	ef 92       	push	r14
     ba2:	ff 92       	push	r15
     ba4:	0f 93       	push	r16
     ba6:	1f 93       	push	r17
     ba8:	cf 93       	push	r28
     baa:	df 93       	push	r29
	uint8_t u8_counter;
	/* calculate start Address */
	uint16_t u16_StratAdress ;
	u16_StratAdress = (((u16_CustomerID -1)*CustomerDataBuffersize)+10); 
     bac:	23 e1       	ldi	r18, 0x13	; 19
     bae:	ac 01       	movw	r20, r24
     bb0:	24 9f       	mul	r18, r20
     bb2:	c0 01       	movw	r24, r0
     bb4:	25 9f       	mul	r18, r21
     bb6:	90 0d       	add	r25, r0
     bb8:	11 24       	eor	r1, r1
     bba:	ec 01       	movw	r28, r24
     bbc:	29 97       	sbiw	r28, 0x09	; 9
     bbe:	7c 01       	movw	r14, r24
     bc0:	5a e0       	ldi	r21, 0x0A	; 10
     bc2:	e5 0e       	add	r14, r21
     bc4:	f1 1c       	adc	r15, r1
	
      /* read customer data and save it into customer data buffer */
	  
	  for(u8_counter=0;u8_counter<CustomerDataBuffersize;u8_counter++)
	  {
		ECUAL_EEPROMRead(u16_StratAdress,&CustomerData[u8_counter]) ;
     bc6:	09 e0       	ldi	r16, 0x09	; 9
     bc8:	10 e0       	ldi	r17, 0x00	; 0
     bca:	08 1b       	sub	r16, r24
     bcc:	19 0b       	sbc	r17, r25
     bce:	b8 01       	movw	r22, r16
     bd0:	6c 0f       	add	r22, r28
     bd2:	7d 1f       	adc	r23, r29
     bd4:	63 55       	subi	r22, 0x53	; 83
     bd6:	78 4f       	sbci	r23, 0xF8	; 248
     bd8:	ce 01       	movw	r24, r28
     bda:	0e 94 b8 0a 	call	0x1570	; 0x1570 <ECUAL_EEPROMRead>
		APP_Delay_ms(20);
     bde:	64 e1       	ldi	r22, 0x14	; 20
     be0:	70 e0       	ldi	r23, 0x00	; 0
     be2:	80 e0       	ldi	r24, 0x00	; 0
     be4:	90 e0       	ldi	r25, 0x00	; 0
     be6:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
		u16_StratAdress++;
     bea:	21 96       	adiw	r28, 0x01	; 1
	uint16_t u16_StratAdress ;
	u16_StratAdress = (((u16_CustomerID -1)*CustomerDataBuffersize)+10); 
	
      /* read customer data and save it into customer data buffer */
	  
	  for(u8_counter=0;u8_counter<CustomerDataBuffersize;u8_counter++)
     bec:	ce 15       	cp	r28, r14
     bee:	df 05       	cpc	r29, r15
     bf0:	71 f7       	brne	.-36     	; 0xbce <APP_ReadCustomerDataByID+0x2e>
		ECUAL_EEPROMRead(u16_StratAdress,&CustomerData[u8_counter]) ;
		APP_Delay_ms(20);
		u16_StratAdress++;
	  }
	
}
     bf2:	df 91       	pop	r29
     bf4:	cf 91       	pop	r28
     bf6:	1f 91       	pop	r17
     bf8:	0f 91       	pop	r16
     bfa:	ff 90       	pop	r15
     bfc:	ef 90       	pop	r14
     bfe:	08 95       	ret

00000c00 <APP_checkPan>:
	uint8_t u8_counter;
	/* we will compare between PAN entered by user and the PAN in the current ID */
	 for(u8_counter=0;u8_counter<9;u8_counter++)
	 {
		                           // PAN is located form the 2 index in the customer buffer */
		 if (PAN_buffer[u8_counter]==CustomerData[u8_counter+2])
     c00:	90 91 f6 07 	lds	r25, 0x07F6	; 0x8007f6 <PAN_buffer>
     c04:	80 91 af 07 	lds	r24, 0x07AF	; 0x8007af <CustomerData+0x2>
     c08:	98 13       	cpse	r25, r24
     c0a:	0f c0       	rjmp	.+30     	; 0xc2a <APP_checkPan+0x2a>
     c0c:	e7 ef       	ldi	r30, 0xF7	; 247
     c0e:	f7 e0       	ldi	r31, 0x07	; 7
     c10:	a0 eb       	ldi	r26, 0xB0	; 176
     c12:	b7 e0       	ldi	r27, 0x07	; 7
     c14:	2f ef       	ldi	r18, 0xFF	; 255
     c16:	37 e0       	ldi	r19, 0x07	; 7
     c18:	91 91       	ld	r25, Z+
     c1a:	8d 91       	ld	r24, X+
     c1c:	98 13       	cpse	r25, r24
     c1e:	07 c0       	rjmp	.+14     	; 0xc2e <APP_checkPan+0x2e>
}
uint8_t APP_checkPan(void)
{
	uint8_t u8_counter;
	/* we will compare between PAN entered by user and the PAN in the current ID */
	 for(u8_counter=0;u8_counter<9;u8_counter++)
     c20:	e2 17       	cp	r30, r18
     c22:	f3 07       	cpc	r31, r19
     c24:	c9 f7       	brne	.-14     	; 0xc18 <APP_checkPan+0x18>
		 else
		 {
				return ERROR;	
		 }
	 }
	 return NO_ERROR;
     c26:	81 e0       	ldi	r24, 0x01	; 1
     c28:	08 95       	ret
		 {
			 continue;
		 }
		 else
		 {
				return ERROR;	
     c2a:	80 e0       	ldi	r24, 0x00	; 0
     c2c:	08 95       	ret
     c2e:	80 e0       	ldi	r24, 0x00	; 0
		 }
	 }
	 return NO_ERROR;
}
     c30:	08 95       	ret

00000c32 <APP_SearchCustomerByPAN>:

uint8_t APP_SearchCustomerByPAN(void)
{
     c32:	0f 93       	push	r16
     c34:	1f 93       	push	r17
     c36:	cf 93       	push	r28
     c38:	df 93       	push	r29
	
	uint16_t u16_ToTNumOfCustomers;
	uint16_t u16_counter;
	uint8_t u8_flag=0;
	/* first get total numbers of customers */
	u16_ToTNumOfCustomers =APP_NumberofStoredCustomers();
     c3a:	0e 94 c1 04 	call	0x982	; 0x982 <APP_NumberofStoredCustomers>
     c3e:	8c 01       	movw	r16, r24
	
	/* start searching */
	for(u16_counter=1;u16_counter<=u16_ToTNumOfCustomers;u16_counter++)
     c40:	89 2b       	or	r24, r25
     c42:	79 f0       	breq	.+30     	; 0xc62 <APP_SearchCustomerByPAN+0x30>
     c44:	c1 e0       	ldi	r28, 0x01	; 1
     c46:	d0 e0       	ldi	r29, 0x00	; 0
	{
		/* read Data */
		APP_ReadCustomerDataByID(u16_counter);
     c48:	ce 01       	movw	r24, r28
     c4a:	0e 94 d0 05 	call	0xba0	; 0xba0 <APP_ReadCustomerDataByID>
		/* check PAN */
		if (APP_checkPan()==NO_ERROR)
     c4e:	0e 94 00 06 	call	0xc00	; 0xc00 <APP_checkPan>
     c52:	81 30       	cpi	r24, 0x01	; 1
     c54:	41 f0       	breq	.+16     	; 0xc66 <APP_SearchCustomerByPAN+0x34>
	uint8_t u8_flag=0;
	/* first get total numbers of customers */
	u16_ToTNumOfCustomers =APP_NumberofStoredCustomers();
	
	/* start searching */
	for(u16_counter=1;u16_counter<=u16_ToTNumOfCustomers;u16_counter++)
     c56:	21 96       	adiw	r28, 0x01	; 1
     c58:	0c 17       	cp	r16, r28
     c5a:	1d 07       	cpc	r17, r29
     c5c:	a8 f7       	brcc	.-22     	; 0xc48 <APP_SearchCustomerByPAN+0x16>
uint8_t APP_SearchCustomerByPAN(void)
{
	
	uint16_t u16_ToTNumOfCustomers;
	uint16_t u16_counter;
	uint8_t u8_flag=0;
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	03 c0       	rjmp	.+6      	; 0xc68 <APP_SearchCustomerByPAN+0x36>
     c62:	90 e0       	ldi	r25, 0x00	; 0
     c64:	01 c0       	rjmp	.+2      	; 0xc68 <APP_SearchCustomerByPAN+0x36>
		/* read Data */
		APP_ReadCustomerDataByID(u16_counter);
		/* check PAN */
		if (APP_checkPan()==NO_ERROR)
		{
			u8_flag=1;
     c66:	91 e0       	ldi	r25, 0x01	; 1
     c68:	81 e0       	ldi	r24, 0x01	; 1
     c6a:	91 30       	cpi	r25, 0x01	; 1
     c6c:	09 f0       	breq	.+2      	; 0xc70 <APP_SearchCustomerByPAN+0x3e>
     c6e:	80 e0       	ldi	r24, 0x00	; 0
	{         
		return ERROR;
	}
	
	
}
     c70:	df 91       	pop	r29
     c72:	cf 91       	pop	r28
     c74:	1f 91       	pop	r17
     c76:	0f 91       	pop	r16
     c78:	08 95       	ret

00000c7a <APP_responseToCardInsertion>:

ATM_ERRORS_t APP_responseToCardInsertion(void)
{
	uint8_t u8_KEY;
	/* check the Card State */
	if (CardState==Initialized)
     c7a:	80 91 83 07 	lds	r24, 0x0783	; 0x800783 <CardState>
     c7e:	81 30       	cpi	r24, 0x01	; 1
     c80:	09 f0       	breq	.+2      	; 0xc84 <APP_responseToCardInsertion+0xa>
     c82:	76 c1       	rjmp	.+748    	; 0xf70 <APP_responseToCardInsertion+0x2f6>
	{
		LCD_clear_screen();
     c84:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
		LCD_display_String("   waiting....    ");
     c88:	81 ed       	ldi	r24, 0xD1	; 209
     c8a:	92 e0       	ldi	r25, 0x02	; 2
     c8c:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
		LCD_clear_screen();
     c90:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
		
		
		
		if (APP_userPassHandler()==NO_ERROR)
     c94:	0e 94 90 02 	call	0x520	; 0x520 <APP_userPassHandler>
     c98:	81 30       	cpi	r24, 0x01	; 1
     c9a:	09 f0       	breq	.+2      	; 0xc9e <APP_responseToCardInsertion+0x24>
     c9c:	3e c1       	rjmp	.+636    	; 0xf1a <APP_responseToCardInsertion+0x2a0>
		{
			/*hello message with card holder name */
			LCD_clear_screen();
     c9e:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
			LCD_display_String("      Hello    ");
     ca2:	84 ee       	ldi	r24, 0xE4	; 228
     ca4:	92 e0       	ldi	r25, 0x02	; 2
     ca6:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
			LCD_GoTo_xy(1,0);
     caa:	60 e0       	ldi	r22, 0x00	; 0
     cac:	81 e0       	ldi	r24, 0x01	; 1
     cae:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LCD_GoTo_xy>
			LCD_display_String(Name_buffer);
     cb2:	8c ec       	ldi	r24, 0xCC	; 204
     cb4:	97 e0       	ldi	r25, 0x07	; 7
     cb6:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
			/*****************************/
			APP_Delay_ms(2000);
     cba:	60 ed       	ldi	r22, 0xD0	; 208
     cbc:	77 e0       	ldi	r23, 0x07	; 7
     cbe:	80 e0       	ldi	r24, 0x00	; 0
     cc0:	90 e0       	ldi	r25, 0x00	; 0
     cc2:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
			/****************************/
			
			if (APP_GetUserAmount()==ERROR)
     cc6:	0e 94 59 01 	call	0x2b2	; 0x2b2 <APP_GetUserAmount>
     cca:	81 11       	cpse	r24, r1
     ccc:	07 c0       	rjmp	.+14     	; 0xcdc <APP_responseToCardInsertion+0x62>
			{
				
					LCD_clear_screen();
     cce:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
					LCD_display_String("wrong format");
     cd2:	84 ef       	ldi	r24, 0xF4	; 244
     cd4:	92 e0       	ldi	r25, 0x02	; 2
     cd6:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
     cda:	73 c1       	rjmp	.+742    	; 0xfc2 <APP_responseToCardInsertion+0x348>
			}
			else
			{
				
				LCD_clear_screen();
     cdc:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
				LCD_display_String("waiting");
     ce0:	81 e0       	ldi	r24, 0x01	; 1
     ce2:	93 e0       	ldi	r25, 0x03	; 3
     ce4:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
				if(APP_SearchCustomerByPAN()==NO_ERROR)
     ce8:	0e 94 19 06 	call	0xc32	; 0xc32 <APP_SearchCustomerByPAN>
     cec:	81 30       	cpi	r24, 0x01	; 1
     cee:	09 f0       	breq	.+2      	; 0xcf2 <APP_responseToCardInsertion+0x78>
     cf0:	f0 c0       	rjmp	.+480    	; 0xed2 <APP_responseToCardInsertion+0x258>
				{
					
					if (APP_checkMaxamount()==NO_ERROR)
     cf2:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <APP_checkMaxamount>
     cf6:	81 30       	cpi	r24, 0x01	; 1
     cf8:	09 f0       	breq	.+2      	; 0xcfc <APP_responseToCardInsertion+0x82>
     cfa:	bf c0       	rjmp	.+382    	; 0xe7a <APP_responseToCardInsertion+0x200>
					{  
						
						if (APP_checkBalance()==NO_ERROR)
     cfc:	0e 94 1f 03 	call	0x63e	; 0x63e <APP_checkBalance>
     d00:	81 30       	cpi	r24, 0x01	; 1
     d02:	09 f0       	breq	.+2      	; 0xd06 <APP_responseToCardInsertion+0x8c>
     d04:	8e c0       	rjmp	.+284    	; 0xe22 <APP_responseToCardInsertion+0x1a8>
						{
							
							/* wait user confirmation */
							LCD_clear_screen();
     d06:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
							LCD_display_String("1-Confirm");
     d0a:	89 e0       	ldi	r24, 0x09	; 9
     d0c:	93 e0       	ldi	r25, 0x03	; 3
     d0e:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
							LCD_GoTo_xy(1,0);
     d12:	60 e0       	ldi	r22, 0x00	; 0
     d14:	81 e0       	ldi	r24, 0x01	; 1
     d16:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LCD_GoTo_xy>
							LCD_display_String("2-Cancel");
     d1a:	83 e1       	ldi	r24, 0x13	; 19
     d1c:	93 e0       	ldi	r25, 0x03	; 3
     d1e:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
							{
								
								
								
								
								u8_KEY =keyPad_GetKey();
     d22:	0e 94 39 0b 	call	0x1672	; 0x1672 <keyPad_GetKey>
								if (u8_KEY=='1')
     d26:	81 33       	cpi	r24, 0x31	; 49
     d28:	09 f0       	breq	.+2      	; 0xd2c <APP_responseToCardInsertion+0xb2>
     d2a:	4c c0       	rjmp	.+152    	; 0xdc4 <APP_responseToCardInsertion+0x14a>
								{
									/* approve the transaction */
									/* this is a critical part so we will disable ADMIN UART Interrupt */
									USART_RxInterruptDiable();
     d2c:	0e 94 ff 12 	call	0x25fe	; 0x25fe <USART_RxInterruptDiable>
									
									if (APP_ApproveTransaction()==NO_ERROR)
     d30:	0e 94 82 03 	call	0x704	; 0x704 <APP_ApproveTransaction>
     d34:	81 30       	cpi	r24, 0x01	; 1
     d36:	a9 f7       	brne	.-22     	; 0xd22 <APP_responseToCardInsertion+0xa8>
									{
										LCD_clear_screen();
     d38:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
										LCD_display_String("the transaction  is approved");
     d3c:	8c e1       	ldi	r24, 0x1C	; 28
     d3e:	93 e0       	ldi	r25, 0x03	; 3
     d40:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
										APP_Delay_ms(2000);
     d44:	60 ed       	ldi	r22, 0xD0	; 208
     d46:	77 e0       	ldi	r23, 0x07	; 7
     d48:	80 e0       	ldi	r24, 0x00	; 0
     d4a:	90 e0       	ldi	r25, 0x00	; 0
     d4c:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
										LCD_clear_screen();
     d50:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
										DisplayNewBalanceLCD();
     d54:	0e 94 63 03 	call	0x6c6	; 0x6c6 <DisplayNewBalanceLCD>
										APP_Delay_ms(2000);
     d58:	60 ed       	ldi	r22, 0xD0	; 208
     d5a:	77 e0       	ldi	r23, 0x07	; 7
     d5c:	80 e0       	ldi	r24, 0x00	; 0
     d5e:	90 e0       	ldi	r25, 0x00	; 0
     d60:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
										LCD_clear_screen();
     d64:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
										LCD_display_String("Take your money");
     d68:	89 e3       	ldi	r24, 0x39	; 57
     d6a:	93 e0       	ldi	r25, 0x03	; 3
     d6c:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
										APP_Delay_ms(2000);
     d70:	60 ed       	ldi	r22, 0xD0	; 208
     d72:	77 e0       	ldi	r23, 0x07	; 7
     d74:	80 e0       	ldi	r24, 0x00	; 0
     d76:	90 e0       	ldi	r25, 0x00	; 0
     d78:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
										/* Money Motor On */
										MoneyMotorON();
     d7c:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <MoneyMotorON>
										LCD_clear_screen();
     d80:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
										LCD_display_String("Take your Card");
     d84:	89 e4       	ldi	r24, 0x49	; 73
     d86:	93 e0       	ldi	r25, 0x03	; 3
     d88:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
										/* card motor Kick out the card to left */
										CardMotorLeft();
     d8c:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <CardMotorLeft>
										APP_Delay_ms(2000);
     d90:	60 ed       	ldi	r22, 0xD0	; 208
     d92:	77 e0       	ldi	r23, 0x07	; 7
     d94:	80 e0       	ldi	r24, 0x00	; 0
     d96:	90 e0       	ldi	r25, 0x00	; 0
     d98:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
										
										LCD_clear_screen();
     d9c:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
										LCD_display_String("Thank you");
     da0:	88 e5       	ldi	r24, 0x58	; 88
     da2:	93 e0       	ldi	r25, 0x03	; 3
     da4:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
										APP_Delay_ms(2000);
     da8:	60 ed       	ldi	r22, 0xD0	; 208
     daa:	77 e0       	ldi	r23, 0x07	; 7
     dac:	80 e0       	ldi	r24, 0x00	; 0
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
										LCD_clear_screen();
     db4:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
										/* update card insertion state to not inserted */
										CardinsertionState =not_inserted;
     db8:	81 e0       	ldi	r24, 0x01	; 1
     dba:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
										/* enable the interrupt again */
										USART_RxInterruptEnable();
     dbe:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <USART_RxInterruptEnable>
										break;
     dc2:	ff c0       	rjmp	.+510    	; 0xfc2 <APP_responseToCardInsertion+0x348>
									}
									
									
								}
								else if (u8_KEY=='2')
     dc4:	82 33       	cpi	r24, 0x32	; 50
     dc6:	09 f0       	breq	.+2      	; 0xdca <APP_responseToCardInsertion+0x150>
     dc8:	ac cf       	rjmp	.-168    	; 0xd22 <APP_responseToCardInsertion+0xa8>
								{
									/* cancel transaction */
									LCD_clear_screen();
     dca:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
									LCD_display_String("Canceled");
     dce:	82 e6       	ldi	r24, 0x62	; 98
     dd0:	93 e0       	ldi	r25, 0x03	; 3
     dd2:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
									APP_Delay_ms(2000);
     dd6:	60 ed       	ldi	r22, 0xD0	; 208
     dd8:	77 e0       	ldi	r23, 0x07	; 7
     dda:	80 e0       	ldi	r24, 0x00	; 0
     ddc:	90 e0       	ldi	r25, 0x00	; 0
     dde:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
									LCD_clear_screen();
     de2:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
									LCD_display_String("Take your Card");
     de6:	89 e4       	ldi	r24, 0x49	; 73
     de8:	93 e0       	ldi	r25, 0x03	; 3
     dea:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
									/* card motor Kick out the card to left */
									CardMotorLeft();
     dee:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <CardMotorLeft>
									APP_Delay_ms(2000);
     df2:	60 ed       	ldi	r22, 0xD0	; 208
     df4:	77 e0       	ldi	r23, 0x07	; 7
     df6:	80 e0       	ldi	r24, 0x00	; 0
     df8:	90 e0       	ldi	r25, 0x00	; 0
     dfa:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
									LCD_clear_screen();
     dfe:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
									LCD_display_String("Thank you");
     e02:	88 e5       	ldi	r24, 0x58	; 88
     e04:	93 e0       	ldi	r25, 0x03	; 3
     e06:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
									APP_Delay_ms(2000);
     e0a:	60 ed       	ldi	r22, 0xD0	; 208
     e0c:	77 e0       	ldi	r23, 0x07	; 7
     e0e:	80 e0       	ldi	r24, 0x00	; 0
     e10:	90 e0       	ldi	r25, 0x00	; 0
     e12:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
									LCD_clear_screen();
     e16:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
									/* update card insertion state to not inserted */
									CardinsertionState =not_inserted;
     e1a:	81 e0       	ldi	r24, 0x01	; 1
     e1c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
									break;
     e20:	d0 c0       	rjmp	.+416    	; 0xfc2 <APP_responseToCardInsertion+0x348>
							}
							
						}
						else{
							/* insufficient fund */
							LCD_clear_screen();
     e22:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
							LCD_display_String("insufficient  fund");
     e26:	8b e6       	ldi	r24, 0x6B	; 107
     e28:	93 e0       	ldi	r25, 0x03	; 3
     e2a:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
							APP_Delay_ms(2000);
     e2e:	60 ed       	ldi	r22, 0xD0	; 208
     e30:	77 e0       	ldi	r23, 0x07	; 7
     e32:	80 e0       	ldi	r24, 0x00	; 0
     e34:	90 e0       	ldi	r25, 0x00	; 0
     e36:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
							LCD_clear_screen();
     e3a:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
							LCD_display_String("Take your Card");
     e3e:	89 e4       	ldi	r24, 0x49	; 73
     e40:	93 e0       	ldi	r25, 0x03	; 3
     e42:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
							/* card motor Kick out the card to left */
							CardMotorLeft();
     e46:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <CardMotorLeft>
							APP_Delay_ms(2000);
     e4a:	60 ed       	ldi	r22, 0xD0	; 208
     e4c:	77 e0       	ldi	r23, 0x07	; 7
     e4e:	80 e0       	ldi	r24, 0x00	; 0
     e50:	90 e0       	ldi	r25, 0x00	; 0
     e52:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
							LCD_clear_screen();
     e56:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
							LCD_display_String("Thank you");
     e5a:	88 e5       	ldi	r24, 0x58	; 88
     e5c:	93 e0       	ldi	r25, 0x03	; 3
     e5e:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
							APP_Delay_ms(2000);
     e62:	60 ed       	ldi	r22, 0xD0	; 208
     e64:	77 e0       	ldi	r23, 0x07	; 7
     e66:	80 e0       	ldi	r24, 0x00	; 0
     e68:	90 e0       	ldi	r25, 0x00	; 0
     e6a:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
							LCD_clear_screen();
     e6e:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
							/* update card insertion state to not inserted */
							CardinsertionState =not_inserted;
     e72:	81 e0       	ldi	r24, 0x01	; 1
     e74:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     e78:	a4 c0       	rjmp	.+328    	; 0xfc2 <APP_responseToCardInsertion+0x348>
						
					}
					else
					{
						/* exceed max amount */
						LCD_clear_screen();
     e7a:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
						LCD_display_String("exceeds maximum amount");
     e7e:	8e e7       	ldi	r24, 0x7E	; 126
     e80:	93 e0       	ldi	r25, 0x03	; 3
     e82:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
						APP_Delay_ms(2000);
     e86:	60 ed       	ldi	r22, 0xD0	; 208
     e88:	77 e0       	ldi	r23, 0x07	; 7
     e8a:	80 e0       	ldi	r24, 0x00	; 0
     e8c:	90 e0       	ldi	r25, 0x00	; 0
     e8e:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
						LCD_clear_screen();
     e92:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
						LCD_display_String("Take your Card");
     e96:	89 e4       	ldi	r24, 0x49	; 73
     e98:	93 e0       	ldi	r25, 0x03	; 3
     e9a:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
						/* card motor Kick out the card to left */
						CardMotorLeft();
     e9e:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <CardMotorLeft>
						APP_Delay_ms(2000);
     ea2:	60 ed       	ldi	r22, 0xD0	; 208
     ea4:	77 e0       	ldi	r23, 0x07	; 7
     ea6:	80 e0       	ldi	r24, 0x00	; 0
     ea8:	90 e0       	ldi	r25, 0x00	; 0
     eaa:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
						LCD_clear_screen();
     eae:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
						LCD_display_String("Thank you");
     eb2:	88 e5       	ldi	r24, 0x58	; 88
     eb4:	93 e0       	ldi	r25, 0x03	; 3
     eb6:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
						APP_Delay_ms(2000);
     eba:	60 ed       	ldi	r22, 0xD0	; 208
     ebc:	77 e0       	ldi	r23, 0x07	; 7
     ebe:	80 e0       	ldi	r24, 0x00	; 0
     ec0:	90 e0       	ldi	r25, 0x00	; 0
     ec2:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
						LCD_clear_screen();
     ec6:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
						/* update card insertion state to not inserted */
						CardinsertionState =not_inserted;
     eca:	81 e0       	ldi	r24, 0x01	; 1
     ecc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     ed0:	78 c0       	rjmp	.+240    	; 0xfc2 <APP_responseToCardInsertion+0x348>
					
				}
				else
				{  /* the PAN number is not exist in DB */
					/* the Card is blocked */
					LCD_clear_screen();
     ed2:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
					LCD_display_String("PAN number is   founded in DB");
     ed6:	85 e9       	ldi	r24, 0x95	; 149
     ed8:	93 e0       	ldi	r25, 0x03	; 3
     eda:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
					LCD_clear_screen();
     ede:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
					LCD_display_String("The Card        is blocked ");
     ee2:	83 eb       	ldi	r24, 0xB3	; 179
     ee4:	93 e0       	ldi	r25, 0x03	; 3
     ee6:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
					CardMotorRight();
     eea:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <CardMotorRight>
					APP_Delay_ms(2000);
     eee:	60 ed       	ldi	r22, 0xD0	; 208
     ef0:	77 e0       	ldi	r23, 0x07	; 7
     ef2:	80 e0       	ldi	r24, 0x00	; 0
     ef4:	90 e0       	ldi	r25, 0x00	; 0
     ef6:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
					LCD_clear_screen();
     efa:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
					LCD_display_String("please contact service provider");
     efe:	8f ec       	ldi	r24, 0xCF	; 207
     f00:	93 e0       	ldi	r25, 0x03	; 3
     f02:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
					APP_Delay_ms(2000);
     f06:	60 ed       	ldi	r22, 0xD0	; 208
     f08:	77 e0       	ldi	r23, 0x07	; 7
     f0a:	80 e0       	ldi	r24, 0x00	; 0
     f0c:	90 e0       	ldi	r25, 0x00	; 0
     f0e:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
					/* update card insertion state to not inserted */
					CardinsertionState =not_inserted;
     f12:	81 e0       	ldi	r24, 0x01	; 1
     f14:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     f18:	54 c0       	rjmp	.+168    	; 0xfc2 <APP_responseToCardInsertion+0x348>
		/* the user entered 3 wrong passwords */
	   else
	   {  
		   /* Card is Blocked */
		   /* move Card motor to right toward the ATM */
		   CardMotorRight();
     f1a:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <CardMotorRight>
		   LCD_clear_screen();
     f1e:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
		   LCD_display_String("you entered 3   wrong passwords");
     f22:	8f ee       	ldi	r24, 0xEF	; 239
     f24:	93 e0       	ldi	r25, 0x03	; 3
     f26:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
		   APP_Delay_ms(2000);
     f2a:	60 ed       	ldi	r22, 0xD0	; 208
     f2c:	77 e0       	ldi	r23, 0x07	; 7
     f2e:	80 e0       	ldi	r24, 0x00	; 0
     f30:	90 e0       	ldi	r25, 0x00	; 0
     f32:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
		   LCD_clear_screen();
     f36:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
		   LCD_display_String("The card        Is blocked");
     f3a:	8f e0       	ldi	r24, 0x0F	; 15
     f3c:	94 e0       	ldi	r25, 0x04	; 4
     f3e:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
		   APP_Delay_ms(2000);
     f42:	60 ed       	ldi	r22, 0xD0	; 208
     f44:	77 e0       	ldi	r23, 0x07	; 7
     f46:	80 e0       	ldi	r24, 0x00	; 0
     f48:	90 e0       	ldi	r25, 0x00	; 0
     f4a:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
		   LCD_clear_screen();
     f4e:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
		   LCD_display_String("please contact service provider");
     f52:	8f ec       	ldi	r24, 0xCF	; 207
     f54:	93 e0       	ldi	r25, 0x03	; 3
     f56:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
		   APP_Delay_ms(2000);
     f5a:	60 ed       	ldi	r22, 0xD0	; 208
     f5c:	77 e0       	ldi	r23, 0x07	; 7
     f5e:	80 e0       	ldi	r24, 0x00	; 0
     f60:	90 e0       	ldi	r25, 0x00	; 0
     f62:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
		   /* update card insertion state to not inserted */
		   CardinsertionState =not_inserted;
     f66:	81 e0       	ldi	r24, 0x01	; 1
     f68:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
		   return ERROR;
     f6c:	80 e0       	ldi	r24, 0x00	; 0
     f6e:	08 95       	ret
	
	}
	else
	{ // card not initialized */
		
		LCD_clear_screen();
     f70:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
		LCD_display_String("The Card is not initialized");
     f74:	8a e2       	ldi	r24, 0x2A	; 42
     f76:	94 e0       	ldi	r25, 0x04	; 4
     f78:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
		APP_Delay_ms(2000);
     f7c:	60 ed       	ldi	r22, 0xD0	; 208
     f7e:	77 e0       	ldi	r23, 0x07	; 7
     f80:	80 e0       	ldi	r24, 0x00	; 0
     f82:	90 e0       	ldi	r25, 0x00	; 0
     f84:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
		/* BLOCK THE card */
		CardMotorRight();
     f88:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <CardMotorRight>
		LCD_clear_screen();
     f8c:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
		LCD_display_String("The Card has     been blocked ");
     f90:	86 e4       	ldi	r24, 0x46	; 70
     f92:	94 e0       	ldi	r25, 0x04	; 4
     f94:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
		APP_Delay_ms(2000);
     f98:	60 ed       	ldi	r22, 0xD0	; 208
     f9a:	77 e0       	ldi	r23, 0x07	; 7
     f9c:	80 e0       	ldi	r24, 0x00	; 0
     f9e:	90 e0       	ldi	r25, 0x00	; 0
     fa0:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
		LCD_clear_screen();
     fa4:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
		LCD_display_String("Please contact  service provider");
     fa8:	85 e6       	ldi	r24, 0x65	; 101
     faa:	94 e0       	ldi	r25, 0x04	; 4
     fac:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
		APP_Delay_ms(2000);
     fb0:	60 ed       	ldi	r22, 0xD0	; 208
     fb2:	77 e0       	ldi	r23, 0x07	; 7
     fb4:	80 e0       	ldi	r24, 0x00	; 0
     fb6:	90 e0       	ldi	r25, 0x00	; 0
     fb8:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
		CardinsertionState =not_inserted;
     fbc:	81 e0       	ldi	r24, 0x01	; 1
     fbe:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
	}
}
     fc2:	08 95       	ret

00000fc4 <APP_UpdateState>:
}


ATM_ERRORS_t APP_UpdateState(void)
{
	if (CardinsertionState== Inserted)
     fc4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     fc8:	81 11       	cpse	r24, r1
     fca:	08 c0       	rjmp	.+16     	; 0xfdc <APP_UpdateState+0x18>
	{
		/*TEST */
		LCD_clear_screen();
     fcc:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
		APP_GetCardData();
     fd0:	0e 94 c7 00 	call	0x18e	; 0x18e <APP_GetCardData>
		APP_ExtractDataFromFrame();
     fd4:	0e 94 db 00 	call	0x1b6	; 0x1b6 <APP_ExtractDataFromFrame>
		APP_responseToCardInsertion();
     fd8:	0e 94 3d 06 	call	0xc7a	; 0xc7a <APP_responseToCardInsertion>
	}
	
}
     fdc:	08 95       	ret

00000fde <APP_AdminCheckPassword>:

uint8_t APP_AdminCheckPassword(void)
{
	uint8_t u8_counter=0;
	uint8_t u_flag =0;
	APP_ReceiveFromTerminal();
     fde:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <APP_ReceiveFromTerminal>
	for(u8_counter=0;u8_counter<4;u8_counter++)
	{
		if(AdminPassword[u8_counter] == TerminalBuffer[u8_counter])
     fe2:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <AdminPassword>
     fe6:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <TerminalBuffer>
     fea:	98 13       	cpse	r25, r24
     fec:	0f c0       	rjmp	.+30     	; 0x100c <APP_AdminCheckPassword+0x2e>
     fee:	e2 e6       	ldi	r30, 0x62	; 98
     ff0:	f0 e0       	ldi	r31, 0x00	; 0
     ff2:	aa e9       	ldi	r26, 0x9A	; 154
     ff4:	b7 e0       	ldi	r27, 0x07	; 7
     ff6:	25 e6       	ldi	r18, 0x65	; 101
     ff8:	30 e0       	ldi	r19, 0x00	; 0
     ffa:	91 91       	ld	r25, Z+
     ffc:	8d 91       	ld	r24, X+
     ffe:	98 13       	cpse	r25, r24
    1000:	07 c0       	rjmp	.+14     	; 0x1010 <APP_AdminCheckPassword+0x32>
uint8_t APP_AdminCheckPassword(void)
{
	uint8_t u8_counter=0;
	uint8_t u_flag =0;
	APP_ReceiveFromTerminal();
	for(u8_counter=0;u8_counter<4;u8_counter++)
    1002:	e2 17       	cp	r30, r18
    1004:	f3 07       	cpc	r31, r19
    1006:	c9 f7       	brne	.-14     	; 0xffa <APP_AdminCheckPassword+0x1c>
}

uint8_t APP_AdminCheckPassword(void)
{
	uint8_t u8_counter=0;
	uint8_t u_flag =0;
    1008:	90 e0       	ldi	r25, 0x00	; 0
    100a:	03 c0       	rjmp	.+6      	; 0x1012 <APP_AdminCheckPassword+0x34>
		if(AdminPassword[u8_counter] == TerminalBuffer[u8_counter])
		{
			continue;
		}
		else{
			u_flag =1;
    100c:	91 e0       	ldi	r25, 0x01	; 1
    100e:	01 c0       	rjmp	.+2      	; 0x1012 <APP_AdminCheckPassword+0x34>
    1010:	91 e0       	ldi	r25, 0x01	; 1
    1012:	81 e0       	ldi	r24, 0x01	; 1
    1014:	91 30       	cpi	r25, 0x01	; 1
    1016:	09 f4       	brne	.+2      	; 0x101a <APP_AdminCheckPassword+0x3c>
    1018:	80 e0       	ldi	r24, 0x00	; 0
	}
	 
	
	
	
}
    101a:	08 95       	ret

0000101c <APP_DisplayCustomerDatafromBuffer>:

uint8_t APP_DisplayCustomerDatafromBuffer(void)
{
    101c:	ef 92       	push	r14
    101e:	ff 92       	push	r15
    1020:	0f 93       	push	r16
    1022:	1f 93       	push	r17
    1024:	cf 93       	push	r28
    1026:	df 93       	push	r29
    1028:	00 d0       	rcall	.+0      	; 0x102a <APP_DisplayCustomerDatafromBuffer+0xe>
    102a:	00 d0       	rcall	.+0      	; 0x102c <APP_DisplayCustomerDatafromBuffer+0x10>
    102c:	1f 92       	push	r1
    102e:	cd b7       	in	r28, 0x3d	; 61
    1030:	de b7       	in	r29, 0x3e	; 62
	uint8_t u8_counter =0;
	uint16_t U16_customerID=0;
	uint8_t u8_Temp;
	U16_customerID =APP_GetCustomerID();
    1032:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <APP_GetCustomerID>
    1036:	8c 01       	movw	r16, r24
	uint8_t IDstring[5]={0,0,0,0,0};
    1038:	fe 01       	movw	r30, r28
    103a:	31 96       	adiw	r30, 0x01	; 1
    103c:	85 e0       	ldi	r24, 0x05	; 5
    103e:	df 01       	movw	r26, r30
    1040:	1d 92       	st	X+, r1
    1042:	8a 95       	dec	r24
    1044:	e9 f7       	brne	.-6      	; 0x1040 <APP_DisplayCustomerDatafromBuffer+0x24>
	
	
	if (U16_customerID==0)
    1046:	01 15       	cp	r16, r1
    1048:	11 05       	cpc	r17, r1
    104a:	31 f4       	brne	.+12     	; 0x1058 <APP_DisplayCustomerDatafromBuffer+0x3c>
	{
		APP_APPToTerminalResponse('0');
    104c:	80 e3       	ldi	r24, 0x30	; 48
    104e:	90 e0       	ldi	r25, 0x00	; 0
    1050:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
		return ERROR;
    1054:	80 e0       	ldi	r24, 0x00	; 0
    1056:	8b c0       	rjmp	.+278    	; 0x116e <APP_DisplayCustomerDatafromBuffer+0x152>
	}
	u8_counter=3;
	APP_APPToTerminalResponse("*************************************************************\r");
    1058:	86 e8       	ldi	r24, 0x86	; 134
    105a:	94 e0       	ldi	r25, 0x04	; 4
    105c:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
    1060:	fe 01       	movw	r30, r28
    1062:	35 96       	adiw	r30, 0x05	; 5
    1064:	ae 01       	movw	r20, r28
    1066:	4e 5f       	subi	r20, 0xFE	; 254
    1068:	5f 4f       	sbci	r21, 0xFF	; 255
	/* convert the number to string */
	while(u8_counter !=0)
	{
		IDstring[u8_counter] = (U16_customerID %10)+48;
    106a:	98 01       	movw	r18, r16
    106c:	ad ec       	ldi	r26, 0xCD	; 205
    106e:	bc ec       	ldi	r27, 0xCC	; 204
    1070:	0e 94 e2 15 	call	0x2bc4	; 0x2bc4 <__umulhisi3>
    1074:	96 95       	lsr	r25
    1076:	87 95       	ror	r24
    1078:	96 95       	lsr	r25
    107a:	87 95       	ror	r24
    107c:	96 95       	lsr	r25
    107e:	87 95       	ror	r24
    1080:	9c 01       	movw	r18, r24
    1082:	22 0f       	add	r18, r18
    1084:	33 1f       	adc	r19, r19
    1086:	88 0f       	add	r24, r24
    1088:	99 1f       	adc	r25, r25
    108a:	88 0f       	add	r24, r24
    108c:	99 1f       	adc	r25, r25
    108e:	88 0f       	add	r24, r24
    1090:	99 1f       	adc	r25, r25
    1092:	82 0f       	add	r24, r18
    1094:	93 1f       	adc	r25, r19
    1096:	98 01       	movw	r18, r16
    1098:	28 1b       	sub	r18, r24
    109a:	39 0b       	sbc	r19, r25
    109c:	c9 01       	movw	r24, r18
    109e:	80 5d       	subi	r24, 0xD0	; 208
    10a0:	82 93       	st	-Z, r24
		U16_customerID =U16_customerID/10;
    10a2:	98 01       	movw	r18, r16
    10a4:	0e 94 e2 15 	call	0x2bc4	; 0x2bc4 <__umulhisi3>
    10a8:	8c 01       	movw	r16, r24
    10aa:	16 95       	lsr	r17
    10ac:	07 95       	ror	r16
    10ae:	16 95       	lsr	r17
    10b0:	07 95       	ror	r16
    10b2:	16 95       	lsr	r17
    10b4:	07 95       	ror	r16
		return ERROR;
	}
	u8_counter=3;
	APP_APPToTerminalResponse("*************************************************************\r");
	/* convert the number to string */
	while(u8_counter !=0)
    10b6:	4e 17       	cp	r20, r30
    10b8:	5f 07       	cpc	r21, r31
    10ba:	b9 f6       	brne	.-82     	; 0x106a <APP_DisplayCustomerDatafromBuffer+0x4e>
	{
		IDstring[u8_counter] = (U16_customerID %10)+48;
		U16_customerID =U16_customerID/10;
		u8_counter--;
	}
	 IDstring[u8_counter] = (U16_customerID %10)+48;
    10bc:	98 01       	movw	r18, r16
    10be:	0e 94 e2 15 	call	0x2bc4	; 0x2bc4 <__umulhisi3>
    10c2:	96 95       	lsr	r25
    10c4:	87 95       	ror	r24
    10c6:	96 95       	lsr	r25
    10c8:	87 95       	ror	r24
    10ca:	96 95       	lsr	r25
    10cc:	87 95       	ror	r24
    10ce:	9c 01       	movw	r18, r24
    10d0:	22 0f       	add	r18, r18
    10d2:	33 1f       	adc	r19, r19
    10d4:	88 0f       	add	r24, r24
    10d6:	99 1f       	adc	r25, r25
    10d8:	88 0f       	add	r24, r24
    10da:	99 1f       	adc	r25, r25
    10dc:	88 0f       	add	r24, r24
    10de:	99 1f       	adc	r25, r25
    10e0:	82 0f       	add	r24, r18
    10e2:	93 1f       	adc	r25, r19
    10e4:	08 1b       	sub	r16, r24
    10e6:	19 0b       	sbc	r17, r25
    10e8:	00 5d       	subi	r16, 0xD0	; 208
    10ea:	09 83       	std	Y+1, r16	; 0x01
	
	APP_APPToTerminalResponse("ID : ");
    10ec:	85 ec       	ldi	r24, 0xC5	; 197
    10ee:	94 e0       	ldi	r25, 0x04	; 4
    10f0:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	APP_APPToTerminalResponse(IDstring);
    10f4:	ce 01       	movw	r24, r28
    10f6:	01 96       	adiw	r24, 0x01	; 1
    10f8:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	APP_APPToTerminalResponse("\r");
    10fc:	88 ef       	ldi	r24, 0xF8	; 248
    10fe:	94 e0       	ldi	r25, 0x04	; 4
    1100:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	
	/* display PAN */
	APP_APPToTerminalResponse("PAN Number :");
    1104:	8b ec       	ldi	r24, 0xCB	; 203
    1106:	94 e0       	ldi	r25, 0x04	; 4
    1108:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
    110c:	0f 2e       	mov	r0, r31
    110e:	ff ea       	ldi	r31, 0xAF	; 175
    1110:	ef 2e       	mov	r14, r31
    1112:	f7 e0       	ldi	r31, 0x07	; 7
    1114:	ff 2e       	mov	r15, r31
    1116:	f0 2d       	mov	r31, r0
    1118:	08 eb       	ldi	r16, 0xB8	; 184
    111a:	17 e0       	ldi	r17, 0x07	; 7
	for(u8_counter=2;u8_counter<11;u8_counter++)
	{
		USART_Transmit(CustomerData[u8_counter]);
    111c:	d7 01       	movw	r26, r14
    111e:	8d 91       	ld	r24, X+
    1120:	7d 01       	movw	r14, r26
    1122:	90 e0       	ldi	r25, 0x00	; 0
    1124:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <USART_Transmit>
	APP_APPToTerminalResponse(IDstring);
	APP_APPToTerminalResponse("\r");
	
	/* display PAN */
	APP_APPToTerminalResponse("PAN Number :");
	for(u8_counter=2;u8_counter<11;u8_counter++)
    1128:	0e 15       	cp	r16, r14
    112a:	1f 05       	cpc	r17, r15
    112c:	b9 f7       	brne	.-18     	; 0x111c <APP_DisplayCustomerDatafromBuffer+0x100>
	{
		USART_Transmit(CustomerData[u8_counter]);
	}
	APP_APPToTerminalResponse("\r");
    112e:	88 ef       	ldi	r24, 0xF8	; 248
    1130:	94 e0       	ldi	r25, 0x04	; 4
    1132:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	APP_APPToTerminalResponse("Balance :");
    1136:	88 ed       	ldi	r24, 0xD8	; 216
    1138:	94 e0       	ldi	r25, 0x04	; 4
    113a:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
    113e:	0f 2e       	mov	r0, r31
    1140:	f0 ec       	ldi	r31, 0xC0	; 192
    1142:	ef 2e       	mov	r14, r31
    1144:	f7 e0       	ldi	r31, 0x07	; 7
    1146:	ff 2e       	mov	r15, r31
    1148:	f0 2d       	mov	r31, r0
	/* display balance */
	for(u8_counter=11;u8_counter<19;u8_counter++)
	{
		USART_Transmit(CustomerData[u8_counter]);
    114a:	f8 01       	movw	r30, r16
    114c:	81 91       	ld	r24, Z+
    114e:	8f 01       	movw	r16, r30
    1150:	90 e0       	ldi	r25, 0x00	; 0
    1152:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <USART_Transmit>
		USART_Transmit(CustomerData[u8_counter]);
	}
	APP_APPToTerminalResponse("\r");
	APP_APPToTerminalResponse("Balance :");
	/* display balance */
	for(u8_counter=11;u8_counter<19;u8_counter++)
    1156:	0e 15       	cp	r16, r14
    1158:	1f 05       	cpc	r17, r15
    115a:	b9 f7       	brne	.-18     	; 0x114a <APP_DisplayCustomerDatafromBuffer+0x12e>
	{
		USART_Transmit(CustomerData[u8_counter]);
	}
	APP_APPToTerminalResponse("\r");
    115c:	88 ef       	ldi	r24, 0xF8	; 248
    115e:	94 e0       	ldi	r25, 0x04	; 4
    1160:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	APP_APPToTerminalResponse("*************************************************************\r");
    1164:	86 e8       	ldi	r24, 0x86	; 134
    1166:	94 e0       	ldi	r25, 0x04	; 4
    1168:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	return NO_ERROR;
    116c:	81 e0       	ldi	r24, 0x01	; 1
}
    116e:	0f 90       	pop	r0
    1170:	0f 90       	pop	r0
    1172:	0f 90       	pop	r0
    1174:	0f 90       	pop	r0
    1176:	0f 90       	pop	r0
    1178:	df 91       	pop	r29
    117a:	cf 91       	pop	r28
    117c:	1f 91       	pop	r17
    117e:	0f 91       	pop	r16
    1180:	ff 90       	pop	r15
    1182:	ef 90       	pop	r14
    1184:	08 95       	ret

00001186 <APP_displayAllCustomer>:

uint8_t APP_displayAllCustomer(void)
{
    1186:	0f 93       	push	r16
    1188:	1f 93       	push	r17
    118a:	cf 93       	push	r28
    118c:	df 93       	push	r29
	uint16_t u16_counter=0;
	uint16_t u16_CustomesNumber=0;
	/* Get total number of customers */
	/* first read Total number */
	u16_CustomesNumber = APP_NumberofStoredCustomers();
    118e:	0e 94 c1 04 	call	0x982	; 0x982 <APP_NumberofStoredCustomers>
    1192:	8c 01       	movw	r16, r24
	if (u16_CustomesNumber ==0)
    1194:	89 2b       	or	r24, r25
    1196:	71 f4       	brne	.+28     	; 0x11b4 <APP_displayAllCustomer+0x2e>
	{
		APP_APPToTerminalResponse("****************************************************\r");
    1198:	8f e8       	ldi	r24, 0x8F	; 143
    119a:	94 e0       	ldi	r25, 0x04	; 4
    119c:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
		APP_APPToTerminalResponse("Data base is empty !! \r");
    11a0:	82 ee       	ldi	r24, 0xE2	; 226
    11a2:	94 e0       	ldi	r25, 0x04	; 4
    11a4:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
		APP_APPToTerminalResponse("****************************************************\r");
    11a8:	8f e8       	ldi	r24, 0x8F	; 143
    11aa:	94 e0       	ldi	r25, 0x04	; 4
    11ac:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
		return NO_ERROR;
    11b0:	81 e0       	ldi	r24, 0x01	; 1
    11b2:	1d c0       	rjmp	.+58     	; 0x11ee <APP_displayAllCustomer+0x68>
		
	}
	APP_APPToTerminalResponse("Total number of customers is : ");
    11b4:	8a ef       	ldi	r24, 0xFA	; 250
    11b6:	94 e0       	ldi	r25, 0x04	; 4
    11b8:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	APP_DisplayTotNumOfCustomers();
    11bc:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <APP_DisplayTotNumOfCustomers>
	APP_APPToTerminalResponse("\r");
    11c0:	88 ef       	ldi	r24, 0xF8	; 248
    11c2:	94 e0       	ldi	r25, 0x04	; 4
    11c4:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	APP_APPToTerminalResponse("*******************************************************\r");
    11c8:	8c e8       	ldi	r24, 0x8C	; 140
    11ca:	94 e0       	ldi	r25, 0x04	; 4
    11cc:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
    11d0:	c1 e0       	ldi	r28, 0x01	; 1
    11d2:	d0 e0       	ldi	r29, 0x00	; 0
	
	
	for(u16_counter=1;u16_counter<=u16_CustomesNumber;u16_counter++)
	{
		APP_ReadCustomerDataByID(u16_counter);
    11d4:	ce 01       	movw	r24, r28
    11d6:	0e 94 d0 05 	call	0xba0	; 0xba0 <APP_ReadCustomerDataByID>
		APP_DisplayCustomerDatafromBuffer();
    11da:	0e 94 0e 08 	call	0x101c	; 0x101c <APP_DisplayCustomerDatafromBuffer>
	APP_DisplayTotNumOfCustomers();
	APP_APPToTerminalResponse("\r");
	APP_APPToTerminalResponse("*******************************************************\r");
	
	
	for(u16_counter=1;u16_counter<=u16_CustomesNumber;u16_counter++)
    11de:	21 96       	adiw	r28, 0x01	; 1
    11e0:	0c 17       	cp	r16, r28
    11e2:	1d 07       	cpc	r17, r29
    11e4:	b8 f7       	brcc	.-18     	; 0x11d4 <APP_displayAllCustomer+0x4e>
	{
		APP_ReadCustomerDataByID(u16_counter);
		APP_DisplayCustomerDatafromBuffer();
	}
	APP_APPToTerminalResponse("*************************************************************\r");
    11e6:	86 e8       	ldi	r24, 0x86	; 134
    11e8:	94 e0       	ldi	r25, 0x04	; 4
    11ea:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
}
    11ee:	df 91       	pop	r29
    11f0:	cf 91       	pop	r28
    11f2:	1f 91       	pop	r17
    11f4:	0f 91       	pop	r16
    11f6:	08 95       	ret

000011f8 <APP_AdminModeHandler>:
	}
}


ATM_ERRORS_t APP_AdminModeHandler(void)
{
    11f8:	cf 93       	push	r28
    11fa:	df 93       	push	r29
    11fc:	c3 e0       	ldi	r28, 0x03	; 3
	uint8_t u8_counter2=0;
	/* check admin password */
	
	while(1)
	{
		APP_APPToTerminalResponse("Please Enter Password\r");
    11fe:	8a e1       	ldi	r24, 0x1A	; 26
    1200:	95 e0       	ldi	r25, 0x05	; 5
    1202:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
		if (APP_AdminCheckPassword()==NO_ERROR)
    1206:	0e 94 ef 07 	call	0xfde	; 0xfde <APP_AdminCheckPassword>
    120a:	81 30       	cpi	r24, 0x01	; 1
    120c:	c1 f1       	breq	.+112    	; 0x127e <APP_AdminModeHandler+0x86>
    120e:	c1 50       	subi	r28, 0x01	; 1
			break;
		}
		else
		{
			u8_counter--;
			if (u8_counter==1)
    1210:	89 f5       	brne	.+98     	; 0x1274 <APP_AdminModeHandler+0x7c>
			{
				APP_APPToTerminalResponse("you entered 3 wrong passwords\r");
    1212:	81 e3       	ldi	r24, 0x31	; 49
    1214:	95 e0       	ldi	r25, 0x05	; 5
    1216:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
				// wait 10 seconds 
				USART_Transmit(0x0C);
    121a:	8c e0       	ldi	r24, 0x0C	; 12
    121c:	90 e0       	ldi	r25, 0x00	; 0
    121e:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <USART_Transmit>
    1222:	c1 e3       	ldi	r28, 0x31	; 49
    1224:	d0 e0       	ldi	r29, 0x00	; 0
				for(u8_counter2=0;u8_counter2<9;u8_counter2++)
				{
					USART_Transmit(u8_counter2+49);
    1226:	ce 01       	movw	r24, r28
    1228:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <USART_Transmit>
					APP_Delay_ms(1000);
    122c:	68 ee       	ldi	r22, 0xE8	; 232
    122e:	73 e0       	ldi	r23, 0x03	; 3
    1230:	80 e0       	ldi	r24, 0x00	; 0
    1232:	90 e0       	ldi	r25, 0x00	; 0
    1234:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
					USART_Transmit(0x0C);
    1238:	8c e0       	ldi	r24, 0x0C	; 12
    123a:	90 e0       	ldi	r25, 0x00	; 0
    123c:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <USART_Transmit>
    1240:	21 96       	adiw	r28, 0x01	; 1
			if (u8_counter==1)
			{
				APP_APPToTerminalResponse("you entered 3 wrong passwords\r");
				// wait 10 seconds 
				USART_Transmit(0x0C);
				for(u8_counter2=0;u8_counter2<9;u8_counter2++)
    1242:	ca 33       	cpi	r28, 0x3A	; 58
    1244:	d1 05       	cpc	r29, r1
    1246:	79 f7       	brne	.-34     	; 0x1226 <APP_AdminModeHandler+0x2e>
				{
					USART_Transmit(u8_counter2+49);
					APP_Delay_ms(1000);
					USART_Transmit(0x0C);
				}
				APP_APPToTerminalResponse("back to operation Mode if you want ADMIN mode Write ADMIN Command\r");
    1248:	80 e5       	ldi	r24, 0x50	; 80
    124a:	95 e0       	ldi	r25, 0x05	; 5
    124c:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
				LCD_clear_screen();
    1250:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
				
				LCD_display_String("1-Insert Card");
    1254:	83 e9       	ldi	r24, 0x93	; 147
    1256:	95 e0       	ldi	r25, 0x05	; 5
    1258:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
				LCD_GoTo_xy(1,0);
    125c:	60 e0       	ldi	r22, 0x00	; 0
    125e:	81 e0       	ldi	r24, 0x01	; 1
    1260:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LCD_GoTo_xy>
				LCD_display_String("2-Temperature");
    1264:	81 ea       	ldi	r24, 0xA1	; 161
    1266:	95 e0       	ldi	r25, 0x05	; 5
    1268:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
				ATM_mode= USER_MODE;
    126c:	81 e0       	ldi	r24, 0x01	; 1
    126e:	80 93 82 07 	sts	0x0782, r24	; 0x800782 <__data_end>
				return ERROR;
    1272:	84 c0       	rjmp	.+264    	; 0x137c <APP_AdminModeHandler+0x184>
				
			}
			APP_APPToTerminalResponse("wrong password\r");
    1274:	8f ea       	ldi	r24, 0xAF	; 175
    1276:	95 e0       	ldi	r25, 0x05	; 5
    1278:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
			
		}
		   
		
	}
    127c:	c0 cf       	rjmp	.-128    	; 0x11fe <APP_AdminModeHandler+0x6>
	/* disable Card insertion interrupt */
	EXTI0_Disable();
    127e:	0e 94 9a 11 	call	0x2334	; 0x2334 <EXTI0_Disable>
	/* display the tha ATM is out of service */
	LCD_clear_screen();
    1282:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
	LCD_display_String("The ATM is      out of service");
    1286:	8f eb       	ldi	r24, 0xBF	; 191
    1288:	95 e0       	ldi	r25, 0x05	; 5
    128a:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
	
	uint8_t u8_receivedData;
	uint8_t u8_ReceivedStringSize;
	/* Disable UART RXC interrupts */
	/* Not to Receiving another ADMIN Command */
	USART_RxInterruptDiable();
    128e:	0e 94 ff 12 	call	0x25fe	; 0x25fe <USART_RxInterruptDiable>
		APP_APPToTerminalResponse("Invalid option\r");
		continue;
	}
	else
	{
		switch(TerminalBuffer[0])
    1292:	c9 e9       	ldi	r28, 0x99	; 153
    1294:	d7 e0       	ldi	r29, 0x07	; 7
while(1)
{
		
	
	/* Display options */
	APP_APPToTerminalResponse("Please select option :\r");
    1296:	8e ed       	ldi	r24, 0xDE	; 222
    1298:	95 e0       	ldi	r25, 0x05	; 5
    129a:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	APP_APPToTerminalResponse("1- Add Customer Data\r");
    129e:	86 ef       	ldi	r24, 0xF6	; 246
    12a0:	95 e0       	ldi	r25, 0x05	; 5
    12a2:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	APP_APPToTerminalResponse("2- Setting Max amount\r");
    12a6:	8c e0       	ldi	r24, 0x0C	; 12
    12a8:	96 e0       	ldi	r25, 0x06	; 6
    12aa:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	APP_APPToTerminalResponse("3- Display all customers Data\r");
    12ae:	83 e2       	ldi	r24, 0x23	; 35
    12b0:	96 e0       	ldi	r25, 0x06	; 6
    12b2:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	APP_APPToTerminalResponse("4-[Be careful] Clear all customers Data\r");
    12b6:	82 e4       	ldi	r24, 0x42	; 66
    12b8:	96 e0       	ldi	r25, 0x06	; 6
    12ba:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	APP_APPToTerminalResponse("5- Exit\r");
    12be:	8b e6       	ldi	r24, 0x6B	; 107
    12c0:	96 e0       	ldi	r25, 0x06	; 6
    12c2:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
	/* receive option */
	u8_ReceivedStringSize = APP_ReceiveFromTerminal();
    12c6:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <APP_ReceiveFromTerminal>
	
	
	/* check the option */
	if (u8_ReceivedStringSize>2)
    12ca:	83 30       	cpi	r24, 0x03	; 3
    12cc:	28 f0       	brcs	.+10     	; 0x12d8 <APP_AdminModeHandler+0xe0>
	{
		APP_APPToTerminalResponse("Invalid option\r");
    12ce:	84 e7       	ldi	r24, 0x74	; 116
    12d0:	96 e0       	ldi	r25, 0x06	; 6
    12d2:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
		continue;
    12d6:	df cf       	rjmp	.-66     	; 0x1296 <APP_AdminModeHandler+0x9e>
	}
	else
	{
		switch(TerminalBuffer[0])
    12d8:	88 81       	ld	r24, Y
    12da:	83 33       	cpi	r24, 0x33	; 51
    12dc:	61 f1       	breq	.+88     	; 0x1336 <APP_AdminModeHandler+0x13e>
    12de:	28 f4       	brcc	.+10     	; 0x12ea <APP_AdminModeHandler+0xf2>
    12e0:	81 33       	cpi	r24, 0x31	; 49
    12e2:	41 f0       	breq	.+16     	; 0x12f4 <APP_AdminModeHandler+0xfc>
    12e4:	82 33       	cpi	r24, 0x32	; 50
    12e6:	e9 f0       	breq	.+58     	; 0x1322 <APP_AdminModeHandler+0x12a>
    12e8:	44 c0       	rjmp	.+136    	; 0x1372 <APP_AdminModeHandler+0x17a>
    12ea:	84 33       	cpi	r24, 0x34	; 52
    12ec:	39 f1       	breq	.+78     	; 0x133c <APP_AdminModeHandler+0x144>
    12ee:	85 33       	cpi	r24, 0x35	; 53
    12f0:	a1 f1       	breq	.+104    	; 0x135a <APP_AdminModeHandler+0x162>
    12f2:	3f c0       	rjmp	.+126    	; 0x1372 <APP_AdminModeHandler+0x17a>
		{
			case '1' :
			{
				if (APP_receivePAN()==NO_ERROR)
    12f4:	0e 94 7d 04 	call	0x8fa	; 0x8fa <APP_receivePAN>
    12f8:	81 30       	cpi	r24, 0x01	; 1
    12fa:	99 f4       	brne	.+38     	; 0x1322 <APP_AdminModeHandler+0x12a>
				{
					if (APP_ReceiveBalance()==NO_ERROR)
    12fc:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <APP_ReceiveBalance>
    1300:	81 30       	cpi	r24, 0x01	; 1
    1302:	79 f4       	brne	.+30     	; 0x1322 <APP_AdminModeHandler+0x12a>
						
						
						/* Store Data into EEPROM */
						/* that means the memory is full */
						uint8_t temp ;
						temp =APP_StoreCustomerDataEEPROM();
    1304:	0e 94 68 05 	call	0xad0	; 0xad0 <APP_StoreCustomerDataEEPROM>
						if (temp == ERROR)
    1308:	88 23       	and	r24, r24
    130a:	29 f2       	breq	.-118    	; 0x1296 <APP_AdminModeHandler+0x9e>
						{
							break;
						}
						else
						{
							APP_APPToTerminalResponse("the Customer Data has been added successfully\r");
    130c:	84 e8       	ldi	r24, 0x84	; 132
    130e:	96 e0       	ldi	r25, 0x06	; 6
    1310:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
							/* Display the total number of the customers */
							APP_APPToTerminalResponse("the New total number of customer in Data base :\r");
    1314:	83 eb       	ldi	r24, 0xB3	; 179
    1316:	96 e0       	ldi	r25, 0x06	; 6
    1318:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
							APP_DisplayTotNumOfCustomers();
    131c:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <APP_DisplayTotNumOfCustomers>
							break;
    1320:	ba cf       	rjmp	.-140    	; 0x1296 <APP_AdminModeHandler+0x9e>
				}
			}
			case '2' :
			{
				uint8_t temp ;
				temp =APP_UpdateMaxAmount();
    1322:	0e 94 36 04 	call	0x86c	; 0x86c <APP_UpdateMaxAmount>
				if (temp==NO_ERROR)
    1326:	81 30       	cpi	r24, 0x01	; 1
    1328:	09 f0       	breq	.+2      	; 0x132c <APP_AdminModeHandler+0x134>
    132a:	b5 cf       	rjmp	.-150    	; 0x1296 <APP_AdminModeHandler+0x9e>
				{
					APP_APPToTerminalResponse("The max amount has been initialized successfully\r");
    132c:	84 ee       	ldi	r24, 0xE4	; 228
    132e:	96 e0       	ldi	r25, 0x06	; 6
    1330:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
					/* update max amount state */
					break;
    1334:	b0 cf       	rjmp	.-160    	; 0x1296 <APP_AdminModeHandler+0x9e>
				    }
				
			}
			case '3' :
			{
				APP_displayAllCustomer();
    1336:	0e 94 c3 08 	call	0x1186	; 0x1186 <APP_displayAllCustomer>
				break;
    133a:	ad cf       	rjmp	.-166    	; 0x1296 <APP_AdminModeHandler+0x9e>
		    }
			case '4' :
			{
				
					APP_ClearTotalNumberOfCustomers();
    133c:	0e 94 bf 05 	call	0xb7e	; 0xb7e <APP_ClearTotalNumberOfCustomers>
					APP_APPToTerminalResponse("*******************************************************\r");
    1340:	8c e8       	ldi	r24, 0x8C	; 140
    1342:	94 e0       	ldi	r25, 0x04	; 4
    1344:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
					APP_APPToTerminalResponse("      Data have been deleted successfully\r");
    1348:	86 e1       	ldi	r24, 0x16	; 22
    134a:	97 e0       	ldi	r25, 0x07	; 7
    134c:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
					APP_APPToTerminalResponse("********************************************************\r");
    1350:	8b e8       	ldi	r24, 0x8B	; 139
    1352:	94 e0       	ldi	r25, 0x04	; 4
    1354:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
				
					break;
    1358:	9e cf       	rjmp	.-196    	; 0x1296 <APP_AdminModeHandler+0x9e>
		
			case '5' :
			{
				
				// Exit handler
				APP_APPToTerminalResponse("back to operation Mode if you want ADMIN mode Write ADMIN Command\r");
    135a:	80 e5       	ldi	r24, 0x50	; 80
    135c:	95 e0       	ldi	r25, 0x05	; 5
    135e:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
				ATM_mode= USER_MODE;
    1362:	81 e0       	ldi	r24, 0x01	; 1
    1364:	80 93 82 07 	sts	0x0782, r24	; 0x800782 <__data_end>
				
				/* Enable accepting Cards again */
				EXTI0_Enable();
    1368:	0e 94 93 11 	call	0x2326	; 0x2326 <EXTI0_Enable>
				/* Enable UART RXC  interrupts */
				USART_RxInterruptEnable();
    136c:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <USART_RxInterruptEnable>
			/*	LCD_clear_screen();
				LCD_display_String("1-Insert Card");
				LCD_GoTo_xy(1,0);
				LCD_display_String("2-Temperature");*/
				return ERROR;
    1370:	05 c0       	rjmp	.+10     	; 0x137c <APP_AdminModeHandler+0x184>
				break;
			}
			default:
			{
				APP_APPToTerminalResponse("Invalid option\r");
    1372:	84 e7       	ldi	r24, 0x74	; 116
    1374:	96 e0       	ldi	r25, 0x06	; 6
    1376:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
    137a:	8d cf       	rjmp	.-230    	; 0x1296 <APP_AdminModeHandler+0x9e>
}
    /* Enable accepting Cards again */
	 EXTI0_Enable();
	/* Enable UART RXC  interrupts */
	USART_RxInterruptEnable();
}
    137c:	80 e0       	ldi	r24, 0x00	; 0
    137e:	df 91       	pop	r29
    1380:	cf 91       	pop	r28
    1382:	08 95       	ret

00001384 <APP_UartAdminCommandHandler>:

void APP_UartAdminCommandHandler(void)
{
	
	
	if (*pu8_uartReceiveData=='\r' || gu8_counter==5)
    1384:	e0 91 11 08 	lds	r30, 0x0811	; 0x800811 <pu8_uartReceiveData>
    1388:	f0 91 12 08 	lds	r31, 0x0812	; 0x800812 <pu8_uartReceiveData+0x1>
    138c:	90 81       	ld	r25, Z
    138e:	9d 30       	cpi	r25, 0x0D	; 13
    1390:	21 f0       	breq	.+8      	; 0x139a <APP_UartAdminCommandHandler+0x16>
    1392:	80 91 84 07 	lds	r24, 0x0784	; 0x800784 <gu8_counter>
    1396:	85 30       	cpi	r24, 0x05	; 5
    1398:	d1 f4       	brne	.+52     	; 0x13ce <APP_UartAdminCommandHandler+0x4a>
	{
		Command[gu8_counter]='\r';
    139a:	e0 91 84 07 	lds	r30, 0x0784	; 0x800784 <gu8_counter>
    139e:	f0 e0       	ldi	r31, 0x00	; 0
    13a0:	eb 5e       	subi	r30, 0xEB	; 235
    13a2:	f7 4f       	sbci	r31, 0xF7	; 247
    13a4:	8d e0       	ldi	r24, 0x0D	; 13
    13a6:	80 83       	st	Z, r24
		/* compare the command*/
		if (APP_CommandCompare()==EQUAL)
    13a8:	0e 94 5e 00 	call	0xbc	; 0xbc <APP_CommandCompare>
    13ac:	81 11       	cpse	r24, r1
    13ae:	04 c0       	rjmp	.+8      	; 0x13b8 <APP_UartAdminCommandHandler+0x34>
		{
			ATM_mode = ADMIN_MODE;
    13b0:	10 92 82 07 	sts	0x0782, r1	; 0x800782 <__data_end>
			APP_AdminModeHandler();
    13b4:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <APP_AdminModeHandler>
		}
		
		
		/* clear buffers and vars */
		gu8_counter =0;
    13b8:	10 92 84 07 	sts	0x0784, r1	; 0x800784 <gu8_counter>
		uint8_t u8_I;
		for(u8_I=0;u8_I<6;u8_I++)
		{
			Command[u8_I]=0;
    13bc:	e5 e1       	ldi	r30, 0x15	; 21
    13be:	f8 e0       	ldi	r31, 0x08	; 8
    13c0:	10 82       	st	Z, r1
    13c2:	11 82       	std	Z+1, r1	; 0x01
    13c4:	12 82       	std	Z+2, r1	; 0x02
    13c6:	13 82       	std	Z+3, r1	; 0x03
    13c8:	14 82       	std	Z+4, r1	; 0x04
    13ca:	15 82       	std	Z+5, r1	; 0x05
    13cc:	08 c0       	rjmp	.+16     	; 0x13de <APP_UartAdminCommandHandler+0x5a>
		
	}
	/* receive data into command buffer */
	else
	{
		Command[gu8_counter]=*pu8_uartReceiveData;
    13ce:	e8 2f       	mov	r30, r24
    13d0:	f0 e0       	ldi	r31, 0x00	; 0
    13d2:	eb 5e       	subi	r30, 0xEB	; 235
    13d4:	f7 4f       	sbci	r31, 0xF7	; 247
    13d6:	90 83       	st	Z, r25
		gu8_counter++;
    13d8:	8f 5f       	subi	r24, 0xFF	; 255
    13da:	80 93 84 07 	sts	0x0784, r24	; 0x800784 <gu8_counter>
	}
	
	/* update the ATM to user mode */
	ATM_mode =USER_MODE;
    13de:	81 e0       	ldi	r24, 0x01	; 1
    13e0:	80 93 82 07 	sts	0x0782, r24	; 0x800782 <__data_end>
    13e4:	08 95       	ret

000013e6 <APP_ATMStatuscheck>:
		APP_DisplayCustomerDatafromBuffer();
	}
	APP_APPToTerminalResponse("*************************************************************\r");
}
uint8_t APP_ATMStatuscheck(void)
{
    13e6:	cf 92       	push	r12
    13e8:	df 92       	push	r13
    13ea:	ef 92       	push	r14
    13ec:	ff 92       	push	r15
    13ee:	cf 93       	push	r28
   float fMAXAmount;
	/* get max amount from Data base */
	APP_GetMaxAmountFromDB();
    13f0:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <APP_GetMaxAmountFromDB>
	
	fMAXAmount = APP_stringToFloat(MAXamountBuffer,8);
    13f4:	68 e0       	ldi	r22, 0x08	; 8
    13f6:	85 e0       	ldi	r24, 0x05	; 5
    13f8:	98 e0       	ldi	r25, 0x08	; 8
    13fa:	0e 94 29 02 	call	0x452	; 0x452 <APP_stringToFloat>
    13fe:	6b 01       	movw	r12, r22
    1400:	7c 01       	movw	r14, r24
	/*check if max amount is set */
	
	
	if ((int)fMAXAmount !=0 && fMAXAmount != 0xffff)
    1402:	0e 94 42 14 	call	0x2884	; 0x2884 <__fixsfsi>
    1406:	67 2b       	or	r22, r23
    1408:	69 f0       	breq	.+26     	; 0x1424 <APP_ATMStatuscheck+0x3e>
	{
		return NO_ERROR;
    140a:	c1 e0       	ldi	r28, 0x01	; 1
    140c:	20 e0       	ldi	r18, 0x00	; 0
    140e:	3f ef       	ldi	r19, 0xFF	; 255
    1410:	4f e7       	ldi	r20, 0x7F	; 127
    1412:	57 e4       	ldi	r21, 0x47	; 71
    1414:	c7 01       	movw	r24, r14
    1416:	b6 01       	movw	r22, r12
    1418:	0e 94 cb 13 	call	0x2796	; 0x2796 <__cmpsf2>
    141c:	81 11       	cpse	r24, r1
    141e:	03 c0       	rjmp	.+6      	; 0x1426 <APP_ATMStatuscheck+0x40>
    1420:	c0 e0       	ldi	r28, 0x00	; 0
    1422:	01 c0       	rjmp	.+2      	; 0x1426 <APP_ATMStatuscheck+0x40>
	}
	return ERROR;
    1424:	c0 e0       	ldi	r28, 0x00	; 0
}
    1426:	8c 2f       	mov	r24, r28
    1428:	cf 91       	pop	r28
    142a:	ff 90       	pop	r15
    142c:	ef 90       	pop	r14
    142e:	df 90       	pop	r13
    1430:	cf 90       	pop	r12
    1432:	08 95       	ret

00001434 <APP_Init>:
float fBalance;
float fAmount ;
/*******************************************************************************/
ATM_ERRORS_t APP_Init(void)
{
	GptInit();
    1434:	0e 94 0b 12 	call	0x2416	; 0x2416 <GptInit>
	USART_Init();
    1438:	0e 94 bf 12 	call	0x257e	; 0x257e <USART_Init>
	MCAL_SpiInit();
    143c:	0e 94 c8 11 	call	0x2390	; 0x2390 <MCAL_SpiInit>
	LCD_init();
    1440:	0e 94 67 0c 	call	0x18ce	; 0x18ce <LCD_init>
	keyPad_init();
    1444:	0e 94 e3 0a 	call	0x15c6	; 0x15c6 <keyPad_init>
	ECUAL_EEPROMInit();
    1448:	0e 94 8d 0a 	call	0x151a	; 0x151a <ECUAL_EEPROMInit>
	MOTOR_Init();
    144c:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <MOTOR_Init>
	EXTI0_init(Failing);
    1450:	83 e0       	ldi	r24, 0x03	; 3
    1452:	0e 94 6f 11 	call	0x22de	; 0x22de <EXTI0_init>
	/* set EXTI0 call back function */
	SetEXTI0CallBackFunction(EXTI0_Handler);
    1456:	89 e4       	ldi	r24, 0x49	; 73
    1458:	90 e0       	ldi	r25, 0x00	; 0
    145a:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <SetEXTI0CallBackFunction>
	                 /*PORTA P0     5V at AVCC */
	TempSensorInit(TEMPSENSOR_CH,TEPSENSOR_VREF);
    145e:	65 e0       	ldi	r22, 0x05	; 5
    1460:	80 e0       	ldi	r24, 0x00	; 0
    1462:	0e 94 1f 0e 	call	0x1c3e	; 0x1c3e <TempSensorInit>
	/* initialize the UART to receive Command using interrupts */
	USART_Receive_INTDriven(pu8_uartReceiveData,APP_UartAdminCommandHandler);
    1466:	62 ec       	ldi	r22, 0xC2	; 194
    1468:	79 e0       	ldi	r23, 0x09	; 9
    146a:	80 91 11 08 	lds	r24, 0x0811	; 0x800811 <pu8_uartReceiveData>
    146e:	90 91 12 08 	lds	r25, 0x0812	; 0x800812 <pu8_uartReceiveData+0x1>
    1472:	0e 94 ef 12 	call	0x25de	; 0x25de <USART_Receive_INTDriven>
	if (APP_ATMStatuscheck()==ERROR)
    1476:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <APP_ATMStatuscheck>
    147a:	81 11       	cpse	r24, r1
    147c:	05 c0       	rjmp	.+10     	; 0x1488 <APP_Init+0x54>
	{
		APP_APPToTerminalResponse("MAX Amount is not initialized \r");
    147e:	81 e4       	ldi	r24, 0x41	; 65
    1480:	97 e0       	ldi	r25, 0x07	; 7
    1482:	0e 94 b3 00 	call	0x166	; 0x166 <APP_APPToTerminalResponse>
    1486:	08 95       	ret
	}
	else
	{
		ATM_mode =USER_MODE;
    1488:	81 e0       	ldi	r24, 0x01	; 1
    148a:	80 93 82 07 	sts	0x0782, r24	; 0x800782 <__data_end>
	}
	
}
    148e:	08 95       	ret

00001490 <APP_GetState>:
}


ATM_ERRORS_t APP_GetState(void)
{
	if (APP_ATMStatuscheck()==NO_ERROR)
    1490:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <APP_ATMStatuscheck>
    1494:	81 30       	cpi	r24, 0x01	; 1
    1496:	19 f4       	brne	.+6      	; 0x149e <APP_GetState+0xe>
	{
		ATM_mode=USER_MODE;
    1498:	80 93 82 07 	sts	0x0782, r24	; 0x800782 <__data_end>
    149c:	04 c0       	rjmp	.+8      	; 0x14a6 <APP_GetState+0x16>
	}
	uint8_t u8_KEY;
	if (ATM_mode==USER_MODE)
    149e:	80 91 82 07 	lds	r24, 0x0782	; 0x800782 <__data_end>
    14a2:	81 30       	cpi	r24, 0x01	; 1
    14a4:	c9 f5       	brne	.+114    	; 0x1518 <APP_GetState+0x88>
	{
		LCD_clear_screen();
    14a6:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
		
		LCD_display_String("1-Insert Card");
    14aa:	83 e9       	ldi	r24, 0x93	; 147
    14ac:	95 e0       	ldi	r25, 0x05	; 5
    14ae:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
		LCD_GoTo_xy(1,0);
    14b2:	60 e0       	ldi	r22, 0x00	; 0
    14b4:	81 e0       	ldi	r24, 0x01	; 1
    14b6:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LCD_GoTo_xy>
		LCD_display_String("2-Temperature");
    14ba:	81 ea       	ldi	r24, 0xA1	; 161
    14bc:	95 e0       	ldi	r25, 0x05	; 5
    14be:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
		
		while(1)
		{
			
			u8_KEY =keyPad_GetKey();
    14c2:	0e 94 39 0b 	call	0x1672	; 0x1672 <keyPad_GetKey>
			if (u8_KEY=='1')
    14c6:	81 33       	cpi	r24, 0x31	; 49
    14c8:	69 f4       	brne	.+26     	; 0x14e4 <APP_GetState+0x54>
			{
				/* Enable INT0 */
				EXTI0_Enable();
    14ca:	0e 94 93 11 	call	0x2326	; 0x2326 <EXTI0_Enable>
				LCD_clear_screen();
    14ce:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
				LCD_display_String("Insert The Card");
    14d2:	81 e6       	ldi	r24, 0x61	; 97
    14d4:	97 e0       	ldi	r25, 0x07	; 7
    14d6:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
				/* wait till card insertion */
				
				while(CardinsertionState !=Inserted);
    14da:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    14de:	81 11       	cpse	r24, r1
    14e0:	fc cf       	rjmp	.-8      	; 0x14da <APP_GetState+0x4a>
    14e2:	08 95       	ret
				break;
			}
			else if (u8_KEY=='2')
    14e4:	82 33       	cpi	r24, 0x32	; 50
    14e6:	69 f7       	brne	.-38     	; 0x14c2 <APP_GetState+0x32>
			{
				/* display temp */
				LCD_clear_screen();
    14e8:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
				LCD_display_String("Temperature is :");
    14ec:	81 e7       	ldi	r24, 0x71	; 113
    14ee:	97 e0       	ldi	r25, 0x07	; 7
    14f0:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
				LCD_GoTo_xy(1,0);
    14f4:	60 e0       	ldi	r22, 0x00	; 0
    14f6:	81 e0       	ldi	r24, 0x01	; 1
    14f8:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LCD_GoTo_xy>
				LCD_DisplayInteger(APP_GetTemperature())  ;
    14fc:	0e 94 50 00 	call	0xa0	; 0xa0 <APP_GetTemperature>
    1500:	68 2f       	mov	r22, r24
    1502:	70 e0       	ldi	r23, 0x00	; 0
    1504:	80 e0       	ldi	r24, 0x00	; 0
    1506:	90 e0       	ldi	r25, 0x00	; 0
    1508:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <LCD_DisplayInteger>
				APP_Delay_ms(2000);
    150c:	60 ed       	ldi	r22, 0xD0	; 208
    150e:	77 e0       	ldi	r23, 0x07	; 7
    1510:	80 e0       	ldi	r24, 0x00	; 0
    1512:	90 e0       	ldi	r25, 0x00	; 0
    1514:	0e 94 87 00 	call	0x10e	; 0x10e <APP_Delay_ms>
			{
				continue;
			}
	}
}
}
    1518:	08 95       	ret

0000151a <ECUAL_EEPROMInit>:
/********************************************************************/

void ECUAL_EEPROMInit(void)
{
	/* MCU Configured as a Master */
	Master_Configure_t.Master_ADDRESS=1;
    151a:	eb e1       	ldi	r30, 0x1B	; 27
    151c:	f8 e0       	ldi	r31, 0x08	; 8
    151e:	81 e0       	ldi	r24, 0x01	; 1
    1520:	82 83       	std	Z+2, r24	; 0x02
	Master_Configure_t.TWBR_VALUE=100;
    1522:	84 e6       	ldi	r24, 0x64	; 100
    1524:	80 83       	st	Z, r24
	Master_Configure_t.TWPS_PRESCAL_VAL=NO_PRESCALE;
    1526:	11 82       	std	Z+1, r1	; 0x01
	MCAL_I2CMasterInit(&Master_Configure_t);
    1528:	cf 01       	movw	r24, r30
    152a:	0e 94 fe 10 	call	0x21fc	; 0x21fc <MCAL_I2CMasterInit>
    152e:	08 95       	ret

00001530 <ECUAL_EEPROMWrite>:
	
}  
                        
void ECUAL_EEPROMWrite( uint16_t u16_MEMAddress , uint8_t u8_DataWrite)
{
    1530:	cf 93       	push	r28
    1532:	df 93       	push	r29
    1534:	00 d0       	rcall	.+0      	; 0x1536 <ECUAL_EEPROMWrite+0x6>
    1536:	1f 92       	push	r1
    1538:	cd b7       	in	r28, 0x3d	; 61
    153a:	de b7       	in	r29, 0x3e	; 62
    153c:	6b 83       	std	Y+3, r22	; 0x03
	/* the First word address the MSB 8 bits of the address */ 
	uint8_t u8_FW_ADD =(uint8_t)(u16_MEMAddress>>8);
    153e:	99 83       	std	Y+1, r25	; 0x01
	/* second word address the LSB 8 bits of the address */
	uint8_t u8_SW_ADD=(uint8_t)(u16_MEMAddress);
    1540:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t u8_ControlByte =0b01010000;  //1010 then 000 slave address then 0 for write operation
	// this byte will be shifted in i2c write will be 10100000 and for repeat start 10100001
	
		
	/* initiate the start condition with control byte */
	MCAL_I2CMaterEstablishComm(u8_ControlByte);
    1542:	80 e5       	ldi	r24, 0x50	; 80
    1544:	0e 94 09 11 	call	0x2212	; 0x2212 <MCAL_I2CMaterEstablishComm>
	
	/*first word memory address in EEPROM */
	MCAL_I2CMasterWrightData(&u8_FW_ADD);
    1548:	ce 01       	movw	r24, r28
    154a:	01 96       	adiw	r24, 0x01	; 1
    154c:	0e 94 44 11 	call	0x2288	; 0x2288 <MCAL_I2CMasterWrightData>
	
	/*first word memory address in EEPROM */
	MCAL_I2CMasterWrightData(&u8_SW_ADD);
    1550:	ce 01       	movw	r24, r28
    1552:	02 96       	adiw	r24, 0x02	; 2
    1554:	0e 94 44 11 	call	0x2288	; 0x2288 <MCAL_I2CMasterWrightData>
	
	/* write data into the address */
	MCAL_I2CMasterWrightData(&u8_DataWrite);
    1558:	ce 01       	movw	r24, r28
    155a:	03 96       	adiw	r24, 0x03	; 3
    155c:	0e 94 44 11 	call	0x2288	; 0x2288 <MCAL_I2CMasterWrightData>
	
	/* send stop condition */
	MCAL_I2CMasterStopCondition();
    1560:	0e 94 64 11 	call	0x22c8	; 0x22c8 <MCAL_I2CMasterStopCondition>
}
    1564:	0f 90       	pop	r0
    1566:	0f 90       	pop	r0
    1568:	0f 90       	pop	r0
    156a:	df 91       	pop	r29
    156c:	cf 91       	pop	r28
    156e:	08 95       	ret

00001570 <ECUAL_EEPROMRead>:

void ECUAL_EEPROMRead( uint16_t u16_MEMAddress , uint8_t *u8_DataRead)
{
    1570:	0f 93       	push	r16
    1572:	1f 93       	push	r17
    1574:	cf 93       	push	r28
    1576:	df 93       	push	r29
    1578:	00 d0       	rcall	.+0      	; 0x157a <ECUAL_EEPROMRead+0xa>
    157a:	cd b7       	in	r28, 0x3d	; 61
    157c:	de b7       	in	r29, 0x3e	; 62
    157e:	8b 01       	movw	r16, r22
	
	/* initialize EEPROM control byte */
	 uint8_t u8_ControlByte =0b01010000;  //1010 then 000 slave address then 0 for write operation  
	                                     // this byte will be shifted in i2c write will be 10100000 and for repeat start 10100001
	/* the First word address the MSB 8 bits of the address */
	uint8_t u8_FW_ADD =(uint8_t)(u16_MEMAddress>>8);
    1580:	99 83       	std	Y+1, r25	; 0x01
	/* second word address the LSB 8 bits of the address */
	uint8_t u8_SW_ADD=(uint8_t)(u16_MEMAddress);
    1582:	8a 83       	std	Y+2, r24	; 0x02
	
	
	
	/* initiate the start condition with control byte */
	MCAL_I2CMaterEstablishComm(u8_ControlByte);
    1584:	80 e5       	ldi	r24, 0x50	; 80
    1586:	0e 94 09 11 	call	0x2212	; 0x2212 <MCAL_I2CMaterEstablishComm>
	
	/*first word memory address in EEPROM */
	MCAL_I2CMasterWrightData(&u8_FW_ADD);
    158a:	ce 01       	movw	r24, r28
    158c:	01 96       	adiw	r24, 0x01	; 1
    158e:	0e 94 44 11 	call	0x2288	; 0x2288 <MCAL_I2CMasterWrightData>
	
	/*first word memory address in EEPROM */
	MCAL_I2CMasterWrightData(&u8_SW_ADD);
    1592:	ce 01       	movw	r24, r28
    1594:	02 96       	adiw	r24, 0x02	; 2
    1596:	0e 94 44 11 	call	0x2288	; 0x2288 <MCAL_I2CMasterWrightData>
	
	
	
	/* repeated start to read */
	MCAL_I2CMasterRepeatedStart(u8_ControlByte);
    159a:	80 e5       	ldi	r24, 0x50	; 80
    159c:	0e 94 26 11 	call	0x224c	; 0x224c <MCAL_I2CMasterRepeatedStart>
    15a0:	80 e0       	ldi	r24, 0x00	; 0
    15a2:	90 e0       	ldi	r25, 0x00	; 0
    15a4:	01 96       	adiw	r24, 0x01	; 1
	
	/* Small delay */
	uint32_t counter;
	for (counter=0;counter<5000;counter++);
    15a6:	88 38       	cpi	r24, 0x88	; 136
    15a8:	23 e1       	ldi	r18, 0x13	; 19
    15aa:	92 07       	cpc	r25, r18
    15ac:	d9 f7       	brne	.-10     	; 0x15a4 <ECUAL_EEPROMRead+0x34>
	
	/* Read Data */
	MCAL_I2CMasterReadsendNACK(u8_DataRead);
    15ae:	c8 01       	movw	r24, r16
    15b0:	0e 94 57 11 	call	0x22ae	; 0x22ae <MCAL_I2CMasterReadsendNACK>
	
	/* send stop condition */
	MCAL_I2CMasterStopCondition();
    15b4:	0e 94 64 11 	call	0x22c8	; 0x22c8 <MCAL_I2CMasterStopCondition>
    15b8:	0f 90       	pop	r0
    15ba:	0f 90       	pop	r0
    15bc:	df 91       	pop	r29
    15be:	cf 91       	pop	r28
    15c0:	1f 91       	pop	r17
    15c2:	0f 91       	pop	r16
    15c4:	08 95       	ret

000015c6 <keyPad_init>:
#include "keypad.h"

uint8_t keypad_row[]={R0,R1,R2,R3};
uint8_t keypad_col[]={C0,C1,C2,C3};
void keyPad_init(void)
{  
    15c6:	0f 93       	push	r16
    15c8:	1f 93       	push	r17
    15ca:	cf 93       	push	r28
    15cc:	df 93       	push	r29
	
	strDio_pins.u8_PortNum=keypadROWS_port;
    15ce:	ce e1       	ldi	r28, 0x1E	; 30
    15d0:	d8 e0       	ldi	r29, 0x08	; 8
    15d2:	11 e0       	ldi	r17, 0x01	; 1
    15d4:	18 83       	st	Y, r17
	strDio_pins.u8_PinNum=R0;
    15d6:	19 82       	std	Y+1, r1	; 0x01
	strDio_pins.u8_Direction=DIO_PIN_DIR_INPUT;
    15d8:	1a 82       	std	Y+2, r1	; 0x02
	Dio_init(&strDio_pins);
    15da:	ce 01       	movw	r24, r28
    15dc:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
	
	strDio_pins.u8_PortNum=keypadROWS_port;
    15e0:	18 83       	st	Y, r17
	strDio_pins.u8_PinNum=R1;
    15e2:	19 83       	std	Y+1, r17	; 0x01
	strDio_pins.u8_Direction=DIO_PIN_DIR_INPUT;
    15e4:	1a 82       	std	Y+2, r1	; 0x02
	Dio_init(&strDio_pins);
    15e6:	ce 01       	movw	r24, r28
    15e8:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
	
	strDio_pins.u8_PortNum=keypadROWS_port;
    15ec:	18 83       	st	Y, r17
	strDio_pins.u8_PinNum=R2;
    15ee:	82 e0       	ldi	r24, 0x02	; 2
    15f0:	89 83       	std	Y+1, r24	; 0x01
	strDio_pins.u8_Direction=DIO_PIN_DIR_INPUT;
    15f2:	1a 82       	std	Y+2, r1	; 0x02
	Dio_init(&strDio_pins);
    15f4:	ce 01       	movw	r24, r28
    15f6:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
	
	strDio_pins.u8_PortNum=keypadROWS_port;
    15fa:	18 83       	st	Y, r17
	strDio_pins.u8_PinNum=R3;
    15fc:	03 e0       	ldi	r16, 0x03	; 3
    15fe:	09 83       	std	Y+1, r16	; 0x01
	strDio_pins.u8_Direction=DIO_PIN_DIR_INPUT;
    1600:	1a 82       	std	Y+2, r1	; 0x02
	Dio_init(&strDio_pins);
    1602:	ce 01       	movw	r24, r28
    1604:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
	
	// second 4 pins are output 
	strDio_pins.u8_PortNum=keypadColumns_port;
    1608:	08 83       	st	Y, r16
	strDio_pins.u8_PinNum=C0;
    160a:	84 e0       	ldi	r24, 0x04	; 4
    160c:	89 83       	std	Y+1, r24	; 0x01
	strDio_pins.u8_Direction=DIO_PIN_DIR_OUTPUT;
    160e:	1a 83       	std	Y+2, r17	; 0x02
	Dio_init(&strDio_pins);
    1610:	ce 01       	movw	r24, r28
    1612:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
	
	strDio_pins.u8_PortNum=keypadColumns_port;
    1616:	08 83       	st	Y, r16
	strDio_pins.u8_PinNum=C1;
    1618:	85 e0       	ldi	r24, 0x05	; 5
    161a:	89 83       	std	Y+1, r24	; 0x01
	strDio_pins.u8_Direction=DIO_PIN_DIR_OUTPUT;
    161c:	1a 83       	std	Y+2, r17	; 0x02
	Dio_init(&strDio_pins);
    161e:	ce 01       	movw	r24, r28
    1620:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
	
	strDio_pins.u8_PortNum=keypadColumns_port;
    1624:	08 83       	st	Y, r16
	strDio_pins.u8_PinNum=C2;
    1626:	86 e0       	ldi	r24, 0x06	; 6
    1628:	89 83       	std	Y+1, r24	; 0x01
	strDio_pins.u8_Direction=DIO_PIN_DIR_OUTPUT;
    162a:	1a 83       	std	Y+2, r17	; 0x02
	Dio_init(&strDio_pins);
    162c:	ce 01       	movw	r24, r28
    162e:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
	
	strDio_pins.u8_PortNum=keypadColumns_port;
    1632:	08 83       	st	Y, r16
	strDio_pins.u8_PinNum=C3;
    1634:	87 e0       	ldi	r24, 0x07	; 7
    1636:	89 83       	std	Y+1, r24	; 0x01
	strDio_pins.u8_Direction=DIO_PIN_DIR_OUTPUT;
    1638:	1a 83       	std	Y+2, r17	; 0x02
	Dio_init(&strDio_pins);
    163a:	ce 01       	movw	r24, r28
    163c:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
	
	// pull up rows PINS
	Dio_writePin(keypadROWS_port,R0,PIN_HIGH);
    1640:	41 e0       	ldi	r20, 0x01	; 1
    1642:	60 e0       	ldi	r22, 0x00	; 0
    1644:	81 e0       	ldi	r24, 0x01	; 1
    1646:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
	Dio_writePin(keypadROWS_port,R1,PIN_HIGH);
    164a:	41 e0       	ldi	r20, 0x01	; 1
    164c:	61 e0       	ldi	r22, 0x01	; 1
    164e:	81 e0       	ldi	r24, 0x01	; 1
    1650:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
	Dio_writePin(keypadROWS_port,R2,PIN_HIGH);
    1654:	41 e0       	ldi	r20, 0x01	; 1
    1656:	62 e0       	ldi	r22, 0x02	; 2
    1658:	81 e0       	ldi	r24, 0x01	; 1
    165a:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
	Dio_writePin(keypadROWS_port,R3,PIN_HIGH);
    165e:	41 e0       	ldi	r20, 0x01	; 1
    1660:	63 e0       	ldi	r22, 0x03	; 3
    1662:	81 e0       	ldi	r24, 0x01	; 1
    1664:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
	//DIO_WritePort(keypad_port,0XFF);
}
    1668:	df 91       	pop	r29
    166a:	cf 91       	pop	r28
    166c:	1f 91       	pop	r17
    166e:	0f 91       	pop	r16
    1670:	08 95       	ret

00001672 <keyPad_GetKey>:
uint8_t keyPad_GetKey(void)
{
    1672:	6f 92       	push	r6
    1674:	7f 92       	push	r7
    1676:	8f 92       	push	r8
    1678:	9f 92       	push	r9
    167a:	af 92       	push	r10
    167c:	bf 92       	push	r11
    167e:	cf 92       	push	r12
    1680:	df 92       	push	r13
    1682:	ef 92       	push	r14
    1684:	ff 92       	push	r15
    1686:	0f 93       	push	r16
    1688:	1f 93       	push	r17
    168a:	cf 93       	push	r28
    168c:	df 93       	push	r29
    168e:	1f 92       	push	r1
    1690:	cd b7       	in	r28, 0x3d	; 61
    1692:	de b7       	in	r29, 0x3e	; 62
    1694:	0f 2e       	mov	r0, r31
    1696:	fc e6       	ldi	r31, 0x6C	; 108
    1698:	6f 2e       	mov	r6, r31
    169a:	f0 e0       	ldi	r31, 0x00	; 0
    169c:	7f 2e       	mov	r7, r31
    169e:	f0 2d       	mov	r31, r0
	int i,j;
	for(i=0;i<4;i++)
    16a0:	a1 2c       	mov	r10, r1
    16a2:	b1 2c       	mov	r11, r1
	{
		
		Dio_writePin(keypadColumns_port,C0,PIN_HIGH);
    16a4:	41 e0       	ldi	r20, 0x01	; 1
    16a6:	64 e0       	ldi	r22, 0x04	; 4
    16a8:	83 e0       	ldi	r24, 0x03	; 3
    16aa:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
		Dio_writePin(keypadColumns_port,C1,PIN_HIGH);
    16ae:	41 e0       	ldi	r20, 0x01	; 1
    16b0:	65 e0       	ldi	r22, 0x05	; 5
    16b2:	83 e0       	ldi	r24, 0x03	; 3
    16b4:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
		Dio_writePin(keypadColumns_port,C2,PIN_HIGH);
    16b8:	41 e0       	ldi	r20, 0x01	; 1
    16ba:	66 e0       	ldi	r22, 0x06	; 6
    16bc:	83 e0       	ldi	r24, 0x03	; 3
    16be:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
		Dio_writePin(keypadColumns_port,C3,PIN_HIGH);
    16c2:	41 e0       	ldi	r20, 0x01	; 1
    16c4:	67 e0       	ldi	r22, 0x07	; 7
    16c6:	83 e0       	ldi	r24, 0x03	; 3
    16c8:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
		
		Dio_writePin(keypadColumns_port,keypad_col[i],PIN_LOW);
    16cc:	f3 01       	movw	r30, r6
    16ce:	61 91       	ld	r22, Z+
    16d0:	3f 01       	movw	r6, r30
    16d2:	40 e0       	ldi	r20, 0x00	; 0
    16d4:	83 e0       	ldi	r24, 0x03	; 3
    16d6:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    16da:	0f 2e       	mov	r0, r31
    16dc:	f0 e7       	ldi	r31, 0x70	; 112
    16de:	ef 2e       	mov	r14, r31
    16e0:	f0 e0       	ldi	r31, 0x00	; 0
    16e2:	ff 2e       	mov	r15, r31
    16e4:	f0 2d       	mov	r31, r0
    16e6:	c1 2c       	mov	r12, r1
    16e8:	d1 2c       	mov	r13, r1
    16ea:	81 2c       	mov	r8, r1
    16ec:	91 2c       	mov	r9, r1
    16ee:	06 c0       	rjmp	.+12     	; 0x16fc <keyPad_GetKey+0x8a>
    16f0:	ff ef       	ldi	r31, 0xFF	; 255
    16f2:	8f 1a       	sub	r8, r31
    16f4:	9f 0a       	sbc	r9, r31
    16f6:	8f ef       	ldi	r24, 0xFF	; 255
    16f8:	e8 1a       	sub	r14, r24
    16fa:	f8 0a       	sbc	r15, r24
    16fc:	87 01       	movw	r16, r14
    16fe:	ef ef       	ldi	r30, 0xFF	; 255
    1700:	ce 1a       	sub	r12, r30
    1702:	de 0a       	sbc	r13, r30
		uint8_t u8_temp ;
		for(j=0;j<4;j++)
		{
			Dio_readPin(keypadROWS_port,keypad_row[j],&u8_temp);
    1704:	ae 01       	movw	r20, r28
    1706:	4f 5f       	subi	r20, 0xFF	; 255
    1708:	5f 4f       	sbci	r21, 0xFF	; 255
    170a:	f7 01       	movw	r30, r14
    170c:	60 81       	ld	r22, Z
    170e:	81 e0       	ldi	r24, 0x01	; 1
    1710:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <Dio_readPin>
			if(u8_temp ==0)
    1714:	89 81       	ldd	r24, Y+1	; 0x01
    1716:	81 11       	cpse	r24, r1
    1718:	52 c0       	rjmp	.+164    	; 0x17be <keyPad_GetKey+0x14c>
			   {
				   
				while(u8_temp==0)    //single pressed
				 {
					 Dio_readPin(keypadROWS_port,keypad_row[j],&u8_temp);
    171a:	ae 01       	movw	r20, r28
    171c:	4f 5f       	subi	r20, 0xFF	; 255
    171e:	5f 4f       	sbci	r21, 0xFF	; 255
    1720:	f8 01       	movw	r30, r16
    1722:	60 81       	ld	r22, Z
    1724:	81 e0       	ldi	r24, 0x01	; 1
    1726:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <Dio_readPin>
		{
			Dio_readPin(keypadROWS_port,keypad_row[j],&u8_temp);
			if(u8_temp ==0)
			   {
				   
				while(u8_temp==0)    //single pressed
    172a:	89 81       	ldd	r24, Y+1	; 0x01
    172c:	88 23       	and	r24, r24
    172e:	a9 f3       	breq	.-22     	; 0x171a <keyPad_GetKey+0xa8>
				 {
					 Dio_readPin(keypadROWS_port,keypad_row[j],&u8_temp);
				}                     
				switch(i)
    1730:	f1 e0       	ldi	r31, 0x01	; 1
    1732:	af 16       	cp	r10, r31
    1734:	b1 04       	cpc	r11, r1
    1736:	e1 f0       	breq	.+56     	; 0x1770 <keyPad_GetKey+0xfe>
    1738:	24 f4       	brge	.+8      	; 0x1742 <keyPad_GetKey+0xd0>
    173a:	a1 14       	cp	r10, r1
    173c:	b1 04       	cpc	r11, r1
    173e:	51 f0       	breq	.+20     	; 0x1754 <keyPad_GetKey+0xe2>
    1740:	3e c0       	rjmp	.+124    	; 0x17be <keyPad_GetKey+0x14c>
    1742:	e2 e0       	ldi	r30, 0x02	; 2
    1744:	ae 16       	cp	r10, r30
    1746:	b1 04       	cpc	r11, r1
    1748:	01 f1       	breq	.+64     	; 0x178a <keyPad_GetKey+0x118>
    174a:	f3 e0       	ldi	r31, 0x03	; 3
    174c:	af 16       	cp	r10, r31
    174e:	b1 04       	cpc	r11, r1
    1750:	49 f1       	breq	.+82     	; 0x17a4 <keyPad_GetKey+0x132>
    1752:	35 c0       	rjmp	.+106    	; 0x17be <keyPad_GetKey+0x14c>
    1754:	c4 01       	movw	r24, r8
				{
					case 0 :
						{
							if(j == 0) return '7';
    1756:	81 14       	cp	r8, r1
    1758:	91 04       	cpc	r9, r1
    175a:	09 f4       	brne	.+2      	; 0x175e <keyPad_GetKey+0xec>
    175c:	3f c0       	rjmp	.+126    	; 0x17dc <keyPad_GetKey+0x16a>
							else if(j == 1) return '4';
    175e:	81 30       	cpi	r24, 0x01	; 1
    1760:	91 05       	cpc	r25, r1
    1762:	f1 f1       	breq	.+124    	; 0x17e0 <keyPad_GetKey+0x16e>
							else if(j == 2) return '1';
    1764:	82 30       	cpi	r24, 0x02	; 2
    1766:	91 05       	cpc	r25, r1
    1768:	e9 f1       	breq	.+122    	; 0x17e4 <keyPad_GetKey+0x172>
							else if(j == 3) return '?';
    176a:	03 97       	sbiw	r24, 0x03	; 3
    176c:	41 f5       	brne	.+80     	; 0x17be <keyPad_GetKey+0x14c>
    176e:	3c c0       	rjmp	.+120    	; 0x17e8 <keyPad_GetKey+0x176>
    1770:	c4 01       	movw	r24, r8
							break;
						}
					case 1 :
					   {
						    if(j == 0) return '8';
    1772:	81 14       	cp	r8, r1
    1774:	91 04       	cpc	r9, r1
    1776:	d1 f1       	breq	.+116    	; 0x17ec <keyPad_GetKey+0x17a>
						    else if(j == 1) return '5';
    1778:	81 30       	cpi	r24, 0x01	; 1
    177a:	91 05       	cpc	r25, r1
    177c:	c9 f1       	breq	.+114    	; 0x17f0 <keyPad_GetKey+0x17e>
						    else if(j == 2) return '2';
    177e:	82 30       	cpi	r24, 0x02	; 2
    1780:	91 05       	cpc	r25, r1
    1782:	c1 f1       	breq	.+112    	; 0x17f4 <keyPad_GetKey+0x182>
						    else if(j == 3) return '0';
    1784:	03 97       	sbiw	r24, 0x03	; 3
    1786:	d9 f4       	brne	.+54     	; 0x17be <keyPad_GetKey+0x14c>
    1788:	37 c0       	rjmp	.+110    	; 0x17f8 <keyPad_GetKey+0x186>
    178a:	c4 01       	movw	r24, r8
						    break;
					    }
					case 2 :
					   {
						    if(j == 0) return '9';
    178c:	81 14       	cp	r8, r1
    178e:	91 04       	cpc	r9, r1
    1790:	a9 f1       	breq	.+106    	; 0x17fc <keyPad_GetKey+0x18a>
						    else if(j == 1) return '6';
    1792:	81 30       	cpi	r24, 0x01	; 1
    1794:	91 05       	cpc	r25, r1
    1796:	a1 f1       	breq	.+104    	; 0x1800 <keyPad_GetKey+0x18e>
						    else if(j == 2) return '3';
    1798:	82 30       	cpi	r24, 0x02	; 2
    179a:	91 05       	cpc	r25, r1
    179c:	99 f1       	breq	.+102    	; 0x1804 <keyPad_GetKey+0x192>
						    else if(j == 3) return '=';
    179e:	03 97       	sbiw	r24, 0x03	; 3
    17a0:	71 f4       	brne	.+28     	; 0x17be <keyPad_GetKey+0x14c>
    17a2:	32 c0       	rjmp	.+100    	; 0x1808 <keyPad_GetKey+0x196>
    17a4:	c4 01       	movw	r24, r8
						    break;
					   }
					case 3 :
					{
						if(j == 0) return '/';
    17a6:	81 14       	cp	r8, r1
    17a8:	91 04       	cpc	r9, r1
    17aa:	81 f1       	breq	.+96     	; 0x180c <keyPad_GetKey+0x19a>
						else if(j == 1) return '*';
    17ac:	81 30       	cpi	r24, 0x01	; 1
    17ae:	91 05       	cpc	r25, r1
    17b0:	79 f1       	breq	.+94     	; 0x1810 <keyPad_GetKey+0x19e>
						else if(j == 2) return '-';
    17b2:	82 30       	cpi	r24, 0x02	; 2
    17b4:	91 05       	cpc	r25, r1
    17b6:	71 f1       	breq	.+92     	; 0x1814 <keyPad_GetKey+0x1a2>
						else if(j == 3) return '+';
    17b8:	03 97       	sbiw	r24, 0x03	; 3
    17ba:	91 f5       	brne	.+100    	; 0x1820 <keyPad_GetKey+0x1ae>
    17bc:	2d c0       	rjmp	.+90     	; 0x1818 <keyPad_GetKey+0x1a6>
		Dio_writePin(keypadColumns_port,C2,PIN_HIGH);
		Dio_writePin(keypadColumns_port,C3,PIN_HIGH);
		
		Dio_writePin(keypadColumns_port,keypad_col[i],PIN_LOW);
		uint8_t u8_temp ;
		for(j=0;j<4;j++)
    17be:	84 e0       	ldi	r24, 0x04	; 4
    17c0:	c8 16       	cp	r12, r24
    17c2:	d1 04       	cpc	r13, r1
    17c4:	0c f4       	brge	.+2      	; 0x17c8 <keyPad_GetKey+0x156>
    17c6:	94 cf       	rjmp	.-216    	; 0x16f0 <keyPad_GetKey+0x7e>
	//DIO_WritePort(keypad_port,0XFF);
}
uint8_t keyPad_GetKey(void)
{
	int i,j;
	for(i=0;i<4;i++)
    17c8:	ef ef       	ldi	r30, 0xFF	; 255
    17ca:	ae 1a       	sub	r10, r30
    17cc:	be 0a       	sbc	r11, r30
    17ce:	f4 e0       	ldi	r31, 0x04	; 4
    17d0:	af 16       	cp	r10, r31
    17d2:	b1 04       	cpc	r11, r1
    17d4:	09 f0       	breq	.+2      	; 0x17d8 <keyPad_GetKey+0x166>
    17d6:	66 cf       	rjmp	.-308    	; 0x16a4 <keyPad_GetKey+0x32>
					
				}
			}
		}
	}
	return 'A';  // return A if no key is pressed 
    17d8:	81 e4       	ldi	r24, 0x41	; 65
    17da:	28 c0       	rjmp	.+80     	; 0x182c <keyPad_GetKey+0x1ba>
				}                     
				switch(i)
				{
					case 0 :
						{
							if(j == 0) return '7';
    17dc:	87 e3       	ldi	r24, 0x37	; 55
    17de:	26 c0       	rjmp	.+76     	; 0x182c <keyPad_GetKey+0x1ba>
							else if(j == 1) return '4';
    17e0:	84 e3       	ldi	r24, 0x34	; 52
    17e2:	24 c0       	rjmp	.+72     	; 0x182c <keyPad_GetKey+0x1ba>
							else if(j == 2) return '1';
    17e4:	81 e3       	ldi	r24, 0x31	; 49
    17e6:	22 c0       	rjmp	.+68     	; 0x182c <keyPad_GetKey+0x1ba>
							else if(j == 3) return '?';
    17e8:	8f e3       	ldi	r24, 0x3F	; 63
    17ea:	20 c0       	rjmp	.+64     	; 0x182c <keyPad_GetKey+0x1ba>
							break;
						}
					case 1 :
					   {
						    if(j == 0) return '8';
    17ec:	88 e3       	ldi	r24, 0x38	; 56
    17ee:	1e c0       	rjmp	.+60     	; 0x182c <keyPad_GetKey+0x1ba>
						    else if(j == 1) return '5';
    17f0:	85 e3       	ldi	r24, 0x35	; 53
    17f2:	1c c0       	rjmp	.+56     	; 0x182c <keyPad_GetKey+0x1ba>
						    else if(j == 2) return '2';
    17f4:	82 e3       	ldi	r24, 0x32	; 50
    17f6:	1a c0       	rjmp	.+52     	; 0x182c <keyPad_GetKey+0x1ba>
						    else if(j == 3) return '0';
    17f8:	80 e3       	ldi	r24, 0x30	; 48
    17fa:	18 c0       	rjmp	.+48     	; 0x182c <keyPad_GetKey+0x1ba>
						    break;
					    }
					case 2 :
					   {
						    if(j == 0) return '9';
    17fc:	89 e3       	ldi	r24, 0x39	; 57
    17fe:	16 c0       	rjmp	.+44     	; 0x182c <keyPad_GetKey+0x1ba>
						    else if(j == 1) return '6';
    1800:	86 e3       	ldi	r24, 0x36	; 54
    1802:	14 c0       	rjmp	.+40     	; 0x182c <keyPad_GetKey+0x1ba>
						    else if(j == 2) return '3';
    1804:	83 e3       	ldi	r24, 0x33	; 51
    1806:	12 c0       	rjmp	.+36     	; 0x182c <keyPad_GetKey+0x1ba>
						    else if(j == 3) return '=';
    1808:	8d e3       	ldi	r24, 0x3D	; 61
    180a:	10 c0       	rjmp	.+32     	; 0x182c <keyPad_GetKey+0x1ba>
						    break;
					   }
					case 3 :
					{
						if(j == 0) return '/';
    180c:	8f e2       	ldi	r24, 0x2F	; 47
    180e:	0e c0       	rjmp	.+28     	; 0x182c <keyPad_GetKey+0x1ba>
						else if(j == 1) return '*';
    1810:	8a e2       	ldi	r24, 0x2A	; 42
    1812:	0c c0       	rjmp	.+24     	; 0x182c <keyPad_GetKey+0x1ba>
						else if(j == 2) return '-';
    1814:	8d e2       	ldi	r24, 0x2D	; 45
    1816:	0a c0       	rjmp	.+20     	; 0x182c <keyPad_GetKey+0x1ba>
						else if(j == 3) return '+';
    1818:	8b e2       	ldi	r24, 0x2B	; 43
    181a:	08 c0       	rjmp	.+16     	; 0x182c <keyPad_GetKey+0x1ba>
					
				}
			}
		}
	}
	return 'A';  // return A if no key is pressed 
    181c:	81 e4       	ldi	r24, 0x41	; 65
    181e:	06 c0       	rjmp	.+12     	; 0x182c <keyPad_GetKey+0x1ba>
		Dio_writePin(keypadColumns_port,C2,PIN_HIGH);
		Dio_writePin(keypadColumns_port,C3,PIN_HIGH);
		
		Dio_writePin(keypadColumns_port,keypad_col[i],PIN_LOW);
		uint8_t u8_temp ;
		for(j=0;j<4;j++)
    1820:	84 e0       	ldi	r24, 0x04	; 4
    1822:	c8 16       	cp	r12, r24
    1824:	d1 04       	cpc	r13, r1
    1826:	0c f4       	brge	.+2      	; 0x182a <keyPad_GetKey+0x1b8>
    1828:	63 cf       	rjmp	.-314    	; 0x16f0 <keyPad_GetKey+0x7e>
    182a:	f8 cf       	rjmp	.-16     	; 0x181c <keyPad_GetKey+0x1aa>
				}
			}
		}
	}
	return 'A';  // return A if no key is pressed 
    182c:	0f 90       	pop	r0
    182e:	df 91       	pop	r29
    1830:	cf 91       	pop	r28
    1832:	1f 91       	pop	r17
    1834:	0f 91       	pop	r16
    1836:	ff 90       	pop	r15
    1838:	ef 90       	pop	r14
    183a:	df 90       	pop	r13
    183c:	cf 90       	pop	r12
    183e:	bf 90       	pop	r11
    1840:	af 90       	pop	r10
    1842:	9f 90       	pop	r9
    1844:	8f 90       	pop	r8
    1846:	7f 90       	pop	r7
    1848:	6f 90       	pop	r6
    184a:	08 95       	ret

0000184c <LCD_Kick>:
	for (u8_counter=0;u8_counter<power;u8_counter++)
	{
		u32_result =u32_result*(base);
	}
	return base;
}
    184c:	41 e0       	ldi	r20, 0x01	; 1
    184e:	63 e0       	ldi	r22, 0x03	; 3
    1850:	80 e0       	ldi	r24, 0x00	; 0
    1852:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    1856:	48 e8       	ldi	r20, 0x88	; 136
    1858:	53 e1       	ldi	r21, 0x13	; 19
    185a:	60 e0       	ldi	r22, 0x00	; 0
    185c:	70 e0       	ldi	r23, 0x00	; 0
    185e:	80 e0       	ldi	r24, 0x00	; 0
    1860:	0e 94 22 12 	call	0x2444	; 0x2444 <GptStart_Sync>
    1864:	40 e0       	ldi	r20, 0x00	; 0
    1866:	63 e0       	ldi	r22, 0x03	; 3
    1868:	80 e0       	ldi	r24, 0x00	; 0
    186a:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    186e:	08 95       	ret

00001870 <LCD_send_command>:
    1870:	cf 93       	push	r28
    1872:	c8 2f       	mov	r28, r24
    1874:	60 e0       	ldi	r22, 0x00	; 0
    1876:	80 e0       	ldi	r24, 0x00	; 0
    1878:	0e 94 ef 10 	call	0x21de	; 0x21de <DIO_WritePort>
    187c:	6c 2f       	mov	r22, r28
    187e:	60 7f       	andi	r22, 0xF0	; 240
    1880:	80 e0       	ldi	r24, 0x00	; 0
    1882:	0e 94 ef 10 	call	0x21de	; 0x21de <DIO_WritePort>
    1886:	40 e0       	ldi	r20, 0x00	; 0
    1888:	61 e0       	ldi	r22, 0x01	; 1
    188a:	80 e0       	ldi	r24, 0x00	; 0
    188c:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    1890:	40 e0       	ldi	r20, 0x00	; 0
    1892:	62 e0       	ldi	r22, 0x02	; 2
    1894:	80 e0       	ldi	r24, 0x00	; 0
    1896:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    189a:	0e 94 26 0c 	call	0x184c	; 0x184c <LCD_Kick>
    189e:	60 e0       	ldi	r22, 0x00	; 0
    18a0:	80 e0       	ldi	r24, 0x00	; 0
    18a2:	0e 94 ef 10 	call	0x21de	; 0x21de <DIO_WritePort>
    18a6:	6c 2f       	mov	r22, r28
    18a8:	62 95       	swap	r22
    18aa:	60 7f       	andi	r22, 0xF0	; 240
    18ac:	80 e0       	ldi	r24, 0x00	; 0
    18ae:	0e 94 ef 10 	call	0x21de	; 0x21de <DIO_WritePort>
    18b2:	40 e0       	ldi	r20, 0x00	; 0
    18b4:	61 e0       	ldi	r22, 0x01	; 1
    18b6:	80 e0       	ldi	r24, 0x00	; 0
    18b8:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    18bc:	40 e0       	ldi	r20, 0x00	; 0
    18be:	62 e0       	ldi	r22, 0x02	; 2
    18c0:	80 e0       	ldi	r24, 0x00	; 0
    18c2:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    18c6:	0e 94 26 0c 	call	0x184c	; 0x184c <LCD_Kick>
    18ca:	cf 91       	pop	r28
    18cc:	08 95       	ret

000018ce <LCD_init>:
    18ce:	0e 94 0b 12 	call	0x2416	; 0x2416 <GptInit>
    18d2:	61 e0       	ldi	r22, 0x01	; 1
    18d4:	80 e0       	ldi	r24, 0x00	; 0
    18d6:	0e 94 cb 10 	call	0x2196	; 0x2196 <DIO_SetPortDirection>
    18da:	ee e1       	ldi	r30, 0x1E	; 30
    18dc:	f8 e0       	ldi	r31, 0x08	; 8
    18de:	10 82       	st	Z, r1
    18e0:	11 82       	std	Z+1, r1	; 0x01
    18e2:	12 82       	std	Z+2, r1	; 0x02
    18e4:	cf 01       	movw	r24, r30
    18e6:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
    18ea:	40 e0       	ldi	r20, 0x00	; 0
    18ec:	62 e0       	ldi	r22, 0x02	; 2
    18ee:	80 e0       	ldi	r24, 0x00	; 0
    18f0:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    18f4:	40 e0       	ldi	r20, 0x00	; 0
    18f6:	63 e0       	ldi	r22, 0x03	; 3
    18f8:	80 e0       	ldi	r24, 0x00	; 0
    18fa:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    18fe:	40 e0       	ldi	r20, 0x00	; 0
    1900:	61 e0       	ldi	r22, 0x01	; 1
    1902:	80 e0       	ldi	r24, 0x00	; 0
    1904:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    1908:	40 e2       	ldi	r20, 0x20	; 32
    190a:	5e e4       	ldi	r21, 0x4E	; 78
    190c:	60 e0       	ldi	r22, 0x00	; 0
    190e:	70 e0       	ldi	r23, 0x00	; 0
    1910:	80 e0       	ldi	r24, 0x00	; 0
    1912:	0e 94 22 12 	call	0x2444	; 0x2444 <GptStart_Sync>
    1916:	83 e3       	ldi	r24, 0x33	; 51
    1918:	0e 94 38 0c 	call	0x1870	; 0x1870 <LCD_send_command>
    191c:	48 e8       	ldi	r20, 0x88	; 136
    191e:	53 e1       	ldi	r21, 0x13	; 19
    1920:	60 e0       	ldi	r22, 0x00	; 0
    1922:	70 e0       	ldi	r23, 0x00	; 0
    1924:	80 e0       	ldi	r24, 0x00	; 0
    1926:	0e 94 22 12 	call	0x2444	; 0x2444 <GptStart_Sync>
    192a:	82 e3       	ldi	r24, 0x32	; 50
    192c:	0e 94 38 0c 	call	0x1870	; 0x1870 <LCD_send_command>
    1930:	48 e8       	ldi	r20, 0x88	; 136
    1932:	53 e1       	ldi	r21, 0x13	; 19
    1934:	60 e0       	ldi	r22, 0x00	; 0
    1936:	70 e0       	ldi	r23, 0x00	; 0
    1938:	80 e0       	ldi	r24, 0x00	; 0
    193a:	0e 94 22 12 	call	0x2444	; 0x2444 <GptStart_Sync>
    193e:	88 e2       	ldi	r24, 0x28	; 40
    1940:	0e 94 38 0c 	call	0x1870	; 0x1870 <LCD_send_command>
    1944:	8c e0       	ldi	r24, 0x0C	; 12
    1946:	0e 94 38 0c 	call	0x1870	; 0x1870 <LCD_send_command>
    194a:	86 e0       	ldi	r24, 0x06	; 6
    194c:	0e 94 38 0c 	call	0x1870	; 0x1870 <LCD_send_command>
    1950:	81 e0       	ldi	r24, 0x01	; 1
    1952:	0e 94 38 0c 	call	0x1870	; 0x1870 <LCD_send_command>
    1956:	08 95       	ret

00001958 <LCD_GoTo_xy>:
    1958:	81 11       	cpse	r24, r1
    195a:	05 c0       	rjmp	.+10     	; 0x1966 <LCD_GoTo_xy+0xe>
    195c:	80 e8       	ldi	r24, 0x80	; 128
    195e:	86 0f       	add	r24, r22
    1960:	0e 94 38 0c 	call	0x1870	; 0x1870 <LCD_send_command>
    1964:	08 95       	ret
    1966:	81 30       	cpi	r24, 0x01	; 1
    1968:	21 f4       	brne	.+8      	; 0x1972 <LCD_GoTo_xy+0x1a>
    196a:	80 ec       	ldi	r24, 0xC0	; 192
    196c:	86 0f       	add	r24, r22
    196e:	0e 94 38 0c 	call	0x1870	; 0x1870 <LCD_send_command>
    1972:	08 95       	ret

00001974 <LCD_display_charcter>:
    1974:	cf 93       	push	r28
    1976:	c8 2f       	mov	r28, r24
    1978:	68 2f       	mov	r22, r24
    197a:	60 7f       	andi	r22, 0xF0	; 240
    197c:	80 e0       	ldi	r24, 0x00	; 0
    197e:	0e 94 ef 10 	call	0x21de	; 0x21de <DIO_WritePort>
    1982:	41 e0       	ldi	r20, 0x01	; 1
    1984:	61 e0       	ldi	r22, 0x01	; 1
    1986:	80 e0       	ldi	r24, 0x00	; 0
    1988:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    198c:	40 e0       	ldi	r20, 0x00	; 0
    198e:	62 e0       	ldi	r22, 0x02	; 2
    1990:	80 e0       	ldi	r24, 0x00	; 0
    1992:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    1996:	0e 94 26 0c 	call	0x184c	; 0x184c <LCD_Kick>
    199a:	6c 2f       	mov	r22, r28
    199c:	62 95       	swap	r22
    199e:	60 7f       	andi	r22, 0xF0	; 240
    19a0:	80 e0       	ldi	r24, 0x00	; 0
    19a2:	0e 94 ef 10 	call	0x21de	; 0x21de <DIO_WritePort>
    19a6:	41 e0       	ldi	r20, 0x01	; 1
    19a8:	61 e0       	ldi	r22, 0x01	; 1
    19aa:	80 e0       	ldi	r24, 0x00	; 0
    19ac:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    19b0:	40 e0       	ldi	r20, 0x00	; 0
    19b2:	62 e0       	ldi	r22, 0x02	; 2
    19b4:	80 e0       	ldi	r24, 0x00	; 0
    19b6:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    19ba:	0e 94 26 0c 	call	0x184c	; 0x184c <LCD_Kick>
    19be:	cf 91       	pop	r28
    19c0:	08 95       	ret

000019c2 <IntegerTostring>:
void IntegerTostring(uint32_t u32_number, uint8_t *str)
{
    19c2:	4f 92       	push	r4
    19c4:	5f 92       	push	r5
    19c6:	6f 92       	push	r6
    19c8:	7f 92       	push	r7
    19ca:	af 92       	push	r10
    19cc:	bf 92       	push	r11
    19ce:	cf 92       	push	r12
    19d0:	df 92       	push	r13
    19d2:	ef 92       	push	r14
    19d4:	ff 92       	push	r15
    19d6:	0f 93       	push	r16
    19d8:	1f 93       	push	r17
    19da:	cf 93       	push	r28
    19dc:	6b 01       	movw	r12, r22
    19de:	7c 01       	movw	r14, r24
    19e0:	5a 01       	movw	r10, r20
	uint32_t u32_temp;
	uint8_t u8_counter=0;
	u32_temp =u32_number;
	if (u32_number==0)
    19e2:	61 15       	cp	r22, r1
    19e4:	71 05       	cpc	r23, r1
    19e6:	81 05       	cpc	r24, r1
    19e8:	91 05       	cpc	r25, r1
    19ea:	29 f4       	brne	.+10     	; 0x19f6 <IntegerTostring+0x34>
	{
		str[1]='\0';
    19ec:	fa 01       	movw	r30, r20
    19ee:	11 82       	std	Z+1, r1	; 0x01
		str[0]=48;
    19f0:	80 e3       	ldi	r24, 0x30	; 48
    19f2:	80 83       	st	Z, r24
    19f4:	3c c0       	rjmp	.+120    	; 0x1a6e <IntegerTostring+0xac>
    19f6:	9b 01       	movw	r18, r22
    19f8:	ac 01       	movw	r20, r24
    19fa:	c0 e0       	ldi	r28, 0x00	; 0
	{
		
	
	while(u32_temp !=0)
	{
		u32_temp = u32_temp /10;
    19fc:	0f 2e       	mov	r0, r31
    19fe:	fa e0       	ldi	r31, 0x0A	; 10
    1a00:	4f 2e       	mov	r4, r31
    1a02:	51 2c       	mov	r5, r1
    1a04:	61 2c       	mov	r6, r1
    1a06:	71 2c       	mov	r7, r1
    1a08:	f0 2d       	mov	r31, r0
    1a0a:	ca 01       	movw	r24, r20
    1a0c:	b9 01       	movw	r22, r18
    1a0e:	a3 01       	movw	r20, r6
    1a10:	92 01       	movw	r18, r4
    1a12:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <__udivmodsi4>
		u8_counter++;
    1a16:	cf 5f       	subi	r28, 0xFF	; 255
	}
	else
	{
		
	
	while(u32_temp !=0)
    1a18:	21 15       	cp	r18, r1
    1a1a:	31 05       	cpc	r19, r1
    1a1c:	41 05       	cpc	r20, r1
    1a1e:	51 05       	cpc	r21, r1
    1a20:	a1 f7       	brne	.-24     	; 0x1a0a <IntegerTostring+0x48>
    1a22:	19 c0       	rjmp	.+50     	; 0x1a56 <IntegerTostring+0x94>
	}
	u32_temp =u32_number;
	str[u8_counter]='\0';
	while(u32_temp !=0)
	{
		str[u8_counter-1]=(u32_temp %10)+48 ;
    1a24:	85 01       	movw	r16, r10
    1a26:	0c 0f       	add	r16, r28
    1a28:	11 1d       	adc	r17, r1
    1a2a:	01 50       	subi	r16, 0x01	; 1
    1a2c:	11 09       	sbc	r17, r1
    1a2e:	c7 01       	movw	r24, r14
    1a30:	b6 01       	movw	r22, r12
    1a32:	a3 01       	movw	r20, r6
    1a34:	92 01       	movw	r18, r4
    1a36:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <__udivmodsi4>
    1a3a:	60 5d       	subi	r22, 0xD0	; 208
    1a3c:	f8 01       	movw	r30, r16
    1a3e:	60 83       	st	Z, r22
		u32_temp =u32_temp /10;
    1a40:	c2 2e       	mov	r12, r18
    1a42:	d3 2e       	mov	r13, r19
    1a44:	e4 2e       	mov	r14, r20
    1a46:	f5 2e       	mov	r15, r21
		u8_counter--;
    1a48:	c1 50       	subi	r28, 0x01	; 1
		u32_temp = u32_temp /10;
		u8_counter++;
	}
	u32_temp =u32_number;
	str[u8_counter]='\0';
	while(u32_temp !=0)
    1a4a:	c1 14       	cp	r12, r1
    1a4c:	d1 04       	cpc	r13, r1
    1a4e:	e1 04       	cpc	r14, r1
    1a50:	f1 04       	cpc	r15, r1
    1a52:	41 f7       	brne	.-48     	; 0x1a24 <IntegerTostring+0x62>
    1a54:	0c c0       	rjmp	.+24     	; 0x1a6e <IntegerTostring+0xac>
	{
		u32_temp = u32_temp /10;
		u8_counter++;
	}
	u32_temp =u32_number;
	str[u8_counter]='\0';
    1a56:	f5 01       	movw	r30, r10
    1a58:	ec 0f       	add	r30, r28
    1a5a:	f1 1d       	adc	r31, r1
    1a5c:	10 82       	st	Z, r1
	while(u32_temp !=0)
	{
		str[u8_counter-1]=(u32_temp %10)+48 ;
    1a5e:	0f 2e       	mov	r0, r31
    1a60:	fa e0       	ldi	r31, 0x0A	; 10
    1a62:	4f 2e       	mov	r4, r31
    1a64:	51 2c       	mov	r5, r1
    1a66:	61 2c       	mov	r6, r1
    1a68:	71 2c       	mov	r7, r1
    1a6a:	f0 2d       	mov	r31, r0
    1a6c:	db cf       	rjmp	.-74     	; 0x1a24 <IntegerTostring+0x62>
		u8_counter--;
	}
	
	}
	
}
    1a6e:	cf 91       	pop	r28
    1a70:	1f 91       	pop	r17
    1a72:	0f 91       	pop	r16
    1a74:	ff 90       	pop	r15
    1a76:	ef 90       	pop	r14
    1a78:	df 90       	pop	r13
    1a7a:	cf 90       	pop	r12
    1a7c:	bf 90       	pop	r11
    1a7e:	af 90       	pop	r10
    1a80:	7f 90       	pop	r7
    1a82:	6f 90       	pop	r6
    1a84:	5f 90       	pop	r5
    1a86:	4f 90       	pop	r4
    1a88:	08 95       	ret

00001a8a <LCD_clear_screen>:
	LCD_display_String(arr);
	 
}
void LCD_clear_screen(void)
{
	LCD_send_command(LCD_CLR_DIS_AND_DDRAM);
    1a8a:	81 e0       	ldi	r24, 0x01	; 1
    1a8c:	0e 94 38 0c 	call	0x1870	; 0x1870 <LCD_send_command>
    1a90:	08 95       	ret

00001a92 <LCD_display_String>:
	LCD_Kick();
	

}
void LCD_display_String(uint8_t *string)
{
    1a92:	0f 93       	push	r16
    1a94:	1f 93       	push	r17
    1a96:	cf 93       	push	r28
    1a98:	8c 01       	movw	r16, r24
	
	uint8_t count=0;
    1a9a:	c0 e0       	ldi	r28, 0x00	; 0
	while(*string > 0)
    1a9c:	11 c0       	rjmp	.+34     	; 0x1ac0 <LCD_display_String+0x2e>
	{    
		count++;
    1a9e:	cf 5f       	subi	r28, 0xFF	; 255
		 LCD_display_charcter(*string++);
    1aa0:	0e 94 ba 0c 	call	0x1974	; 0x1974 <LCD_display_charcter>
		if (count ==16)  // first row completed
    1aa4:	c0 31       	cpi	r28, 0x10	; 16
    1aa6:	21 f4       	brne	.+8      	; 0x1ab0 <LCD_display_String+0x1e>
	{
		LCD_send_command((LCD_cursor_line1+u8_col));
	}
	else if (u8_row==1)
	{
		LCD_send_command(LCD_cursor_line2+u8_col);
    1aa8:	80 ec       	ldi	r24, 0xC0	; 192
    1aaa:	0e 94 38 0c 	call	0x1870	; 0x1870 <LCD_send_command>
    1aae:	08 c0       	rjmp	.+16     	; 0x1ac0 <LCD_display_String+0x2e>
		if (count ==16)  // first row completed
		{
			LCD_GoTo_xy(1,0);   // row 1 position 0
			
		}
		if (count ==32)       // LCD filled and will be cleared and start again
    1ab0:	c0 32       	cpi	r28, 0x20	; 32
    1ab2:	31 f4       	brne	.+12     	; 0x1ac0 <LCD_display_String+0x2e>
		{   LCD_clear_screen();
    1ab4:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <LCD_clear_screen>
}
void LCD_GoTo_xy(uint8_t u8_row, uint8_t u8_col)
{
	if (u8_row==0)
	{
		LCD_send_command((LCD_cursor_line1+u8_col));
    1ab8:	80 e8       	ldi	r24, 0x80	; 128
    1aba:	0e 94 38 0c 	call	0x1870	; 0x1870 <LCD_send_command>
			
		}
		if (count ==32)       // LCD filled and will be cleared and start again
		{   LCD_clear_screen();
			LCD_GoTo_xy(0,0);   // row 0 position 0
			count=0;
    1abe:	c0 e0       	ldi	r28, 0x00	; 0
}
void LCD_display_String(uint8_t *string)
{
	
	uint8_t count=0;
	while(*string > 0)
    1ac0:	f8 01       	movw	r30, r16
    1ac2:	81 91       	ld	r24, Z+
    1ac4:	8f 01       	movw	r16, r30
    1ac6:	81 11       	cpse	r24, r1
    1ac8:	ea cf       	rjmp	.-44     	; 0x1a9e <LCD_display_String+0xc>
		{   LCD_clear_screen();
			LCD_GoTo_xy(0,0);   // row 0 position 0
			count=0;
		}
	}
}
    1aca:	cf 91       	pop	r28
    1acc:	1f 91       	pop	r17
    1ace:	0f 91       	pop	r16
    1ad0:	08 95       	ret

00001ad2 <LCD_DisplayInteger>:
	
	}
	
}
void LCD_DisplayInteger(uint32_t u32_number)
{   
    1ad2:	cf 93       	push	r28
    1ad4:	df 93       	push	r29
    1ad6:	cd b7       	in	r28, 0x3d	; 61
    1ad8:	de b7       	in	r29, 0x3e	; 62
    1ada:	2a 97       	sbiw	r28, 0x0a	; 10
    1adc:	0f b6       	in	r0, 0x3f	; 63
    1ade:	f8 94       	cli
    1ae0:	de bf       	out	0x3e, r29	; 62
    1ae2:	0f be       	out	0x3f, r0	; 63
    1ae4:	cd bf       	out	0x3d, r28	; 61
	uint8_t arr[10];
	IntegerTostring(u32_number,arr);
    1ae6:	ae 01       	movw	r20, r28
    1ae8:	4f 5f       	subi	r20, 0xFF	; 255
    1aea:	5f 4f       	sbci	r21, 0xFF	; 255
    1aec:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <IntegerTostring>
	LCD_display_String(arr);
    1af0:	ce 01       	movw	r24, r28
    1af2:	01 96       	adiw	r24, 0x01	; 1
    1af4:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_display_String>
	 
}
    1af8:	2a 96       	adiw	r28, 0x0a	; 10
    1afa:	0f b6       	in	r0, 0x3f	; 63
    1afc:	f8 94       	cli
    1afe:	de bf       	out	0x3e, r29	; 62
    1b00:	0f be       	out	0x3f, r0	; 63
    1b02:	cd bf       	out	0x3d, r28	; 61
    1b04:	df 91       	pop	r29
    1b06:	cf 91       	pop	r28
    1b08:	08 95       	ret

00001b0a <Motor_Delay_ms>:
#include "Motors.h"
#include "..\..\MCAL\TIMER\timer.h"
#include "..\..\MCAL\TIMER\timer_Cfg.h"

void Motor_Delay_ms(uint32_t u32_Timemsec)
{
    1b0a:	8f 92       	push	r8
    1b0c:	9f 92       	push	r9
    1b0e:	af 92       	push	r10
    1b10:	bf 92       	push	r11
    1b12:	cf 92       	push	r12
    1b14:	df 92       	push	r13
    1b16:	ef 92       	push	r14
    1b18:	ff 92       	push	r15
	uint32_t u32_counter =0;
	for (u32_counter=0;u32_counter<u32_Timemsec;u32_counter++)
    1b1a:	61 15       	cp	r22, r1
    1b1c:	71 05       	cpc	r23, r1
    1b1e:	81 05       	cpc	r24, r1
    1b20:	91 05       	cpc	r25, r1
    1b22:	b1 f0       	breq	.+44     	; 0x1b50 <Motor_Delay_ms+0x46>
    1b24:	4b 01       	movw	r8, r22
    1b26:	5c 01       	movw	r10, r24
    1b28:	c1 2c       	mov	r12, r1
    1b2a:	d1 2c       	mov	r13, r1
    1b2c:	76 01       	movw	r14, r12
	{
		/* this function takes timer id and number of ticks so if fck 1mega */
		/* the timer time base will be  1micro so we pass 1000 micro to represent 1 msec*/
		GptStart_Sync(0,1000);
    1b2e:	48 ee       	ldi	r20, 0xE8	; 232
    1b30:	53 e0       	ldi	r21, 0x03	; 3
    1b32:	60 e0       	ldi	r22, 0x00	; 0
    1b34:	70 e0       	ldi	r23, 0x00	; 0
    1b36:	80 e0       	ldi	r24, 0x00	; 0
    1b38:	0e 94 22 12 	call	0x2444	; 0x2444 <GptStart_Sync>
#include "..\..\MCAL\TIMER\timer_Cfg.h"

void Motor_Delay_ms(uint32_t u32_Timemsec)
{
	uint32_t u32_counter =0;
	for (u32_counter=0;u32_counter<u32_Timemsec;u32_counter++)
    1b3c:	8f ef       	ldi	r24, 0xFF	; 255
    1b3e:	c8 1a       	sub	r12, r24
    1b40:	d8 0a       	sbc	r13, r24
    1b42:	e8 0a       	sbc	r14, r24
    1b44:	f8 0a       	sbc	r15, r24
    1b46:	8c 14       	cp	r8, r12
    1b48:	9d 04       	cpc	r9, r13
    1b4a:	ae 04       	cpc	r10, r14
    1b4c:	bf 04       	cpc	r11, r15
    1b4e:	79 f7       	brne	.-34     	; 0x1b2e <Motor_Delay_ms+0x24>
	{
		/* this function takes timer id and number of ticks so if fck 1mega */
		/* the timer time base will be  1micro so we pass 1000 micro to represent 1 msec*/
		GptStart_Sync(0,1000);
	}
}
    1b50:	ff 90       	pop	r15
    1b52:	ef 90       	pop	r14
    1b54:	df 90       	pop	r13
    1b56:	cf 90       	pop	r12
    1b58:	bf 90       	pop	r11
    1b5a:	af 90       	pop	r10
    1b5c:	9f 90       	pop	r9
    1b5e:	8f 90       	pop	r8
    1b60:	08 95       	ret

00001b62 <MOTOR_Init>:
MOTOR_Init(void)
{
    1b62:	0f 93       	push	r16
    1b64:	1f 93       	push	r17
    1b66:	cf 93       	push	r28
    1b68:	df 93       	push	r29
	/* timer init */
	GptInit();
    1b6a:	0e 94 0b 12 	call	0x2416	; 0x2416 <GptInit>
	strDio_pins.u8_PortNum =M1PORT;
    1b6e:	ce e1       	ldi	r28, 0x1E	; 30
    1b70:	d8 e0       	ldi	r29, 0x08	; 8
    1b72:	02 e0       	ldi	r16, 0x02	; 2
    1b74:	08 83       	st	Y, r16
	strDio_pins.u8_PinNum =M1PIN1;
    1b76:	86 e0       	ldi	r24, 0x06	; 6
    1b78:	89 83       	std	Y+1, r24	; 0x01
	strDio_pins.u8_Direction= DIO_PIN_DIR_OUTPUT;
    1b7a:	11 e0       	ldi	r17, 0x01	; 1
    1b7c:	1a 83       	std	Y+2, r17	; 0x02
	strDio_pins.u8_InitState=PIN_LOW;
    1b7e:	1b 82       	std	Y+3, r1	; 0x03
	Dio_init(&strDio_pins);
    1b80:	ce 01       	movw	r24, r28
    1b82:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
	
	strDio_pins.u8_PortNum =M1PORT;
    1b86:	08 83       	st	Y, r16
	strDio_pins.u8_PinNum =M1PIN2;
    1b88:	87 e0       	ldi	r24, 0x07	; 7
    1b8a:	89 83       	std	Y+1, r24	; 0x01
	strDio_pins.u8_Direction= DIO_PIN_DIR_OUTPUT;
    1b8c:	1a 83       	std	Y+2, r17	; 0x02
	strDio_pins.u8_InitState=PIN_LOW;
    1b8e:	1b 82       	std	Y+3, r1	; 0x03
	Dio_init(&strDio_pins);
    1b90:	ce 01       	movw	r24, r28
    1b92:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
	
	strDio_pins.u8_PortNum =M2PORT;
    1b96:	08 83       	st	Y, r16
	strDio_pins.u8_PinNum =M2PIN;
    1b98:	85 e0       	ldi	r24, 0x05	; 5
    1b9a:	89 83       	std	Y+1, r24	; 0x01
	strDio_pins.u8_Direction= DIO_PIN_DIR_OUTPUT;
    1b9c:	1a 83       	std	Y+2, r17	; 0x02
	strDio_pins.u8_InitState=PIN_LOW;
    1b9e:	1b 82       	std	Y+3, r1	; 0x03
	Dio_init(&strDio_pins);
    1ba0:	ce 01       	movw	r24, r28
    1ba2:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
}
    1ba6:	df 91       	pop	r29
    1ba8:	cf 91       	pop	r28
    1baa:	1f 91       	pop	r17
    1bac:	0f 91       	pop	r16
    1bae:	08 95       	ret

00001bb0 <CardMotorRight>:

void CardMotorRight(void)
{
	Dio_writePin(M1PORT,M1PIN1,PIN_HIGH);
    1bb0:	41 e0       	ldi	r20, 0x01	; 1
    1bb2:	66 e0       	ldi	r22, 0x06	; 6
    1bb4:	82 e0       	ldi	r24, 0x02	; 2
    1bb6:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
	Dio_writePin(M1PORT,M1PIN2,PIN_LOW);
    1bba:	40 e0       	ldi	r20, 0x00	; 0
    1bbc:	67 e0       	ldi	r22, 0x07	; 7
    1bbe:	82 e0       	ldi	r24, 0x02	; 2
    1bc0:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
	Motor_Delay_ms(2000);
    1bc4:	60 ed       	ldi	r22, 0xD0	; 208
    1bc6:	77 e0       	ldi	r23, 0x07	; 7
    1bc8:	80 e0       	ldi	r24, 0x00	; 0
    1bca:	90 e0       	ldi	r25, 0x00	; 0
    1bcc:	0e 94 85 0d 	call	0x1b0a	; 0x1b0a <Motor_Delay_ms>
	Dio_writePin(M1PORT,M1PIN1,PIN_LOW);
    1bd0:	40 e0       	ldi	r20, 0x00	; 0
    1bd2:	66 e0       	ldi	r22, 0x06	; 6
    1bd4:	82 e0       	ldi	r24, 0x02	; 2
    1bd6:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
	Dio_writePin(M1PORT,M1PIN2,PIN_LOW);
    1bda:	40 e0       	ldi	r20, 0x00	; 0
    1bdc:	67 e0       	ldi	r22, 0x07	; 7
    1bde:	82 e0       	ldi	r24, 0x02	; 2
    1be0:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    1be4:	08 95       	ret

00001be6 <CardMotorLeft>:
}
void CardMotorLeft(void)
{
	Dio_writePin(M1PORT,M1PIN1,PIN_LOW);
    1be6:	40 e0       	ldi	r20, 0x00	; 0
    1be8:	66 e0       	ldi	r22, 0x06	; 6
    1bea:	82 e0       	ldi	r24, 0x02	; 2
    1bec:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
	Dio_writePin(M1PORT,M1PIN2,PIN_HIGH);
    1bf0:	41 e0       	ldi	r20, 0x01	; 1
    1bf2:	67 e0       	ldi	r22, 0x07	; 7
    1bf4:	82 e0       	ldi	r24, 0x02	; 2
    1bf6:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
	Motor_Delay_ms(2000);
    1bfa:	60 ed       	ldi	r22, 0xD0	; 208
    1bfc:	77 e0       	ldi	r23, 0x07	; 7
    1bfe:	80 e0       	ldi	r24, 0x00	; 0
    1c00:	90 e0       	ldi	r25, 0x00	; 0
    1c02:	0e 94 85 0d 	call	0x1b0a	; 0x1b0a <Motor_Delay_ms>
	Dio_writePin(M1PORT,M1PIN1,PIN_LOW);
    1c06:	40 e0       	ldi	r20, 0x00	; 0
    1c08:	66 e0       	ldi	r22, 0x06	; 6
    1c0a:	82 e0       	ldi	r24, 0x02	; 2
    1c0c:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
	Dio_writePin(M1PORT,M1PIN2,PIN_LOW);
    1c10:	40 e0       	ldi	r20, 0x00	; 0
    1c12:	67 e0       	ldi	r22, 0x07	; 7
    1c14:	82 e0       	ldi	r24, 0x02	; 2
    1c16:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    1c1a:	08 95       	ret

00001c1c <MoneyMotorON>:
}
void MoneyMotorON(void)
{
	Dio_writePin(M2PORT,M2PIN,PIN_HIGH);
    1c1c:	41 e0       	ldi	r20, 0x01	; 1
    1c1e:	65 e0       	ldi	r22, 0x05	; 5
    1c20:	82 e0       	ldi	r24, 0x02	; 2
    1c22:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
	Motor_Delay_ms(2000);
    1c26:	60 ed       	ldi	r22, 0xD0	; 208
    1c28:	77 e0       	ldi	r23, 0x07	; 7
    1c2a:	80 e0       	ldi	r24, 0x00	; 0
    1c2c:	90 e0       	ldi	r25, 0x00	; 0
    1c2e:	0e 94 85 0d 	call	0x1b0a	; 0x1b0a <Motor_Delay_ms>
	Dio_writePin(M2PORT,M2PIN,PIN_LOW);
    1c32:	40 e0       	ldi	r20, 0x00	; 0
    1c34:	65 e0       	ldi	r22, 0x05	; 5
    1c36:	82 e0       	ldi	r24, 0x02	; 2
    1c38:	0e 94 52 10 	call	0x20a4	; 0x20a4 <Dio_writePin>
    1c3c:	08 95       	ret

00001c3e <TempSensorInit>:
 /* will affect temp calculations */
 
uint8_t gu8_Vref;
/******************************************************/
void TempSensorInit(uint8_t u8_channelID, uint8_t u8_Vref)
{
    1c3e:	cf 93       	push	r28
    1c40:	df 93       	push	r29
    1c42:	c8 2f       	mov	r28, r24
    1c44:	d6 2f       	mov	r29, r22
	/* initialize the ADC */
	ADC_CONFIG_STRUCT.Channels =u8_channelID;
    1c46:	e3 e2       	ldi	r30, 0x23	; 35
    1c48:	f8 e0       	ldi	r31, 0x08	; 8
    1c4a:	48 2f       	mov	r20, r24
    1c4c:	82 83       	std	Z+2, r24	; 0x02
	ADC_CONFIG_STRUCT.Clock_selector=clk_128;
    1c4e:	87 e0       	ldi	r24, 0x07	; 7
    1c50:	68 2f       	mov	r22, r24
    1c52:	84 83       	std	Z+4, r24	; 0x04
	ADC_CONFIG_STRUCT.Vref_selector=AVCC_with_extCapacitor;
    1c54:	81 e0       	ldi	r24, 0x01	; 1
    1c56:	38 2f       	mov	r19, r24
    1c58:	81 83       	std	Z+1, r24	; 0x01
	ADC_init(ADC_CONFIG_STRUCT);
    1c5a:	20 91 23 08 	lds	r18, 0x0823	; 0x800823 <ADC_CONFIG_STRUCT>
    1c5e:	50 91 26 08 	lds	r21, 0x0826	; 0x800826 <ADC_CONFIG_STRUCT+0x3>
    1c62:	70 91 28 08 	lds	r23, 0x0828	; 0x800828 <ADC_CONFIG_STRUCT+0x5>
    1c66:	80 91 29 08 	lds	r24, 0x0829	; 0x800829 <ADC_CONFIG_STRUCT+0x6>
    1c6a:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <ADC_init>
	
	gu8_Vref = u8_Vref;
    1c6e:	d0 93 22 08 	sts	0x0822, r29	; 0x800822 <gu8_Vref>
	
	if (u8_channelID==0)
    1c72:	c1 11       	cpse	r28, r1
    1c74:	08 c0       	rjmp	.+16     	; 0x1c86 <TempSensorInit+0x48>
	{
		strDio_pins.u8_PortNum =PORT_A;
    1c76:	ee e1       	ldi	r30, 0x1E	; 30
    1c78:	f8 e0       	ldi	r31, 0x08	; 8
    1c7a:	10 82       	st	Z, r1
		strDio_pins.u8_PinNum =PIN_0;
    1c7c:	11 82       	std	Z+1, r1	; 0x01
		strDio_pins.u8_Direction=DIO_PIN_DIR_INPUT;
    1c7e:	12 82       	std	Z+2, r1	; 0x02
		Dio_init(&strDio_pins);
    1c80:	cf 01       	movw	r24, r30
    1c82:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
	}
	
}
    1c86:	df 91       	pop	r29
    1c88:	cf 91       	pop	r28
    1c8a:	08 95       	ret

00001c8c <TempSensorGetTemp>:
void TempSensorGetTemp(uint8_t *pu8_TEMP)
{
    1c8c:	cf 92       	push	r12
    1c8e:	df 92       	push	r13
    1c90:	ef 92       	push	r14
    1c92:	ff 92       	push	r15
    1c94:	0f 93       	push	r16
    1c96:	1f 93       	push	r17
    1c98:	cf 93       	push	r28
    1c9a:	df 93       	push	r29
    1c9c:	00 d0       	rcall	.+0      	; 0x1c9e <TempSensorGetTemp+0x12>
    1c9e:	cd b7       	in	r28, 0x3d	; 61
    1ca0:	de b7       	in	r29, 0x3e	; 62
    1ca2:	8c 01       	movw	r16, r24
	strDio_pins.u8_PortNum =PORT_A;
    1ca4:	ee e1       	ldi	r30, 0x1E	; 30
    1ca6:	f8 e0       	ldi	r31, 0x08	; 8
    1ca8:	10 82       	st	Z, r1
	strDio_pins.u8_PinNum =PIN_0;
    1caa:	11 82       	std	Z+1, r1	; 0x01
	strDio_pins.u8_Direction=DIO_PIN_DIR_INPUT;
    1cac:	12 82       	std	Z+2, r1	; 0x02
	Dio_init(&strDio_pins);
    1cae:	cf 01       	movw	r24, r30
    1cb0:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <Dio_init>
	
	uint16_t u16_Sample;
	ADC_GetSingleSample(&u16_Sample);
    1cb4:	ce 01       	movw	r24, r28
    1cb6:	01 96       	adiw	r24, 0x01	; 1
    1cb8:	0e 94 ec 0e 	call	0x1dd8	; 0x1dd8 <ADC_GetSingleSample>
	
	/* temp equation according to LM35 sensor */
	
	*pu8_TEMP =(u16_Sample /((.01*RESOLUTION_LEVELS)/gu8_Vref));
    1cbc:	69 81       	ldd	r22, Y+1	; 0x01
    1cbe:	7a 81       	ldd	r23, Y+2	; 0x02
    1cc0:	80 e0       	ldi	r24, 0x00	; 0
    1cc2:	90 e0       	ldi	r25, 0x00	; 0
    1cc4:	0e 94 78 14 	call	0x28f0	; 0x28f0 <__floatunsisf>
    1cc8:	6b 01       	movw	r12, r22
    1cca:	7c 01       	movw	r14, r24
    1ccc:	60 91 22 08 	lds	r22, 0x0822	; 0x800822 <gu8_Vref>
    1cd0:	70 e0       	ldi	r23, 0x00	; 0
    1cd2:	80 e0       	ldi	r24, 0x00	; 0
    1cd4:	90 e0       	ldi	r25, 0x00	; 0
    1cd6:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <__floatsisf>
    1cda:	9b 01       	movw	r18, r22
    1cdc:	ac 01       	movw	r20, r24
    1cde:	6a e0       	ldi	r22, 0x0A	; 10
    1ce0:	77 ed       	ldi	r23, 0xD7	; 215
    1ce2:	83 e2       	ldi	r24, 0x23	; 35
    1ce4:	91 e4       	ldi	r25, 0x41	; 65
    1ce6:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <__divsf3>
    1cea:	9b 01       	movw	r18, r22
    1cec:	ac 01       	movw	r20, r24
    1cee:	c7 01       	movw	r24, r14
    1cf0:	b6 01       	movw	r22, r12
    1cf2:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <__divsf3>
    1cf6:	0e 94 49 14 	call	0x2892	; 0x2892 <__fixunssfsi>
    1cfa:	f8 01       	movw	r30, r16
    1cfc:	60 83       	st	Z, r22
    1cfe:	0f 90       	pop	r0
    1d00:	0f 90       	pop	r0
    1d02:	df 91       	pop	r29
    1d04:	cf 91       	pop	r28
    1d06:	1f 91       	pop	r17
    1d08:	0f 91       	pop	r16
    1d0a:	ff 90       	pop	r15
    1d0c:	ef 90       	pop	r14
    1d0e:	df 90       	pop	r13
    1d10:	cf 90       	pop	r12
    1d12:	08 95       	ret

00001d14 <main>:

			  

int main(void)
{
	APP_Init();
    1d14:	0e 94 1a 0a 	call	0x1434	; 0x1434 <APP_Init>
	
    while (1) 
    {
		APP_GetState();
    1d18:	0e 94 48 0a 	call	0x1490	; 0x1490 <APP_GetState>
		APP_UpdateState();
    1d1c:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <APP_UpdateState>
    1d20:	fb cf       	rjmp	.-10     	; 0x1d18 <main+0x4>

00001d22 <ADC_init>:
	ADCSRA |=(1<<ADCSRA_ADEN);
}
void ADC_disable(void)
{
	//clr_bit(ADCSRA,ADCSRA_ADEN);
	ADCSRA &=~(1<<ADCSRA_ADEN);
    1d22:	cf 93       	push	r28
    1d24:	df 93       	push	r29
    1d26:	cd b7       	in	r28, 0x3d	; 61
    1d28:	de b7       	in	r29, 0x3e	; 62
    1d2a:	27 97       	sbiw	r28, 0x07	; 7
    1d2c:	0f b6       	in	r0, 0x3f	; 63
    1d2e:	f8 94       	cli
    1d30:	de bf       	out	0x3e, r29	; 62
    1d32:	0f be       	out	0x3f, r0	; 63
    1d34:	cd bf       	out	0x3d, r28	; 61
    1d36:	29 83       	std	Y+1, r18	; 0x01
    1d38:	3a 83       	std	Y+2, r19	; 0x02
    1d3a:	4b 83       	std	Y+3, r20	; 0x03
    1d3c:	5c 83       	std	Y+4, r21	; 0x04
    1d3e:	6d 83       	std	Y+5, r22	; 0x05
    1d40:	7e 83       	std	Y+6, r23	; 0x06
    1d42:	8f 83       	std	Y+7, r24	; 0x07
    1d44:	86 b1       	in	r24, 0x06	; 6
    1d46:	88 7f       	andi	r24, 0xF8	; 248
    1d48:	86 b9       	out	0x06, r24	; 6
    1d4a:	96 b1       	in	r25, 0x06	; 6
    1d4c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d4e:	89 2b       	or	r24, r25
    1d50:	86 b9       	out	0x06, r24	; 6
    1d52:	35 98       	cbi	0x06, 5	; 6
    1d54:	26 b1       	in	r18, 0x06	; 6
    1d56:	9f 81       	ldd	r25, Y+7	; 0x07
    1d58:	30 e2       	ldi	r19, 0x20	; 32
    1d5a:	93 9f       	mul	r25, r19
    1d5c:	c0 01       	movw	r24, r0
    1d5e:	11 24       	eor	r1, r1
    1d60:	82 2b       	or	r24, r18
    1d62:	86 b9       	out	0x06, r24	; 6
    1d64:	33 98       	cbi	0x06, 3	; 6
    1d66:	96 b1       	in	r25, 0x06	; 6
    1d68:	8e 81       	ldd	r24, Y+6	; 0x06
    1d6a:	88 0f       	add	r24, r24
    1d6c:	88 0f       	add	r24, r24
    1d6e:	88 0f       	add	r24, r24
    1d70:	89 2b       	or	r24, r25
    1d72:	86 b9       	out	0x06, r24	; 6
    1d74:	87 b1       	in	r24, 0x07	; 7
    1d76:	80 7e       	andi	r24, 0xE0	; 224
    1d78:	87 b9       	out	0x07, r24	; 7
    1d7a:	97 b1       	in	r25, 0x07	; 7
    1d7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d7e:	89 2b       	or	r24, r25
    1d80:	87 b9       	out	0x07, r24	; 7
    1d82:	87 b1       	in	r24, 0x07	; 7
    1d84:	8f 73       	andi	r24, 0x3F	; 63
    1d86:	87 b9       	out	0x07, r24	; 7
    1d88:	27 b1       	in	r18, 0x07	; 7
    1d8a:	9a 81       	ldd	r25, Y+2	; 0x02
    1d8c:	30 e4       	ldi	r19, 0x40	; 64
    1d8e:	93 9f       	mul	r25, r19
    1d90:	c0 01       	movw	r24, r0
    1d92:	11 24       	eor	r1, r1
    1d94:	82 2b       	or	r24, r18
    1d96:	87 b9       	out	0x07, r24	; 7
    1d98:	3d 98       	cbi	0x07, 5	; 7
    1d9a:	27 b1       	in	r18, 0x07	; 7
    1d9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d9e:	30 e2       	ldi	r19, 0x20	; 32
    1da0:	93 9f       	mul	r25, r19
    1da2:	c0 01       	movw	r24, r0
    1da4:	11 24       	eor	r1, r1
    1da6:	82 2b       	or	r24, r18
    1da8:	87 b9       	out	0x07, r24	; 7
    1daa:	80 b7       	in	r24, 0x30	; 48
    1dac:	8f 71       	andi	r24, 0x1F	; 31
    1dae:	80 bf       	out	0x30, r24	; 48
    1db0:	20 b7       	in	r18, 0x30	; 48
    1db2:	99 81       	ldd	r25, Y+1	; 0x01
    1db4:	30 e2       	ldi	r19, 0x20	; 32
    1db6:	93 9f       	mul	r25, r19
    1db8:	c0 01       	movw	r24, r0
    1dba:	11 24       	eor	r1, r1
    1dbc:	82 2b       	or	r24, r18
    1dbe:	80 bf       	out	0x30, r24	; 48
    1dc0:	37 9a       	sbi	0x06, 7	; 6
    1dc2:	27 96       	adiw	r28, 0x07	; 7
    1dc4:	0f b6       	in	r0, 0x3f	; 63
    1dc6:	f8 94       	cli
    1dc8:	de bf       	out	0x3e, r29	; 62
    1dca:	0f be       	out	0x3f, r0	; 63
    1dcc:	cd bf       	out	0x3d, r28	; 61
    1dce:	df 91       	pop	r29
    1dd0:	cf 91       	pop	r28
    1dd2:	08 95       	ret

00001dd4 <ADC_start_convertion>:
}
void ADC_start_convertion(void)
{
	//set_bit(ADCSRA,ADCSRA_ADSC);
	ADCSRA |=(1<<ADCSRA_ADSC);
    1dd4:	36 9a       	sbi	0x06, 6	; 6
    1dd6:	08 95       	ret

00001dd8 <ADC_GetSingleSample>:
}
void ADC_GetSingleSample(uint16_t *Sample)
{
    1dd8:	cf 93       	push	r28
    1dda:	df 93       	push	r29
    1ddc:	ec 01       	movw	r28, r24
	/* clear the flag */
	ADCSRA |=(1<<ADCSRA_ADIF);
    1dde:	34 9a       	sbi	0x06, 4	; 6
	uint16_t u16_Temp;
	ADC_start_convertion();
    1de0:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <ADC_start_convertion>
	/* wait the flag */
	while(!(ADCSRA & (1<<ADCSRA_ADIF)));
    1de4:	34 9b       	sbis	0x06, 4	; 6
    1de6:	fe cf       	rjmp	.-4      	; 0x1de4 <ADC_GetSingleSample+0xc>
	u16_Temp =ADCL;
    1de8:	84 b1       	in	r24, 0x04	; 4
	u16_Temp |=(ADCH<<8);
    1dea:	25 b1       	in	r18, 0x05	; 5
	
	*Sample =u16_Temp ;
    1dec:	90 e0       	ldi	r25, 0x00	; 0
    1dee:	92 2b       	or	r25, r18
    1df0:	99 83       	std	Y+1, r25	; 0x01
    1df2:	88 83       	st	Y, r24
	
    1df4:	df 91       	pop	r29
    1df6:	cf 91       	pop	r28
    1df8:	08 95       	ret

00001dfa <Dio_init>:
			{
				DDRD &=~(1<<u8_PIN_num);
			}
			else
			{
				DDRD |=(1<<u8_PIN_num);
    1dfa:	fc 01       	movw	r30, r24
    1dfc:	80 81       	ld	r24, Z
    1dfe:	81 30       	cpi	r24, 0x01	; 1
    1e00:	09 f4       	brne	.+2      	; 0x1e04 <Dio_init+0xa>
    1e02:	44 c0       	rjmp	.+136    	; 0x1e8c <Dio_init+0x92>
    1e04:	38 f0       	brcs	.+14     	; 0x1e14 <Dio_init+0x1a>
    1e06:	82 30       	cpi	r24, 0x02	; 2
    1e08:	09 f4       	brne	.+2      	; 0x1e0c <Dio_init+0x12>
    1e0a:	7c c0       	rjmp	.+248    	; 0x1f04 <Dio_init+0x10a>
    1e0c:	83 30       	cpi	r24, 0x03	; 3
    1e0e:	09 f4       	brne	.+2      	; 0x1e12 <Dio_init+0x18>
    1e10:	b5 c0       	rjmp	.+362    	; 0x1f7c <Dio_init+0x182>
    1e12:	ee c0       	rjmp	.+476    	; 0x1ff0 <Dio_init+0x1f6>
    1e14:	82 81       	ldd	r24, Z+2	; 0x02
    1e16:	81 11       	cpse	r24, r1
    1e18:	0d c0       	rjmp	.+26     	; 0x1e34 <Dio_init+0x3a>
    1e1a:	2a b3       	in	r18, 0x1a	; 26
    1e1c:	81 e0       	ldi	r24, 0x01	; 1
    1e1e:	90 e0       	ldi	r25, 0x00	; 0
    1e20:	01 80       	ldd	r0, Z+1	; 0x01
    1e22:	02 c0       	rjmp	.+4      	; 0x1e28 <Dio_init+0x2e>
    1e24:	88 0f       	add	r24, r24
    1e26:	99 1f       	adc	r25, r25
    1e28:	0a 94       	dec	r0
    1e2a:	e2 f7       	brpl	.-8      	; 0x1e24 <Dio_init+0x2a>
    1e2c:	80 95       	com	r24
    1e2e:	82 23       	and	r24, r18
    1e30:	8a bb       	out	0x1a, r24	; 26
    1e32:	0d c0       	rjmp	.+26     	; 0x1e4e <Dio_init+0x54>
    1e34:	81 30       	cpi	r24, 0x01	; 1
    1e36:	59 f4       	brne	.+22     	; 0x1e4e <Dio_init+0x54>
    1e38:	2a b3       	in	r18, 0x1a	; 26
    1e3a:	81 e0       	ldi	r24, 0x01	; 1
    1e3c:	90 e0       	ldi	r25, 0x00	; 0
    1e3e:	01 80       	ldd	r0, Z+1	; 0x01
    1e40:	02 c0       	rjmp	.+4      	; 0x1e46 <Dio_init+0x4c>
    1e42:	88 0f       	add	r24, r24
    1e44:	99 1f       	adc	r25, r25
    1e46:	0a 94       	dec	r0
    1e48:	e2 f7       	brpl	.-8      	; 0x1e42 <Dio_init+0x48>
    1e4a:	82 2b       	or	r24, r18
    1e4c:	8a bb       	out	0x1a, r24	; 26
    1e4e:	83 81       	ldd	r24, Z+3	; 0x03
    1e50:	81 11       	cpse	r24, r1
    1e52:	0d c0       	rjmp	.+26     	; 0x1e6e <Dio_init+0x74>
    1e54:	2b b3       	in	r18, 0x1b	; 27
    1e56:	81 e0       	ldi	r24, 0x01	; 1
    1e58:	90 e0       	ldi	r25, 0x00	; 0
    1e5a:	01 80       	ldd	r0, Z+1	; 0x01
    1e5c:	02 c0       	rjmp	.+4      	; 0x1e62 <Dio_init+0x68>
    1e5e:	88 0f       	add	r24, r24
    1e60:	99 1f       	adc	r25, r25
    1e62:	0a 94       	dec	r0
    1e64:	e2 f7       	brpl	.-8      	; 0x1e5e <Dio_init+0x64>
    1e66:	80 95       	com	r24
    1e68:	82 23       	and	r24, r18
    1e6a:	8b bb       	out	0x1b, r24	; 27
    1e6c:	c1 c0       	rjmp	.+386    	; 0x1ff0 <Dio_init+0x1f6>
    1e6e:	81 30       	cpi	r24, 0x01	; 1
    1e70:	09 f0       	breq	.+2      	; 0x1e74 <Dio_init+0x7a>
    1e72:	be c0       	rjmp	.+380    	; 0x1ff0 <Dio_init+0x1f6>
    1e74:	2b b3       	in	r18, 0x1b	; 27
    1e76:	81 e0       	ldi	r24, 0x01	; 1
    1e78:	90 e0       	ldi	r25, 0x00	; 0
    1e7a:	01 80       	ldd	r0, Z+1	; 0x01
    1e7c:	02 c0       	rjmp	.+4      	; 0x1e82 <Dio_init+0x88>
    1e7e:	88 0f       	add	r24, r24
    1e80:	99 1f       	adc	r25, r25
    1e82:	0a 94       	dec	r0
    1e84:	e2 f7       	brpl	.-8      	; 0x1e7e <Dio_init+0x84>
    1e86:	82 2b       	or	r24, r18
    1e88:	8b bb       	out	0x1b, r24	; 27
    1e8a:	b2 c0       	rjmp	.+356    	; 0x1ff0 <Dio_init+0x1f6>
    1e8c:	82 81       	ldd	r24, Z+2	; 0x02
    1e8e:	81 11       	cpse	r24, r1
    1e90:	0d c0       	rjmp	.+26     	; 0x1eac <Dio_init+0xb2>
    1e92:	27 b3       	in	r18, 0x17	; 23
    1e94:	81 e0       	ldi	r24, 0x01	; 1
    1e96:	90 e0       	ldi	r25, 0x00	; 0
    1e98:	01 80       	ldd	r0, Z+1	; 0x01
    1e9a:	02 c0       	rjmp	.+4      	; 0x1ea0 <Dio_init+0xa6>
    1e9c:	88 0f       	add	r24, r24
    1e9e:	99 1f       	adc	r25, r25
    1ea0:	0a 94       	dec	r0
    1ea2:	e2 f7       	brpl	.-8      	; 0x1e9c <Dio_init+0xa2>
    1ea4:	80 95       	com	r24
    1ea6:	82 23       	and	r24, r18
    1ea8:	87 bb       	out	0x17, r24	; 23
    1eaa:	0d c0       	rjmp	.+26     	; 0x1ec6 <Dio_init+0xcc>
    1eac:	81 30       	cpi	r24, 0x01	; 1
    1eae:	59 f4       	brne	.+22     	; 0x1ec6 <Dio_init+0xcc>
    1eb0:	27 b3       	in	r18, 0x17	; 23
    1eb2:	81 e0       	ldi	r24, 0x01	; 1
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	01 80       	ldd	r0, Z+1	; 0x01
    1eb8:	02 c0       	rjmp	.+4      	; 0x1ebe <Dio_init+0xc4>
    1eba:	88 0f       	add	r24, r24
    1ebc:	99 1f       	adc	r25, r25
    1ebe:	0a 94       	dec	r0
    1ec0:	e2 f7       	brpl	.-8      	; 0x1eba <Dio_init+0xc0>
    1ec2:	82 2b       	or	r24, r18
    1ec4:	87 bb       	out	0x17, r24	; 23
    1ec6:	83 81       	ldd	r24, Z+3	; 0x03
    1ec8:	81 11       	cpse	r24, r1
    1eca:	0d c0       	rjmp	.+26     	; 0x1ee6 <Dio_init+0xec>
    1ecc:	28 b3       	in	r18, 0x18	; 24
    1ece:	81 e0       	ldi	r24, 0x01	; 1
    1ed0:	90 e0       	ldi	r25, 0x00	; 0
    1ed2:	01 80       	ldd	r0, Z+1	; 0x01
    1ed4:	02 c0       	rjmp	.+4      	; 0x1eda <Dio_init+0xe0>
    1ed6:	88 0f       	add	r24, r24
    1ed8:	99 1f       	adc	r25, r25
    1eda:	0a 94       	dec	r0
    1edc:	e2 f7       	brpl	.-8      	; 0x1ed6 <Dio_init+0xdc>
    1ede:	80 95       	com	r24
    1ee0:	82 23       	and	r24, r18
    1ee2:	88 bb       	out	0x18, r24	; 24
    1ee4:	85 c0       	rjmp	.+266    	; 0x1ff0 <Dio_init+0x1f6>
    1ee6:	81 30       	cpi	r24, 0x01	; 1
    1ee8:	09 f0       	breq	.+2      	; 0x1eec <Dio_init+0xf2>
    1eea:	82 c0       	rjmp	.+260    	; 0x1ff0 <Dio_init+0x1f6>
    1eec:	28 b3       	in	r18, 0x18	; 24
    1eee:	81 e0       	ldi	r24, 0x01	; 1
    1ef0:	90 e0       	ldi	r25, 0x00	; 0
    1ef2:	01 80       	ldd	r0, Z+1	; 0x01
    1ef4:	02 c0       	rjmp	.+4      	; 0x1efa <Dio_init+0x100>
    1ef6:	88 0f       	add	r24, r24
    1ef8:	99 1f       	adc	r25, r25
    1efa:	0a 94       	dec	r0
    1efc:	e2 f7       	brpl	.-8      	; 0x1ef6 <Dio_init+0xfc>
    1efe:	82 2b       	or	r24, r18
    1f00:	88 bb       	out	0x18, r24	; 24
    1f02:	76 c0       	rjmp	.+236    	; 0x1ff0 <Dio_init+0x1f6>
    1f04:	82 81       	ldd	r24, Z+2	; 0x02
    1f06:	81 11       	cpse	r24, r1
    1f08:	0d c0       	rjmp	.+26     	; 0x1f24 <Dio_init+0x12a>
    1f0a:	24 b3       	in	r18, 0x14	; 20
    1f0c:	81 e0       	ldi	r24, 0x01	; 1
    1f0e:	90 e0       	ldi	r25, 0x00	; 0
    1f10:	01 80       	ldd	r0, Z+1	; 0x01
    1f12:	02 c0       	rjmp	.+4      	; 0x1f18 <Dio_init+0x11e>
    1f14:	88 0f       	add	r24, r24
    1f16:	99 1f       	adc	r25, r25
    1f18:	0a 94       	dec	r0
    1f1a:	e2 f7       	brpl	.-8      	; 0x1f14 <Dio_init+0x11a>
    1f1c:	80 95       	com	r24
    1f1e:	82 23       	and	r24, r18
    1f20:	84 bb       	out	0x14, r24	; 20
    1f22:	0d c0       	rjmp	.+26     	; 0x1f3e <Dio_init+0x144>
    1f24:	81 30       	cpi	r24, 0x01	; 1
    1f26:	59 f4       	brne	.+22     	; 0x1f3e <Dio_init+0x144>
    1f28:	24 b3       	in	r18, 0x14	; 20
    1f2a:	81 e0       	ldi	r24, 0x01	; 1
    1f2c:	90 e0       	ldi	r25, 0x00	; 0
    1f2e:	01 80       	ldd	r0, Z+1	; 0x01
    1f30:	02 c0       	rjmp	.+4      	; 0x1f36 <Dio_init+0x13c>
    1f32:	88 0f       	add	r24, r24
    1f34:	99 1f       	adc	r25, r25
    1f36:	0a 94       	dec	r0
    1f38:	e2 f7       	brpl	.-8      	; 0x1f32 <Dio_init+0x138>
    1f3a:	82 2b       	or	r24, r18
    1f3c:	84 bb       	out	0x14, r24	; 20
    1f3e:	83 81       	ldd	r24, Z+3	; 0x03
    1f40:	81 11       	cpse	r24, r1
    1f42:	0d c0       	rjmp	.+26     	; 0x1f5e <Dio_init+0x164>
    1f44:	25 b3       	in	r18, 0x15	; 21
    1f46:	81 e0       	ldi	r24, 0x01	; 1
    1f48:	90 e0       	ldi	r25, 0x00	; 0
    1f4a:	01 80       	ldd	r0, Z+1	; 0x01
    1f4c:	02 c0       	rjmp	.+4      	; 0x1f52 <Dio_init+0x158>
    1f4e:	88 0f       	add	r24, r24
    1f50:	99 1f       	adc	r25, r25
    1f52:	0a 94       	dec	r0
    1f54:	e2 f7       	brpl	.-8      	; 0x1f4e <Dio_init+0x154>
    1f56:	80 95       	com	r24
    1f58:	82 23       	and	r24, r18
    1f5a:	85 bb       	out	0x15, r24	; 21
    1f5c:	49 c0       	rjmp	.+146    	; 0x1ff0 <Dio_init+0x1f6>
    1f5e:	81 30       	cpi	r24, 0x01	; 1
    1f60:	09 f0       	breq	.+2      	; 0x1f64 <Dio_init+0x16a>
    1f62:	46 c0       	rjmp	.+140    	; 0x1ff0 <Dio_init+0x1f6>
    1f64:	25 b3       	in	r18, 0x15	; 21
    1f66:	81 e0       	ldi	r24, 0x01	; 1
    1f68:	90 e0       	ldi	r25, 0x00	; 0
    1f6a:	01 80       	ldd	r0, Z+1	; 0x01
    1f6c:	02 c0       	rjmp	.+4      	; 0x1f72 <Dio_init+0x178>
    1f6e:	88 0f       	add	r24, r24
    1f70:	99 1f       	adc	r25, r25
    1f72:	0a 94       	dec	r0
    1f74:	e2 f7       	brpl	.-8      	; 0x1f6e <Dio_init+0x174>
    1f76:	82 2b       	or	r24, r18
    1f78:	85 bb       	out	0x15, r24	; 21
    1f7a:	3a c0       	rjmp	.+116    	; 0x1ff0 <Dio_init+0x1f6>
    1f7c:	82 81       	ldd	r24, Z+2	; 0x02
    1f7e:	81 11       	cpse	r24, r1
    1f80:	0d c0       	rjmp	.+26     	; 0x1f9c <Dio_init+0x1a2>
    1f82:	21 b3       	in	r18, 0x11	; 17
    1f84:	81 e0       	ldi	r24, 0x01	; 1
    1f86:	90 e0       	ldi	r25, 0x00	; 0
    1f88:	01 80       	ldd	r0, Z+1	; 0x01
    1f8a:	02 c0       	rjmp	.+4      	; 0x1f90 <Dio_init+0x196>
    1f8c:	88 0f       	add	r24, r24
    1f8e:	99 1f       	adc	r25, r25
    1f90:	0a 94       	dec	r0
    1f92:	e2 f7       	brpl	.-8      	; 0x1f8c <Dio_init+0x192>
    1f94:	80 95       	com	r24
    1f96:	82 23       	and	r24, r18
    1f98:	81 bb       	out	0x11, r24	; 17
    1f9a:	0d c0       	rjmp	.+26     	; 0x1fb6 <Dio_init+0x1bc>
    1f9c:	81 30       	cpi	r24, 0x01	; 1
    1f9e:	59 f4       	brne	.+22     	; 0x1fb6 <Dio_init+0x1bc>
    1fa0:	21 b3       	in	r18, 0x11	; 17
    1fa2:	81 e0       	ldi	r24, 0x01	; 1
    1fa4:	90 e0       	ldi	r25, 0x00	; 0
    1fa6:	01 80       	ldd	r0, Z+1	; 0x01
    1fa8:	02 c0       	rjmp	.+4      	; 0x1fae <Dio_init+0x1b4>
    1faa:	88 0f       	add	r24, r24
    1fac:	99 1f       	adc	r25, r25
    1fae:	0a 94       	dec	r0
    1fb0:	e2 f7       	brpl	.-8      	; 0x1faa <Dio_init+0x1b0>
    1fb2:	82 2b       	or	r24, r18
    1fb4:	81 bb       	out	0x11, r24	; 17
    1fb6:	83 81       	ldd	r24, Z+3	; 0x03
    1fb8:	81 11       	cpse	r24, r1
    1fba:	0d c0       	rjmp	.+26     	; 0x1fd6 <Dio_init+0x1dc>
    1fbc:	22 b3       	in	r18, 0x12	; 18
    1fbe:	81 e0       	ldi	r24, 0x01	; 1
    1fc0:	90 e0       	ldi	r25, 0x00	; 0
    1fc2:	01 80       	ldd	r0, Z+1	; 0x01
    1fc4:	02 c0       	rjmp	.+4      	; 0x1fca <Dio_init+0x1d0>
    1fc6:	88 0f       	add	r24, r24
    1fc8:	99 1f       	adc	r25, r25
    1fca:	0a 94       	dec	r0
    1fcc:	e2 f7       	brpl	.-8      	; 0x1fc6 <Dio_init+0x1cc>
    1fce:	80 95       	com	r24
    1fd0:	82 23       	and	r24, r18
    1fd2:	82 bb       	out	0x12, r24	; 18
    1fd4:	0d c0       	rjmp	.+26     	; 0x1ff0 <Dio_init+0x1f6>
    1fd6:	81 30       	cpi	r24, 0x01	; 1
    1fd8:	59 f4       	brne	.+22     	; 0x1ff0 <Dio_init+0x1f6>
    1fda:	22 b3       	in	r18, 0x12	; 18
    1fdc:	81 e0       	ldi	r24, 0x01	; 1
    1fde:	90 e0       	ldi	r25, 0x00	; 0
    1fe0:	01 80       	ldd	r0, Z+1	; 0x01
    1fe2:	02 c0       	rjmp	.+4      	; 0x1fe8 <Dio_init+0x1ee>
    1fe4:	88 0f       	add	r24, r24
    1fe6:	99 1f       	adc	r25, r25
    1fe8:	0a 94       	dec	r0
    1fea:	e2 f7       	brpl	.-8      	; 0x1fe4 <Dio_init+0x1ea>
    1fec:	82 2b       	or	r24, r18
    1fee:	82 bb       	out	0x12, r24	; 18
    1ff0:	81 e0       	ldi	r24, 0x01	; 1
    1ff2:	08 95       	ret

00001ff4 <Dio_readPin>:
    1ff4:	81 30       	cpi	r24, 0x01	; 1
    1ff6:	d1 f0       	breq	.+52     	; 0x202c <Dio_readPin+0x38>
    1ff8:	28 f0       	brcs	.+10     	; 0x2004 <Dio_readPin+0x10>
    1ffa:	82 30       	cpi	r24, 0x02	; 2
    1ffc:	59 f1       	breq	.+86     	; 0x2054 <Dio_readPin+0x60>
    1ffe:	83 30       	cpi	r24, 0x03	; 3
    2000:	e9 f1       	breq	.+122    	; 0x207c <Dio_readPin+0x88>
    2002:	08 95       	ret
    2004:	29 b3       	in	r18, 0x19	; 25
    2006:	81 e0       	ldi	r24, 0x01	; 1
    2008:	90 e0       	ldi	r25, 0x00	; 0
    200a:	06 2e       	mov	r0, r22
    200c:	02 c0       	rjmp	.+4      	; 0x2012 <Dio_readPin+0x1e>
    200e:	88 0f       	add	r24, r24
    2010:	99 1f       	adc	r25, r25
    2012:	0a 94       	dec	r0
    2014:	e2 f7       	brpl	.-8      	; 0x200e <Dio_readPin+0x1a>
    2016:	30 e0       	ldi	r19, 0x00	; 0
    2018:	82 23       	and	r24, r18
    201a:	93 23       	and	r25, r19
    201c:	02 c0       	rjmp	.+4      	; 0x2022 <Dio_readPin+0x2e>
    201e:	95 95       	asr	r25
    2020:	87 95       	ror	r24
    2022:	6a 95       	dec	r22
    2024:	e2 f7       	brpl	.-8      	; 0x201e <Dio_readPin+0x2a>
    2026:	fa 01       	movw	r30, r20
    2028:	80 83       	st	Z, r24
    202a:	08 95       	ret
    202c:	26 b3       	in	r18, 0x16	; 22
    202e:	81 e0       	ldi	r24, 0x01	; 1
    2030:	90 e0       	ldi	r25, 0x00	; 0
    2032:	06 2e       	mov	r0, r22
    2034:	02 c0       	rjmp	.+4      	; 0x203a <Dio_readPin+0x46>
    2036:	88 0f       	add	r24, r24
    2038:	99 1f       	adc	r25, r25
    203a:	0a 94       	dec	r0
    203c:	e2 f7       	brpl	.-8      	; 0x2036 <Dio_readPin+0x42>
    203e:	30 e0       	ldi	r19, 0x00	; 0
    2040:	82 23       	and	r24, r18
    2042:	93 23       	and	r25, r19
    2044:	02 c0       	rjmp	.+4      	; 0x204a <Dio_readPin+0x56>
    2046:	95 95       	asr	r25
    2048:	87 95       	ror	r24
    204a:	6a 95       	dec	r22
    204c:	e2 f7       	brpl	.-8      	; 0x2046 <Dio_readPin+0x52>
    204e:	fa 01       	movw	r30, r20
    2050:	80 83       	st	Z, r24
    2052:	08 95       	ret
    2054:	23 b3       	in	r18, 0x13	; 19
    2056:	81 e0       	ldi	r24, 0x01	; 1
    2058:	90 e0       	ldi	r25, 0x00	; 0
    205a:	06 2e       	mov	r0, r22
    205c:	02 c0       	rjmp	.+4      	; 0x2062 <Dio_readPin+0x6e>
    205e:	88 0f       	add	r24, r24
    2060:	99 1f       	adc	r25, r25
    2062:	0a 94       	dec	r0
    2064:	e2 f7       	brpl	.-8      	; 0x205e <Dio_readPin+0x6a>
    2066:	30 e0       	ldi	r19, 0x00	; 0
    2068:	82 23       	and	r24, r18
    206a:	93 23       	and	r25, r19
    206c:	02 c0       	rjmp	.+4      	; 0x2072 <Dio_readPin+0x7e>
    206e:	95 95       	asr	r25
    2070:	87 95       	ror	r24
    2072:	6a 95       	dec	r22
    2074:	e2 f7       	brpl	.-8      	; 0x206e <Dio_readPin+0x7a>
    2076:	fa 01       	movw	r30, r20
    2078:	80 83       	st	Z, r24
    207a:	08 95       	ret
    207c:	20 b3       	in	r18, 0x10	; 16
    207e:	81 e0       	ldi	r24, 0x01	; 1
    2080:	90 e0       	ldi	r25, 0x00	; 0
    2082:	06 2e       	mov	r0, r22
    2084:	02 c0       	rjmp	.+4      	; 0x208a <Dio_readPin+0x96>
    2086:	88 0f       	add	r24, r24
    2088:	99 1f       	adc	r25, r25
    208a:	0a 94       	dec	r0
    208c:	e2 f7       	brpl	.-8      	; 0x2086 <Dio_readPin+0x92>
    208e:	30 e0       	ldi	r19, 0x00	; 0
    2090:	82 23       	and	r24, r18
    2092:	93 23       	and	r25, r19
    2094:	02 c0       	rjmp	.+4      	; 0x209a <Dio_readPin+0xa6>
    2096:	95 95       	asr	r25
    2098:	87 95       	ror	r24
    209a:	6a 95       	dec	r22
    209c:	e2 f7       	brpl	.-8      	; 0x2096 <Dio_readPin+0xa2>
    209e:	fa 01       	movw	r30, r20
    20a0:	80 83       	st	Z, r24
    20a2:	08 95       	ret

000020a4 <Dio_writePin>:
    20a4:	81 30       	cpi	r24, 0x01	; 1
    20a6:	19 f1       	breq	.+70     	; 0x20ee <Dio_writePin+0x4a>
    20a8:	30 f0       	brcs	.+12     	; 0x20b6 <Dio_writePin+0x12>
    20aa:	82 30       	cpi	r24, 0x02	; 2
    20ac:	e1 f1       	breq	.+120    	; 0x2126 <Dio_writePin+0x82>
    20ae:	83 30       	cpi	r24, 0x03	; 3
    20b0:	09 f4       	brne	.+2      	; 0x20b4 <Dio_writePin+0x10>
    20b2:	54 c0       	rjmp	.+168    	; 0x215c <Dio_writePin+0xb8>
    20b4:	6d c0       	rjmp	.+218    	; 0x2190 <Dio_writePin+0xec>
    20b6:	41 11       	cpse	r20, r1
    20b8:	0c c0       	rjmp	.+24     	; 0x20d2 <Dio_writePin+0x2e>
    20ba:	2b b3       	in	r18, 0x1b	; 27
    20bc:	81 e0       	ldi	r24, 0x01	; 1
    20be:	90 e0       	ldi	r25, 0x00	; 0
    20c0:	02 c0       	rjmp	.+4      	; 0x20c6 <Dio_writePin+0x22>
    20c2:	88 0f       	add	r24, r24
    20c4:	99 1f       	adc	r25, r25
    20c6:	6a 95       	dec	r22
    20c8:	e2 f7       	brpl	.-8      	; 0x20c2 <Dio_writePin+0x1e>
    20ca:	80 95       	com	r24
    20cc:	82 23       	and	r24, r18
    20ce:	8b bb       	out	0x1b, r24	; 27
    20d0:	60 c0       	rjmp	.+192    	; 0x2192 <Dio_writePin+0xee>
    20d2:	41 30       	cpi	r20, 0x01	; 1
    20d4:	09 f0       	breq	.+2      	; 0x20d8 <Dio_writePin+0x34>
    20d6:	5c c0       	rjmp	.+184    	; 0x2190 <Dio_writePin+0xec>
    20d8:	2b b3       	in	r18, 0x1b	; 27
    20da:	81 e0       	ldi	r24, 0x01	; 1
    20dc:	90 e0       	ldi	r25, 0x00	; 0
    20de:	02 c0       	rjmp	.+4      	; 0x20e4 <Dio_writePin+0x40>
    20e0:	88 0f       	add	r24, r24
    20e2:	99 1f       	adc	r25, r25
    20e4:	6a 95       	dec	r22
    20e6:	e2 f7       	brpl	.-8      	; 0x20e0 <Dio_writePin+0x3c>
    20e8:	82 2b       	or	r24, r18
    20ea:	8b bb       	out	0x1b, r24	; 27
    20ec:	52 c0       	rjmp	.+164    	; 0x2192 <Dio_writePin+0xee>
    20ee:	41 11       	cpse	r20, r1
    20f0:	0c c0       	rjmp	.+24     	; 0x210a <Dio_writePin+0x66>
    20f2:	28 b3       	in	r18, 0x18	; 24
    20f4:	81 e0       	ldi	r24, 0x01	; 1
    20f6:	90 e0       	ldi	r25, 0x00	; 0
    20f8:	02 c0       	rjmp	.+4      	; 0x20fe <Dio_writePin+0x5a>
    20fa:	88 0f       	add	r24, r24
    20fc:	99 1f       	adc	r25, r25
    20fe:	6a 95       	dec	r22
    2100:	e2 f7       	brpl	.-8      	; 0x20fa <Dio_writePin+0x56>
    2102:	80 95       	com	r24
    2104:	82 23       	and	r24, r18
    2106:	88 bb       	out	0x18, r24	; 24
    2108:	43 c0       	rjmp	.+134    	; 0x2190 <Dio_writePin+0xec>
    210a:	41 30       	cpi	r20, 0x01	; 1
    210c:	09 f0       	breq	.+2      	; 0x2110 <Dio_writePin+0x6c>
    210e:	40 c0       	rjmp	.+128    	; 0x2190 <Dio_writePin+0xec>
    2110:	28 b3       	in	r18, 0x18	; 24
    2112:	81 e0       	ldi	r24, 0x01	; 1
    2114:	90 e0       	ldi	r25, 0x00	; 0
    2116:	02 c0       	rjmp	.+4      	; 0x211c <Dio_writePin+0x78>
    2118:	88 0f       	add	r24, r24
    211a:	99 1f       	adc	r25, r25
    211c:	6a 95       	dec	r22
    211e:	e2 f7       	brpl	.-8      	; 0x2118 <Dio_writePin+0x74>
    2120:	82 2b       	or	r24, r18
    2122:	88 bb       	out	0x18, r24	; 24
    2124:	35 c0       	rjmp	.+106    	; 0x2190 <Dio_writePin+0xec>
    2126:	41 11       	cpse	r20, r1
    2128:	0c c0       	rjmp	.+24     	; 0x2142 <Dio_writePin+0x9e>
    212a:	25 b3       	in	r18, 0x15	; 21
    212c:	81 e0       	ldi	r24, 0x01	; 1
    212e:	90 e0       	ldi	r25, 0x00	; 0
    2130:	02 c0       	rjmp	.+4      	; 0x2136 <Dio_writePin+0x92>
    2132:	88 0f       	add	r24, r24
    2134:	99 1f       	adc	r25, r25
    2136:	6a 95       	dec	r22
    2138:	e2 f7       	brpl	.-8      	; 0x2132 <Dio_writePin+0x8e>
    213a:	80 95       	com	r24
    213c:	82 23       	and	r24, r18
    213e:	85 bb       	out	0x15, r24	; 21
    2140:	27 c0       	rjmp	.+78     	; 0x2190 <Dio_writePin+0xec>
    2142:	41 30       	cpi	r20, 0x01	; 1
    2144:	29 f5       	brne	.+74     	; 0x2190 <Dio_writePin+0xec>
    2146:	25 b3       	in	r18, 0x15	; 21
    2148:	81 e0       	ldi	r24, 0x01	; 1
    214a:	90 e0       	ldi	r25, 0x00	; 0
    214c:	02 c0       	rjmp	.+4      	; 0x2152 <Dio_writePin+0xae>
    214e:	88 0f       	add	r24, r24
    2150:	99 1f       	adc	r25, r25
    2152:	6a 95       	dec	r22
    2154:	e2 f7       	brpl	.-8      	; 0x214e <Dio_writePin+0xaa>
    2156:	82 2b       	or	r24, r18
    2158:	85 bb       	out	0x15, r24	; 21
    215a:	1a c0       	rjmp	.+52     	; 0x2190 <Dio_writePin+0xec>
    215c:	41 11       	cpse	r20, r1
    215e:	0c c0       	rjmp	.+24     	; 0x2178 <Dio_writePin+0xd4>
    2160:	22 b3       	in	r18, 0x12	; 18
    2162:	81 e0       	ldi	r24, 0x01	; 1
    2164:	90 e0       	ldi	r25, 0x00	; 0
    2166:	02 c0       	rjmp	.+4      	; 0x216c <Dio_writePin+0xc8>
    2168:	88 0f       	add	r24, r24
    216a:	99 1f       	adc	r25, r25
    216c:	6a 95       	dec	r22
    216e:	e2 f7       	brpl	.-8      	; 0x2168 <Dio_writePin+0xc4>
    2170:	80 95       	com	r24
    2172:	82 23       	and	r24, r18
    2174:	82 bb       	out	0x12, r24	; 18
    2176:	0c c0       	rjmp	.+24     	; 0x2190 <Dio_writePin+0xec>
    2178:	41 30       	cpi	r20, 0x01	; 1
    217a:	51 f4       	brne	.+20     	; 0x2190 <Dio_writePin+0xec>
    217c:	22 b3       	in	r18, 0x12	; 18
    217e:	81 e0       	ldi	r24, 0x01	; 1
    2180:	90 e0       	ldi	r25, 0x00	; 0
    2182:	02 c0       	rjmp	.+4      	; 0x2188 <Dio_writePin+0xe4>
    2184:	88 0f       	add	r24, r24
    2186:	99 1f       	adc	r25, r25
    2188:	6a 95       	dec	r22
    218a:	e2 f7       	brpl	.-8      	; 0x2184 <Dio_writePin+0xe0>
    218c:	82 2b       	or	r24, r18
    218e:	82 bb       	out	0x12, r24	; 18
    2190:	08 95       	ret
    2192:	81 e0       	ldi	r24, 0x01	; 1
    2194:	08 95       	ret

00002196 <DIO_SetPortDirection>:
		
	}
}
void DIO_SetPortDirection(uint8_t u8_port , uint8_t u8_Direction)
{
	switch(u8_port)
    2196:	81 30       	cpi	r24, 0x01	; 1
    2198:	69 f0       	breq	.+26     	; 0x21b4 <DIO_SetPortDirection+0x1e>
    219a:	28 f0       	brcs	.+10     	; 0x21a6 <DIO_SetPortDirection+0x10>
    219c:	82 30       	cpi	r24, 0x02	; 2
    219e:	89 f0       	breq	.+34     	; 0x21c2 <DIO_SetPortDirection+0x2c>
    21a0:	83 30       	cpi	r24, 0x03	; 3
    21a2:	b1 f0       	breq	.+44     	; 0x21d0 <DIO_SetPortDirection+0x3a>
    21a4:	08 95       	ret
	{
		case PORT_A :
		{
			if (u8_Direction==DIO_PIN_DIR_INPUT)
    21a6:	61 11       	cpse	r22, r1
    21a8:	02 c0       	rjmp	.+4      	; 0x21ae <DIO_SetPortDirection+0x18>
			{
				DDRA =0;
    21aa:	1a ba       	out	0x1a, r1	; 26
				break;
    21ac:	08 95       	ret
			}
			else
			{
				DDRA =0xFF;
    21ae:	8f ef       	ldi	r24, 0xFF	; 255
    21b0:	8a bb       	out	0x1a, r24	; 26
				break;
    21b2:	08 95       	ret
			}
			
		}
		case PORT_B :
		{
			if (u8_Direction==DIO_PIN_DIR_INPUT)
    21b4:	61 11       	cpse	r22, r1
    21b6:	02 c0       	rjmp	.+4      	; 0x21bc <DIO_SetPortDirection+0x26>
			{
				DDRB =0;
    21b8:	17 ba       	out	0x17, r1	; 23
				break;
    21ba:	08 95       	ret
			}
			else
			{
				DDRB =0xFF;
    21bc:	8f ef       	ldi	r24, 0xFF	; 255
    21be:	87 bb       	out	0x17, r24	; 23
				break;
    21c0:	08 95       	ret
			}
		}
		case PORT_C :
		{
			if (u8_Direction==DIO_PIN_DIR_INPUT)
    21c2:	61 11       	cpse	r22, r1
    21c4:	02 c0       	rjmp	.+4      	; 0x21ca <DIO_SetPortDirection+0x34>
			{
				DDRC =0;
    21c6:	14 ba       	out	0x14, r1	; 20
				break;
    21c8:	08 95       	ret
			}
			else
			{
				DDRC =0xFF;
    21ca:	8f ef       	ldi	r24, 0xFF	; 255
    21cc:	84 bb       	out	0x14, r24	; 20
				break;
    21ce:	08 95       	ret
			}
		}
		case PORT_D :
		{
			if (u8_Direction==DIO_PIN_DIR_INPUT)
    21d0:	61 11       	cpse	r22, r1
    21d2:	02 c0       	rjmp	.+4      	; 0x21d8 <DIO_SetPortDirection+0x42>
			{
				DDRD =0;
    21d4:	11 ba       	out	0x11, r1	; 17
				break;
    21d6:	08 95       	ret
			}
			else
			{
				DDRD =0xFF;
    21d8:	8f ef       	ldi	r24, 0xFF	; 255
    21da:	81 bb       	out	0x11, r24	; 17
    21dc:	08 95       	ret

000021de <DIO_WritePort>:
		}
	}
}
void DIO_WritePort(uint8_t u8_port , uint8_t u8_val )
{
	switch(u8_port)
    21de:	81 30       	cpi	r24, 0x01	; 1
    21e0:	41 f0       	breq	.+16     	; 0x21f2 <DIO_WritePort+0x14>
    21e2:	28 f0       	brcs	.+10     	; 0x21ee <DIO_WritePort+0x10>
    21e4:	82 30       	cpi	r24, 0x02	; 2
    21e6:	31 f0       	breq	.+12     	; 0x21f4 <DIO_WritePort+0x16>
    21e8:	83 30       	cpi	r24, 0x03	; 3
    21ea:	31 f0       	breq	.+12     	; 0x21f8 <DIO_WritePort+0x1a>
    21ec:	08 95       	ret
	{
		case PORT_A :
		{
			PORTA = u8_val ;
    21ee:	6b bb       	out	0x1b, r22	; 27
			break;
    21f0:	08 95       	ret
		}
		case  PORT_B :
		{
			PORTB = u8_val;
    21f2:	68 bb       	out	0x18, r22	; 24
		}
		case PORT_C :
		{
			PORTC = u8_val;
    21f4:	65 bb       	out	0x15, r22	; 21
			break;
    21f6:	08 95       	ret
		}
		case PORT_D :
		{
			PORTD = u8_val;
    21f8:	62 bb       	out	0x12, r22	; 18
    21fa:	08 95       	ret

000021fc <MCAL_I2CMasterInit>:
	else if (u8State_reg==Data_received_NOTACK_sent)
	{
		return Data_received_NOTACK_sent;
	}
	
}
    21fc:	fc 01       	movw	r30, r24
    21fe:	91 b1       	in	r25, 0x01	; 1
    2200:	81 81       	ldd	r24, Z+1	; 0x01
    2202:	89 2b       	or	r24, r25
    2204:	81 b9       	out	0x01, r24	; 1
    2206:	80 81       	ld	r24, Z
    2208:	80 b9       	out	0x00, r24	; 0
    220a:	82 81       	ldd	r24, Z+2	; 0x02
    220c:	88 0f       	add	r24, r24
    220e:	82 b9       	out	0x02, r24	; 2
    2210:	08 95       	ret

00002212 <MCAL_I2CMaterEstablishComm>:
    2212:	94 ea       	ldi	r25, 0xA4	; 164
    2214:	96 bf       	out	0x36, r25	; 54
    2216:	06 b6       	in	r0, 0x36	; 54
    2218:	07 fe       	sbrs	r0, 7
    221a:	fd cf       	rjmp	.-6      	; 0x2216 <MCAL_I2CMaterEstablishComm+0x4>
    221c:	91 b1       	in	r25, 0x01	; 1
    221e:	98 7f       	andi	r25, 0xF8	; 248
    2220:	98 30       	cpi	r25, 0x08	; 8
    2222:	71 f4       	brne	.+28     	; 0x2240 <MCAL_I2CMaterEstablishComm+0x2e>
    2224:	88 0f       	add	r24, r24
    2226:	83 b9       	out	0x03, r24	; 3
    2228:	84 e8       	ldi	r24, 0x84	; 132
    222a:	86 bf       	out	0x36, r24	; 54
    222c:	06 b6       	in	r0, 0x36	; 54
    222e:	07 fe       	sbrs	r0, 7
    2230:	fd cf       	rjmp	.-6      	; 0x222c <MCAL_I2CMaterEstablishComm+0x1a>
    2232:	81 b1       	in	r24, 0x01	; 1
    2234:	88 7f       	andi	r24, 0xF8	; 248
    2236:	88 31       	cpi	r24, 0x18	; 24
    2238:	29 f0       	breq	.+10     	; 0x2244 <MCAL_I2CMaterEstablishComm+0x32>
    223a:	80 32       	cpi	r24, 0x20	; 32
    223c:	29 f0       	breq	.+10     	; 0x2248 <MCAL_I2CMaterEstablishComm+0x36>
    223e:	08 95       	ret
    2240:	80 e0       	ldi	r24, 0x00	; 0
    2242:	08 95       	ret
    2244:	88 e1       	ldi	r24, 0x18	; 24
    2246:	08 95       	ret
    2248:	80 e2       	ldi	r24, 0x20	; 32
    224a:	08 95       	ret

0000224c <MCAL_I2CMasterRepeatedStart>:
    224c:	94 ea       	ldi	r25, 0xA4	; 164
    224e:	96 bf       	out	0x36, r25	; 54
    2250:	06 b6       	in	r0, 0x36	; 54
    2252:	07 fe       	sbrs	r0, 7
    2254:	fd cf       	rjmp	.-6      	; 0x2250 <MCAL_I2CMasterRepeatedStart+0x4>
    2256:	91 b1       	in	r25, 0x01	; 1
    2258:	98 7f       	andi	r25, 0xF8	; 248
    225a:	90 31       	cpi	r25, 0x10	; 16
    225c:	79 f4       	brne	.+30     	; 0x227c <MCAL_I2CMasterRepeatedStart+0x30>
    225e:	88 0f       	add	r24, r24
    2260:	81 60       	ori	r24, 0x01	; 1
    2262:	83 b9       	out	0x03, r24	; 3
    2264:	84 e8       	ldi	r24, 0x84	; 132
    2266:	86 bf       	out	0x36, r24	; 54
    2268:	06 b6       	in	r0, 0x36	; 54
    226a:	07 fe       	sbrs	r0, 7
    226c:	fd cf       	rjmp	.-6      	; 0x2268 <MCAL_I2CMasterRepeatedStart+0x1c>
    226e:	81 b1       	in	r24, 0x01	; 1
    2270:	88 7f       	andi	r24, 0xF8	; 248
    2272:	80 34       	cpi	r24, 0x40	; 64
    2274:	29 f0       	breq	.+10     	; 0x2280 <MCAL_I2CMasterRepeatedStart+0x34>
    2276:	88 34       	cpi	r24, 0x48	; 72
    2278:	29 f0       	breq	.+10     	; 0x2284 <MCAL_I2CMasterRepeatedStart+0x38>
    227a:	08 95       	ret
    227c:	80 e0       	ldi	r24, 0x00	; 0
    227e:	08 95       	ret
    2280:	80 e4       	ldi	r24, 0x40	; 64
    2282:	08 95       	ret
    2284:	88 e4       	ldi	r24, 0x48	; 72
    2286:	08 95       	ret

00002288 <MCAL_I2CMasterWrightData>:
    2288:	fc 01       	movw	r30, r24
    228a:	80 81       	ld	r24, Z
    228c:	83 b9       	out	0x03, r24	; 3
    228e:	84 e8       	ldi	r24, 0x84	; 132
    2290:	86 bf       	out	0x36, r24	; 54
    2292:	06 b6       	in	r0, 0x36	; 54
    2294:	07 fe       	sbrs	r0, 7
    2296:	fd cf       	rjmp	.-6      	; 0x2292 <MCAL_I2CMasterWrightData+0xa>
    2298:	81 b1       	in	r24, 0x01	; 1
    229a:	88 7f       	andi	r24, 0xF8	; 248
    229c:	88 32       	cpi	r24, 0x28	; 40
    229e:	19 f0       	breq	.+6      	; 0x22a6 <MCAL_I2CMasterWrightData+0x1e>
    22a0:	80 33       	cpi	r24, 0x30	; 48
    22a2:	19 f0       	breq	.+6      	; 0x22aa <MCAL_I2CMasterWrightData+0x22>
    22a4:	08 95       	ret
    22a6:	88 e2       	ldi	r24, 0x28	; 40
    22a8:	08 95       	ret
    22aa:	80 e3       	ldi	r24, 0x30	; 48
    22ac:	08 95       	ret

000022ae <MCAL_I2CMasterReadsendNACK>:
I2C_status_codes MCAL_I2CMasterReadsendNACK(uint8_t *readData)
{
	uint8_t u8State_reg=0;
	/* Clear the TWINT Flag by writing 1 and enable I2c  */
	TWCR =(1<<TWCR_TWINT)|(1<<TWCR_TWEN);
    22ae:	24 e8       	ldi	r18, 0x84	; 132
    22b0:	26 bf       	out	0x36, r18	; 54
	
	/* wait the flag */
	while(!(TWCR &(1<<TWCR_TWINT)));
    22b2:	06 b6       	in	r0, 0x36	; 54
    22b4:	07 fe       	sbrs	r0, 7
    22b6:	fd cf       	rjmp	.-6      	; 0x22b2 <MCAL_I2CMasterReadsendNACK+0x4>
	
	//PORTA=TWDR;
	*readData =TWDR;
    22b8:	23 b1       	in	r18, 0x03	; 3
    22ba:	fc 01       	movw	r30, r24
    22bc:	20 83       	st	Z, r18
	//PORTA = *readData;
	/* Read TWI status register the 0XF8 to clear the first LSB 3 bits */
	u8State_reg =TWSR & 0xF8;
    22be:	81 b1       	in	r24, 0x01	; 1
	
	if (u8State_reg==Data_received_NOTACK_sent)
    22c0:	88 7f       	andi	r24, 0xF8	; 248
    22c2:	88 35       	cpi	r24, 0x58	; 88
    22c4:	01 f0       	breq	.+0      	; 0x22c6 <MCAL_I2CMasterReadsendNACK+0x18>
		
		return Data_received_NOTACK_sent;
	}
	
	
}
    22c6:	08 95       	ret

000022c8 <MCAL_I2CMasterStopCondition>:
void MCAL_I2CMasterStopCondition(void)
{
	
	/* Clear the TWINT Flag by writing 1 and enable I2c Enable stop condition  */
	TWCR =(1<<TWCR_TWINT)|(1<<TWCR_TWEN)|(1<<TWCR_TWSTO);
    22c8:	84 e9       	ldi	r24, 0x94	; 148
    22ca:	86 bf       	out	0x36, r24	; 54
	
	/* wait the stop condition finished */ 
	while(TWCR&(1<<TWCR_TWSTO));
    22cc:	06 b6       	in	r0, 0x36	; 54
    22ce:	04 fc       	sbrc	r0, 4
    22d0:	fd cf       	rjmp	.-6      	; 0x22cc <MCAL_I2CMasterStopCondition+0x4>
	
}
    22d2:	08 95       	ret

000022d4 <SetEXTI0CallBackFunction>:
/**************************EXTI0 CALL back pointer to function********************************/
static void (*EXTI0_CallBack)(void);
/******************************************************************************************/
void SetEXTI0CallBackFunction(void (*ptr)(void))
{
	EXTI0_CallBack = ptr;
    22d4:	90 93 86 07 	sts	0x0786, r25	; 0x800786 <EXTI0_CallBack+0x1>
    22d8:	80 93 85 07 	sts	0x0785, r24	; 0x800785 <EXTI0_CallBack>
    22dc:	08 95       	ret

000022de <EXTI0_init>:
}


void EXTI0_init(uint8_t trigger)
{
	switch(trigger)
    22de:	81 30       	cpi	r24, 0x01	; 1
    22e0:	69 f0       	breq	.+26     	; 0x22fc <EXTI0_init+0x1e>
    22e2:	28 f0       	brcs	.+10     	; 0x22ee <EXTI0_init+0x10>
    22e4:	82 30       	cpi	r24, 0x02	; 2
    22e6:	c1 f0       	breq	.+48     	; 0x2318 <EXTI0_init+0x3a>
    22e8:	83 30       	cpi	r24, 0x03	; 3
    22ea:	79 f0       	breq	.+30     	; 0x230a <EXTI0_init+0x2c>
    22ec:	08 95       	ret
	{
		case LOW_LEVEL :
		
		 // we need to set ISC01:00 TO 00
		MCUCR &=~(1<<ISC00);
    22ee:	85 b7       	in	r24, 0x35	; 53
    22f0:	8e 7f       	andi	r24, 0xFE	; 254
    22f2:	85 bf       	out	0x35, r24	; 53
		MCUCR &=~(1<<ISC01);
    22f4:	85 b7       	in	r24, 0x35	; 53
    22f6:	8d 7f       	andi	r24, 0xFD	; 253
    22f8:	85 bf       	out	0x35, r24	; 53
		
		break;
    22fa:	08 95       	ret
		case Any_logic :
		// we need to set ISC10:00 TO 01
		MCUCR |=(1<<ISC00);
    22fc:	85 b7       	in	r24, 0x35	; 53
    22fe:	81 60       	ori	r24, 0x01	; 1
    2300:	85 bf       	out	0x35, r24	; 53
		MCUCR &=~(1<<ISC01);
    2302:	85 b7       	in	r24, 0x35	; 53
    2304:	8d 7f       	andi	r24, 0xFD	; 253
    2306:	85 bf       	out	0x35, r24	; 53
		break;
    2308:	08 95       	ret
		
		case Failing :
		
		MCUCR &=~(1<<ISC00); // we need to set ISC10:00 TO 10
    230a:	85 b7       	in	r24, 0x35	; 53
    230c:	8e 7f       	andi	r24, 0xFE	; 254
    230e:	85 bf       	out	0x35, r24	; 53
		MCUCR |=(1<<ISC01);
    2310:	85 b7       	in	r24, 0x35	; 53
    2312:	82 60       	ori	r24, 0x02	; 2
    2314:	85 bf       	out	0x35, r24	; 53
		break;
    2316:	08 95       	ret
		
		case Rising :
		
		MCUCR |=(1<<ISC00); // we need to set ISC10:00 TO 11
    2318:	85 b7       	in	r24, 0x35	; 53
    231a:	81 60       	ori	r24, 0x01	; 1
    231c:	85 bf       	out	0x35, r24	; 53
		MCUCR |=(1<<ISC01);
    231e:	85 b7       	in	r24, 0x35	; 53
    2320:	82 60       	ori	r24, 0x02	; 2
    2322:	85 bf       	out	0x35, r24	; 53
    2324:	08 95       	ret

00002326 <EXTI0_Enable>:
	
}

void EXTI0_Enable(void)
{
	SREG |=(1<<I); // enable global interrupt
    2326:	8f b7       	in	r24, 0x3f	; 63
    2328:	80 68       	ori	r24, 0x80	; 128
    232a:	8f bf       	out	0x3f, r24	; 63
	GICR|=(1<<INT0);  // Enable EXTINT0
    232c:	8b b7       	in	r24, 0x3b	; 59
    232e:	80 64       	ori	r24, 0x40	; 64
    2330:	8b bf       	out	0x3b, r24	; 59
    2332:	08 95       	ret

00002334 <EXTI0_Disable>:
}
void EXTI0_Disable(void)
{
	/* clear interrupt flag */
	GIFR |=(1<<6);
    2334:	8a b7       	in	r24, 0x3a	; 58
    2336:	80 64       	ori	r24, 0x40	; 64
    2338:	8a bf       	out	0x3a, r24	; 58
	GICR &=~(1<<INT0);  // Disable EXTINT0
    233a:	8b b7       	in	r24, 0x3b	; 59
    233c:	8f 7b       	andi	r24, 0xBF	; 191
    233e:	8b bf       	out	0x3b, r24	; 59
    2340:	08 95       	ret

00002342 <__vector_1>:
}

/*************EXTI0 ISR*******************/

void __vector_1(void)
{
    2342:	1f 92       	push	r1
    2344:	0f 92       	push	r0
    2346:	0f b6       	in	r0, 0x3f	; 63
    2348:	0f 92       	push	r0
    234a:	11 24       	eor	r1, r1
    234c:	2f 93       	push	r18
    234e:	3f 93       	push	r19
    2350:	4f 93       	push	r20
    2352:	5f 93       	push	r21
    2354:	6f 93       	push	r22
    2356:	7f 93       	push	r23
    2358:	8f 93       	push	r24
    235a:	9f 93       	push	r25
    235c:	af 93       	push	r26
    235e:	bf 93       	push	r27
    2360:	ef 93       	push	r30
    2362:	ff 93       	push	r31
	EXTI0_CallBack();
    2364:	e0 91 85 07 	lds	r30, 0x0785	; 0x800785 <EXTI0_CallBack>
    2368:	f0 91 86 07 	lds	r31, 0x0786	; 0x800786 <EXTI0_CallBack+0x1>
    236c:	09 95       	icall
}
    236e:	ff 91       	pop	r31
    2370:	ef 91       	pop	r30
    2372:	bf 91       	pop	r27
    2374:	af 91       	pop	r26
    2376:	9f 91       	pop	r25
    2378:	8f 91       	pop	r24
    237a:	7f 91       	pop	r23
    237c:	6f 91       	pop	r22
    237e:	5f 91       	pop	r21
    2380:	4f 91       	pop	r20
    2382:	3f 91       	pop	r19
    2384:	2f 91       	pop	r18
    2386:	0f 90       	pop	r0
    2388:	0f be       	out	0x3f, r0	; 63
    238a:	0f 90       	pop	r0
    238c:	1f 90       	pop	r1
    238e:	18 95       	reti

00002390 <MCAL_SpiInit>:
	/* wait until flag is set */
	while(!(SPSR &(1<<SPSR_SPIF)));
	
	flush_buffer = SPDR;
	
}
    2390:	6e 9a       	sbi	0x0d, 6	; 13
    2392:	6c 9a       	sbi	0x0d, 4	; 13
    2394:	8d b1       	in	r24, 0x0d	; 13
    2396:	8c 7f       	andi	r24, 0xFC	; 252
    2398:	8d b9       	out	0x0d, r24	; 13
    239a:	8d b1       	in	r24, 0x0d	; 13
    239c:	83 60       	ori	r24, 0x03	; 3
    239e:	8d b9       	out	0x0d, r24	; 13
    23a0:	70 98       	cbi	0x0e, 0	; 14
    23a2:	bc 9a       	sbi	0x17, 4	; 23
    23a4:	c4 9a       	sbi	0x18, 4	; 24
    23a6:	bd 9a       	sbi	0x17, 5	; 23
    23a8:	be 98       	cbi	0x17, 6	; 23
    23aa:	bf 9a       	sbi	0x17, 7	; 23
    23ac:	08 95       	ret

000023ae <MCAL_SPI_DisableInterrupt>:
    23ae:	6f 98       	cbi	0x0d, 7	; 13
    23b0:	08 95       	ret

000023b2 <MCAL_SPIMasterReceive>:
void MCAL_SPIMasterReceive(uint8_t *ReceivedData)
{
	volatile uint16_t x;
	/* apply low signal to SS*/
	PORTB &=~(1<<PB_SS);
    23b2:	c4 98       	cbi	0x18, 4	; 24
	
	
	
	
	/* load data to be send into SPI data reg */
	SPDR = 0xff;
    23b4:	2f ef       	ldi	r18, 0xFF	; 255
    23b6:	2f b9       	out	0x0f, r18	; 15
	
	
	/* wait until flag is set */
	while(!(SPSR &(1<<SPSR_SPIF)));
    23b8:	77 9b       	sbis	0x0e, 7	; 14
    23ba:	fe cf       	rjmp	.-4      	; 0x23b8 <MCAL_SPIMasterReceive+0x6>
	
	
	/* received Data   */
	*ReceivedData = SPDR;
    23bc:	2f b1       	in	r18, 0x0f	; 15
    23be:	fc 01       	movw	r30, r24
    23c0:	20 83       	st	Z, r18
    23c2:	08 95       	ret

000023c4 <__vector_12>:
	/* reset SS to High */
	//PORTB |=(1<<PB_SS);
}

void __vector_12(void)
{
    23c4:	1f 92       	push	r1
    23c6:	0f 92       	push	r0
    23c8:	0f b6       	in	r0, 0x3f	; 63
    23ca:	0f 92       	push	r0
    23cc:	11 24       	eor	r1, r1
    23ce:	2f 93       	push	r18
    23d0:	3f 93       	push	r19
    23d2:	4f 93       	push	r20
    23d4:	5f 93       	push	r21
    23d6:	6f 93       	push	r22
    23d8:	7f 93       	push	r23
    23da:	8f 93       	push	r24
    23dc:	9f 93       	push	r25
    23de:	af 93       	push	r26
    23e0:	bf 93       	push	r27
    23e2:	ef 93       	push	r30
    23e4:	ff 93       	push	r31
	MCAL_SPI_DisableInterrupt();
    23e6:	0e 94 d7 11 	call	0x23ae	; 0x23ae <MCAL_SPI_DisableInterrupt>
	pCallBack();
    23ea:	e0 91 2a 08 	lds	r30, 0x082A	; 0x80082a <pCallBack>
    23ee:	f0 91 2b 08 	lds	r31, 0x082B	; 0x80082b <pCallBack+0x1>
    23f2:	09 95       	icall
    23f4:	ff 91       	pop	r31
    23f6:	ef 91       	pop	r30
    23f8:	bf 91       	pop	r27
    23fa:	af 91       	pop	r26
    23fc:	9f 91       	pop	r25
    23fe:	8f 91       	pop	r24
    2400:	7f 91       	pop	r23
    2402:	6f 91       	pop	r22
    2404:	5f 91       	pop	r21
    2406:	4f 91       	pop	r20
    2408:	3f 91       	pop	r19
    240a:	2f 91       	pop	r18
    240c:	0f 90       	pop	r0
    240e:	0f be       	out	0x3f, r0	; 63
    2410:	0f 90       	pop	r0
    2412:	1f 90       	pop	r1
    2414:	18 95       	reti

00002416 <GptInit>:
		else if(timer_config[u8_counter].EN_channel==TIMER1)
		{
			
		}
	}
}
    2416:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <timer_config>
    241a:	81 11       	cpse	r24, r1
    241c:	07 c0       	rjmp	.+14     	; 0x242c <GptInit+0x16>
    241e:	12 be       	out	0x32, r1	; 50
    2420:	82 b7       	in	r24, 0x32	; 50
    2422:	8f 7b       	andi	r24, 0xBF	; 191
    2424:	82 bf       	out	0x32, r24	; 50
    2426:	82 b7       	in	r24, 0x32	; 50
    2428:	87 7f       	andi	r24, 0xF7	; 247
    242a:	82 bf       	out	0x32, r24	; 50
    242c:	80 91 77 00 	lds	r24, 0x0077	; 0x800077 <timer_config+0x3>
    2430:	81 11       	cpse	r24, r1
    2432:	07 c0       	rjmp	.+14     	; 0x2442 <GptInit+0x2c>
    2434:	12 be       	out	0x32, r1	; 50
    2436:	82 b7       	in	r24, 0x32	; 50
    2438:	8f 7b       	andi	r24, 0xBF	; 191
    243a:	82 bf       	out	0x32, r24	; 50
    243c:	82 b7       	in	r24, 0x32	; 50
    243e:	87 7f       	andi	r24, 0xF7	; 247
    2440:	82 bf       	out	0x32, r24	; 50
    2442:	08 95       	ret

00002444 <GptStart_Sync>:
    2444:	cf 92       	push	r12
    2446:	df 92       	push	r13
    2448:	ef 92       	push	r14
    244a:	ff 92       	push	r15
    244c:	0f 93       	push	r16
    244e:	1f 93       	push	r17
    2450:	cf 93       	push	r28
    2452:	df 93       	push	r29
    2454:	c5 2e       	mov	r12, r21
    2456:	d6 2e       	mov	r13, r22
    2458:	e7 2e       	mov	r14, r23
    245a:	ff 24       	eor	r15, r15
    245c:	4f 3f       	cpi	r20, 0xFF	; 255
    245e:	51 05       	cpc	r21, r1
    2460:	61 05       	cpc	r22, r1
    2462:	71 05       	cpc	r23, r1
    2464:	09 f0       	breq	.+2      	; 0x2468 <GptStart_Sync+0x24>
    2466:	18 f4       	brcc	.+6      	; 0x246e <GptStart_Sync+0x2a>
    2468:	c1 2c       	mov	r12, r1
    246a:	d1 2c       	mov	r13, r1
    246c:	76 01       	movw	r14, r12
    246e:	8f ef       	ldi	r24, 0xFF	; 255
    2470:	c8 1a       	sub	r12, r24
    2472:	d8 0a       	sbc	r13, r24
    2474:	e8 0a       	sbc	r14, r24
    2476:	f8 0a       	sbc	r15, r24
    2478:	e4 e7       	ldi	r30, 0x74	; 116
    247a:	f0 e0       	ldi	r31, 0x00	; 0
    247c:	ca e7       	ldi	r28, 0x7A	; 122
    247e:	d0 e0       	ldi	r29, 0x00	; 0
    2480:	94 2f       	mov	r25, r20
    2482:	91 95       	neg	r25
    2484:	df 01       	movw	r26, r30
    2486:	80 81       	ld	r24, Z
    2488:	81 11       	cpse	r24, r1
    248a:	23 c0       	rjmp	.+70     	; 0x24d2 <GptStart_Sync+0x8e>
    248c:	4f 3f       	cpi	r20, 0xFF	; 255
    248e:	51 05       	cpc	r21, r1
    2490:	61 05       	cpc	r22, r1
    2492:	71 05       	cpc	r23, r1
    2494:	09 f0       	breq	.+2      	; 0x2498 <GptStart_Sync+0x54>
    2496:	10 f4       	brcc	.+4      	; 0x249c <GptStart_Sync+0x58>
    2498:	92 bf       	out	0x32, r25	; 50
    249a:	01 c0       	rjmp	.+2      	; 0x249e <GptStart_Sync+0x5a>
    249c:	92 bf       	out	0x32, r25	; 50
    249e:	83 b7       	in	r24, 0x33	; 51
    24a0:	88 7f       	andi	r24, 0xF8	; 248
    24a2:	83 bf       	out	0x33, r24	; 51
    24a4:	23 b7       	in	r18, 0x33	; 51
    24a6:	12 96       	adiw	r26, 0x02	; 2
    24a8:	8c 91       	ld	r24, X
    24aa:	82 2b       	or	r24, r18
    24ac:	83 bf       	out	0x33, r24	; 51
    24ae:	00 e0       	ldi	r16, 0x00	; 0
    24b0:	10 e0       	ldi	r17, 0x00	; 0
    24b2:	98 01       	movw	r18, r16
    24b4:	08 b6       	in	r0, 0x38	; 56
    24b6:	00 fe       	sbrs	r0, 0
    24b8:	fd cf       	rjmp	.-6      	; 0x24b4 <GptStart_Sync+0x70>
    24ba:	88 b7       	in	r24, 0x38	; 56
    24bc:	81 60       	ori	r24, 0x01	; 1
    24be:	88 bf       	out	0x38, r24	; 56
    24c0:	0f 5f       	subi	r16, 0xFF	; 255
    24c2:	1f 4f       	sbci	r17, 0xFF	; 255
    24c4:	2f 4f       	sbci	r18, 0xFF	; 255
    24c6:	3f 4f       	sbci	r19, 0xFF	; 255
    24c8:	c0 16       	cp	r12, r16
    24ca:	d1 06       	cpc	r13, r17
    24cc:	e2 06       	cpc	r14, r18
    24ce:	f3 06       	cpc	r15, r19
    24d0:	88 f7       	brcc	.-30     	; 0x24b4 <GptStart_Sync+0x70>
    24d2:	33 96       	adiw	r30, 0x03	; 3
    24d4:	ec 17       	cp	r30, r28
    24d6:	fd 07       	cpc	r31, r29
    24d8:	a9 f6       	brne	.-86     	; 0x2484 <GptStart_Sync+0x40>
    24da:	df 91       	pop	r29
    24dc:	cf 91       	pop	r28
    24de:	1f 91       	pop	r17
    24e0:	0f 91       	pop	r16
    24e2:	ff 90       	pop	r15
    24e4:	ef 90       	pop	r14
    24e6:	df 90       	pop	r13
    24e8:	cf 90       	pop	r12
    24ea:	08 95       	ret

000024ec <__vector_11>:
/***********************************************************************************/

/*********************** timer0 Overflow ISR************************************/
void __vector_11(void)
{   
    24ec:	1f 92       	push	r1
    24ee:	0f 92       	push	r0
    24f0:	0f b6       	in	r0, 0x3f	; 63
    24f2:	0f 92       	push	r0
    24f4:	11 24       	eor	r1, r1
    24f6:	2f 93       	push	r18
    24f8:	3f 93       	push	r19
    24fa:	4f 93       	push	r20
    24fc:	5f 93       	push	r21
    24fe:	6f 93       	push	r22
    2500:	7f 93       	push	r23
    2502:	8f 93       	push	r24
    2504:	9f 93       	push	r25
    2506:	af 93       	push	r26
    2508:	bf 93       	push	r27
    250a:	ef 93       	push	r30
    250c:	ff 93       	push	r31
	u8_gOVF_Counter--;
    250e:	80 91 87 07 	lds	r24, 0x0787	; 0x800787 <u8_gOVF_Counter>
    2512:	90 91 88 07 	lds	r25, 0x0788	; 0x800788 <u8_gOVF_Counter+0x1>
    2516:	a0 91 89 07 	lds	r26, 0x0789	; 0x800789 <u8_gOVF_Counter+0x2>
    251a:	b0 91 8a 07 	lds	r27, 0x078A	; 0x80078a <u8_gOVF_Counter+0x3>
    251e:	01 97       	sbiw	r24, 0x01	; 1
    2520:	a1 09       	sbc	r26, r1
    2522:	b1 09       	sbc	r27, r1
    2524:	80 93 87 07 	sts	0x0787, r24	; 0x800787 <u8_gOVF_Counter>
    2528:	90 93 88 07 	sts	0x0788, r25	; 0x800788 <u8_gOVF_Counter+0x1>
    252c:	a0 93 89 07 	sts	0x0789, r26	; 0x800789 <u8_gOVF_Counter+0x2>
    2530:	b0 93 8a 07 	sts	0x078A, r27	; 0x80078a <u8_gOVF_Counter+0x3>
	
	if(u8_gOVF_Counter==0)
    2534:	80 91 87 07 	lds	r24, 0x0787	; 0x800787 <u8_gOVF_Counter>
    2538:	90 91 88 07 	lds	r25, 0x0788	; 0x800788 <u8_gOVF_Counter+0x1>
    253c:	a0 91 89 07 	lds	r26, 0x0789	; 0x800789 <u8_gOVF_Counter+0x2>
    2540:	b0 91 8a 07 	lds	r27, 0x078A	; 0x80078a <u8_gOVF_Counter+0x3>
    2544:	89 2b       	or	r24, r25
    2546:	8a 2b       	or	r24, r26
    2548:	8b 2b       	or	r24, r27
    254a:	41 f4       	brne	.+16     	; 0x255c <__vector_11+0x70>
	{   
		// disable interrupt
		TIMSK &=~(1<<TIMSK_TOIE0);
    254c:	89 b7       	in	r24, 0x39	; 57
    254e:	8e 7f       	andi	r24, 0xFE	; 254
    2550:	89 bf       	out	0x39, r24	; 57
		// call back
		OVF_CallBack();
    2552:	e0 91 8b 07 	lds	r30, 0x078B	; 0x80078b <OVF_CallBack>
    2556:	f0 91 8c 07 	lds	r31, 0x078C	; 0x80078c <OVF_CallBack+0x1>
    255a:	09 95       	icall
	}
	
	
}
    255c:	ff 91       	pop	r31
    255e:	ef 91       	pop	r30
    2560:	bf 91       	pop	r27
    2562:	af 91       	pop	r26
    2564:	9f 91       	pop	r25
    2566:	8f 91       	pop	r24
    2568:	7f 91       	pop	r23
    256a:	6f 91       	pop	r22
    256c:	5f 91       	pop	r21
    256e:	4f 91       	pop	r20
    2570:	3f 91       	pop	r19
    2572:	2f 91       	pop	r18
    2574:	0f 90       	pop	r0
    2576:	0f be       	out	0x3f, r0	; 63
    2578:	0f 90       	pop	r0
    257a:	1f 90       	pop	r1
    257c:	18 95       	reti

0000257e <USART_Init>:
}
UART_ERROR_t USART_RX_Disable(void)
{
	UCSRB &=~(1<<UCSRB_RXEN);
	return UART_NO_ERROR;
}
    257e:	59 98       	cbi	0x0b, 1	; 11
    2580:	8c e0       	ldi	r24, 0x0C	; 12
    2582:	89 b9       	out	0x09, r24	; 9
    2584:	10 bc       	out	0x20, r1	; 32
    2586:	80 b5       	in	r24, 0x20	; 32
    2588:	86 68       	ori	r24, 0x86	; 134
    258a:	80 bd       	out	0x20, r24	; 32
    258c:	80 b5       	in	r24, 0x20	; 32
    258e:	80 68       	ori	r24, 0x80	; 128
    2590:	80 bd       	out	0x20, r24	; 32
    2592:	80 b5       	in	r24, 0x20	; 32
    2594:	80 68       	ori	r24, 0x80	; 128
    2596:	80 bd       	out	0x20, r24	; 32
    2598:	80 b5       	in	r24, 0x20	; 32
    259a:	80 68       	ori	r24, 0x80	; 128
    259c:	80 bd       	out	0x20, r24	; 32
    259e:	80 e0       	ldi	r24, 0x00	; 0
    25a0:	08 95       	ret

000025a2 <USART_Transmit>:
    25a2:	53 9a       	sbi	0x0a, 3	; 10
    25a4:	5d 9b       	sbis	0x0b, 5	; 11
    25a6:	fe cf       	rjmp	.-4      	; 0x25a4 <USART_Transmit+0x2>
    25a8:	8c b9       	out	0x0c, r24	; 12
    25aa:	80 e0       	ldi	r24, 0x00	; 0
    25ac:	08 95       	ret

000025ae <USART_Receive>:
    25ae:	00 97       	sbiw	r24, 0x00	; 0
    25b0:	79 f0       	breq	.+30     	; 0x25d0 <USART_Receive+0x22>
    25b2:	54 9a       	sbi	0x0a, 4	; 10
    25b4:	fc 01       	movw	r30, r24
    25b6:	11 82       	std	Z+1, r1	; 0x01
    25b8:	10 82       	st	Z, r1
    25ba:	5f 9b       	sbis	0x0b, 7	; 11
    25bc:	fe cf       	rjmp	.-4      	; 0x25ba <USART_Receive+0xc>
    25be:	5a 99       	sbic	0x0b, 2	; 11
    25c0:	09 c0       	rjmp	.+18     	; 0x25d4 <USART_Receive+0x26>
    25c2:	2c b1       	in	r18, 0x0c	; 12
    25c4:	30 e0       	ldi	r19, 0x00	; 0
    25c6:	fc 01       	movw	r30, r24
    25c8:	31 83       	std	Z+1, r19	; 0x01
    25ca:	20 83       	st	Z, r18
    25cc:	80 e0       	ldi	r24, 0x00	; 0
    25ce:	08 95       	ret
    25d0:	82 e0       	ldi	r24, 0x02	; 2
    25d2:	08 95       	ret
    25d4:	83 e0       	ldi	r24, 0x03	; 3
    25d6:	08 95       	ret

000025d8 <USART_RxInterruptEnable>:
    25d8:	57 9a       	sbi	0x0a, 7	; 10
    25da:	80 e0       	ldi	r24, 0x00	; 0
    25dc:	08 95       	ret

000025de <USART_Receive_INTDriven>:
    25de:	54 9a       	sbi	0x0a, 4	; 10
    25e0:	90 93 2e 08 	sts	0x082E, r25	; 0x80082e <U8_Receive_UDR+0x1>
    25e4:	80 93 2d 08 	sts	0x082D, r24	; 0x80082d <U8_Receive_UDR>
    25e8:	70 93 8e 07 	sts	0x078E, r23	; 0x80078e <RXC_CallBack+0x1>
    25ec:	60 93 8d 07 	sts	0x078D, r22	; 0x80078d <RXC_CallBack>
    25f0:	8f b7       	in	r24, 0x3f	; 63
    25f2:	80 68       	ori	r24, 0x80	; 128
    25f4:	8f bf       	out	0x3f, r24	; 63
    25f6:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <USART_RxInterruptEnable>
    25fa:	80 e0       	ldi	r24, 0x00	; 0
    25fc:	08 95       	ret

000025fe <USART_RxInterruptDiable>:
    25fe:	57 98       	cbi	0x0a, 7	; 10
    2600:	80 e0       	ldi	r24, 0x00	; 0
    2602:	08 95       	ret

00002604 <USART_UDRInterruptDisable>:
    2604:	55 98       	cbi	0x0a, 5	; 10
    2606:	80 e0       	ldi	r24, 0x00	; 0
    2608:	08 95       	ret

0000260a <__vector_14>:
/************UDRE ISR***************************************************/
void __vector_14(void)
{
    260a:	1f 92       	push	r1
    260c:	0f 92       	push	r0
    260e:	0f b6       	in	r0, 0x3f	; 63
    2610:	0f 92       	push	r0
    2612:	11 24       	eor	r1, r1
    2614:	2f 93       	push	r18
    2616:	3f 93       	push	r19
    2618:	4f 93       	push	r20
    261a:	5f 93       	push	r21
    261c:	6f 93       	push	r22
    261e:	7f 93       	push	r23
    2620:	8f 93       	push	r24
    2622:	9f 93       	push	r25
    2624:	af 93       	push	r26
    2626:	bf 93       	push	r27
    2628:	ef 93       	push	r30
    262a:	ff 93       	push	r31
	//PORTA |=(1<<0);
	 UDR=U8_Transmit_UDR;
    262c:	80 91 2c 08 	lds	r24, 0x082C	; 0x80082c <U8_Transmit_UDR>
    2630:	8c b9       	out	0x0c, r24	; 12
	USART_UDRInterruptDisable();
    2632:	0e 94 02 13 	call	0x2604	; 0x2604 <USART_UDRInterruptDisable>
	UDRE_CallBack();
    2636:	e0 91 8f 07 	lds	r30, 0x078F	; 0x80078f <UDRE_CallBack>
    263a:	f0 91 90 07 	lds	r31, 0x0790	; 0x800790 <UDRE_CallBack+0x1>
    263e:	09 95       	icall
}
    2640:	ff 91       	pop	r31
    2642:	ef 91       	pop	r30
    2644:	bf 91       	pop	r27
    2646:	af 91       	pop	r26
    2648:	9f 91       	pop	r25
    264a:	8f 91       	pop	r24
    264c:	7f 91       	pop	r23
    264e:	6f 91       	pop	r22
    2650:	5f 91       	pop	r21
    2652:	4f 91       	pop	r20
    2654:	3f 91       	pop	r19
    2656:	2f 91       	pop	r18
    2658:	0f 90       	pop	r0
    265a:	0f be       	out	0x3f, r0	; 63
    265c:	0f 90       	pop	r0
    265e:	1f 90       	pop	r1
    2660:	18 95       	reti

00002662 <__vector_13>:
/**************************************/

/*************RXC ISR*******************/

void __vector_13(void)
{
    2662:	1f 92       	push	r1
    2664:	0f 92       	push	r0
    2666:	0f b6       	in	r0, 0x3f	; 63
    2668:	0f 92       	push	r0
    266a:	11 24       	eor	r1, r1
    266c:	2f 93       	push	r18
    266e:	3f 93       	push	r19
    2670:	4f 93       	push	r20
    2672:	5f 93       	push	r21
    2674:	6f 93       	push	r22
    2676:	7f 93       	push	r23
    2678:	8f 93       	push	r24
    267a:	9f 93       	push	r25
    267c:	af 93       	push	r26
    267e:	bf 93       	push	r27
    2680:	ef 93       	push	r30
    2682:	ff 93       	push	r31
	*U8_Receive_UDR =UDR;
    2684:	e0 91 2d 08 	lds	r30, 0x082D	; 0x80082d <U8_Receive_UDR>
    2688:	f0 91 2e 08 	lds	r31, 0x082E	; 0x80082e <U8_Receive_UDR+0x1>
    268c:	8c b1       	in	r24, 0x0c	; 12
    268e:	80 83       	st	Z, r24
	RXC_CallBack();
    2690:	e0 91 8d 07 	lds	r30, 0x078D	; 0x80078d <RXC_CallBack>
    2694:	f0 91 8e 07 	lds	r31, 0x078E	; 0x80078e <RXC_CallBack+0x1>
    2698:	09 95       	icall
}
    269a:	ff 91       	pop	r31
    269c:	ef 91       	pop	r30
    269e:	bf 91       	pop	r27
    26a0:	af 91       	pop	r26
    26a2:	9f 91       	pop	r25
    26a4:	8f 91       	pop	r24
    26a6:	7f 91       	pop	r23
    26a8:	6f 91       	pop	r22
    26aa:	5f 91       	pop	r21
    26ac:	4f 91       	pop	r20
    26ae:	3f 91       	pop	r19
    26b0:	2f 91       	pop	r18
    26b2:	0f 90       	pop	r0
    26b4:	0f be       	out	0x3f, r0	; 63
    26b6:	0f 90       	pop	r0
    26b8:	1f 90       	pop	r1
    26ba:	18 95       	reti

000026bc <__subsf3>:
    26bc:	50 58       	subi	r21, 0x80	; 128

000026be <__addsf3>:
    26be:	bb 27       	eor	r27, r27
    26c0:	aa 27       	eor	r26, r26
    26c2:	0e 94 76 13 	call	0x26ec	; 0x26ec <__addsf3x>
    26c6:	0c 94 f0 14 	jmp	0x29e0	; 0x29e0 <__fp_round>
    26ca:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <__fp_pscA>
    26ce:	38 f0       	brcs	.+14     	; 0x26de <__addsf3+0x20>
    26d0:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <__fp_pscB>
    26d4:	20 f0       	brcs	.+8      	; 0x26de <__addsf3+0x20>
    26d6:	39 f4       	brne	.+14     	; 0x26e6 <__addsf3+0x28>
    26d8:	9f 3f       	cpi	r25, 0xFF	; 255
    26da:	19 f4       	brne	.+6      	; 0x26e2 <__addsf3+0x24>
    26dc:	26 f4       	brtc	.+8      	; 0x26e6 <__addsf3+0x28>
    26de:	0c 94 df 14 	jmp	0x29be	; 0x29be <__fp_nan>
    26e2:	0e f4       	brtc	.+2      	; 0x26e6 <__addsf3+0x28>
    26e4:	e0 95       	com	r30
    26e6:	e7 fb       	bst	r30, 7
    26e8:	0c 94 d9 14 	jmp	0x29b2	; 0x29b2 <__fp_inf>

000026ec <__addsf3x>:
    26ec:	e9 2f       	mov	r30, r25
    26ee:	0e 94 01 15 	call	0x2a02	; 0x2a02 <__fp_split3>
    26f2:	58 f3       	brcs	.-42     	; 0x26ca <__addsf3+0xc>
    26f4:	ba 17       	cp	r27, r26
    26f6:	62 07       	cpc	r22, r18
    26f8:	73 07       	cpc	r23, r19
    26fa:	84 07       	cpc	r24, r20
    26fc:	95 07       	cpc	r25, r21
    26fe:	20 f0       	brcs	.+8      	; 0x2708 <__addsf3x+0x1c>
    2700:	79 f4       	brne	.+30     	; 0x2720 <__addsf3x+0x34>
    2702:	a6 f5       	brtc	.+104    	; 0x276c <__addsf3x+0x80>
    2704:	0c 94 23 15 	jmp	0x2a46	; 0x2a46 <__fp_zero>
    2708:	0e f4       	brtc	.+2      	; 0x270c <__addsf3x+0x20>
    270a:	e0 95       	com	r30
    270c:	0b 2e       	mov	r0, r27
    270e:	ba 2f       	mov	r27, r26
    2710:	a0 2d       	mov	r26, r0
    2712:	0b 01       	movw	r0, r22
    2714:	b9 01       	movw	r22, r18
    2716:	90 01       	movw	r18, r0
    2718:	0c 01       	movw	r0, r24
    271a:	ca 01       	movw	r24, r20
    271c:	a0 01       	movw	r20, r0
    271e:	11 24       	eor	r1, r1
    2720:	ff 27       	eor	r31, r31
    2722:	59 1b       	sub	r21, r25
    2724:	99 f0       	breq	.+38     	; 0x274c <__addsf3x+0x60>
    2726:	59 3f       	cpi	r21, 0xF9	; 249
    2728:	50 f4       	brcc	.+20     	; 0x273e <__addsf3x+0x52>
    272a:	50 3e       	cpi	r21, 0xE0	; 224
    272c:	68 f1       	brcs	.+90     	; 0x2788 <__addsf3x+0x9c>
    272e:	1a 16       	cp	r1, r26
    2730:	f0 40       	sbci	r31, 0x00	; 0
    2732:	a2 2f       	mov	r26, r18
    2734:	23 2f       	mov	r18, r19
    2736:	34 2f       	mov	r19, r20
    2738:	44 27       	eor	r20, r20
    273a:	58 5f       	subi	r21, 0xF8	; 248
    273c:	f3 cf       	rjmp	.-26     	; 0x2724 <__addsf3x+0x38>
    273e:	46 95       	lsr	r20
    2740:	37 95       	ror	r19
    2742:	27 95       	ror	r18
    2744:	a7 95       	ror	r26
    2746:	f0 40       	sbci	r31, 0x00	; 0
    2748:	53 95       	inc	r21
    274a:	c9 f7       	brne	.-14     	; 0x273e <__addsf3x+0x52>
    274c:	7e f4       	brtc	.+30     	; 0x276c <__addsf3x+0x80>
    274e:	1f 16       	cp	r1, r31
    2750:	ba 0b       	sbc	r27, r26
    2752:	62 0b       	sbc	r22, r18
    2754:	73 0b       	sbc	r23, r19
    2756:	84 0b       	sbc	r24, r20
    2758:	ba f0       	brmi	.+46     	; 0x2788 <__addsf3x+0x9c>
    275a:	91 50       	subi	r25, 0x01	; 1
    275c:	a1 f0       	breq	.+40     	; 0x2786 <__addsf3x+0x9a>
    275e:	ff 0f       	add	r31, r31
    2760:	bb 1f       	adc	r27, r27
    2762:	66 1f       	adc	r22, r22
    2764:	77 1f       	adc	r23, r23
    2766:	88 1f       	adc	r24, r24
    2768:	c2 f7       	brpl	.-16     	; 0x275a <__addsf3x+0x6e>
    276a:	0e c0       	rjmp	.+28     	; 0x2788 <__addsf3x+0x9c>
    276c:	ba 0f       	add	r27, r26
    276e:	62 1f       	adc	r22, r18
    2770:	73 1f       	adc	r23, r19
    2772:	84 1f       	adc	r24, r20
    2774:	48 f4       	brcc	.+18     	; 0x2788 <__addsf3x+0x9c>
    2776:	87 95       	ror	r24
    2778:	77 95       	ror	r23
    277a:	67 95       	ror	r22
    277c:	b7 95       	ror	r27
    277e:	f7 95       	ror	r31
    2780:	9e 3f       	cpi	r25, 0xFE	; 254
    2782:	08 f0       	brcs	.+2      	; 0x2786 <__addsf3x+0x9a>
    2784:	b0 cf       	rjmp	.-160    	; 0x26e6 <__addsf3+0x28>
    2786:	93 95       	inc	r25
    2788:	88 0f       	add	r24, r24
    278a:	08 f0       	brcs	.+2      	; 0x278e <__addsf3x+0xa2>
    278c:	99 27       	eor	r25, r25
    278e:	ee 0f       	add	r30, r30
    2790:	97 95       	ror	r25
    2792:	87 95       	ror	r24
    2794:	08 95       	ret

00002796 <__cmpsf2>:
    2796:	0e 94 b5 14 	call	0x296a	; 0x296a <__fp_cmp>
    279a:	08 f4       	brcc	.+2      	; 0x279e <__cmpsf2+0x8>
    279c:	81 e0       	ldi	r24, 0x01	; 1
    279e:	08 95       	ret

000027a0 <__divsf3>:
    27a0:	0e 94 e4 13 	call	0x27c8	; 0x27c8 <__divsf3x>
    27a4:	0c 94 f0 14 	jmp	0x29e0	; 0x29e0 <__fp_round>
    27a8:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <__fp_pscB>
    27ac:	58 f0       	brcs	.+22     	; 0x27c4 <__divsf3+0x24>
    27ae:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <__fp_pscA>
    27b2:	40 f0       	brcs	.+16     	; 0x27c4 <__divsf3+0x24>
    27b4:	29 f4       	brne	.+10     	; 0x27c0 <__divsf3+0x20>
    27b6:	5f 3f       	cpi	r21, 0xFF	; 255
    27b8:	29 f0       	breq	.+10     	; 0x27c4 <__divsf3+0x24>
    27ba:	0c 94 d9 14 	jmp	0x29b2	; 0x29b2 <__fp_inf>
    27be:	51 11       	cpse	r21, r1
    27c0:	0c 94 24 15 	jmp	0x2a48	; 0x2a48 <__fp_szero>
    27c4:	0c 94 df 14 	jmp	0x29be	; 0x29be <__fp_nan>

000027c8 <__divsf3x>:
    27c8:	0e 94 01 15 	call	0x2a02	; 0x2a02 <__fp_split3>
    27cc:	68 f3       	brcs	.-38     	; 0x27a8 <__divsf3+0x8>

000027ce <__divsf3_pse>:
    27ce:	99 23       	and	r25, r25
    27d0:	b1 f3       	breq	.-20     	; 0x27be <__divsf3+0x1e>
    27d2:	55 23       	and	r21, r21
    27d4:	91 f3       	breq	.-28     	; 0x27ba <__divsf3+0x1a>
    27d6:	95 1b       	sub	r25, r21
    27d8:	55 0b       	sbc	r21, r21
    27da:	bb 27       	eor	r27, r27
    27dc:	aa 27       	eor	r26, r26
    27de:	62 17       	cp	r22, r18
    27e0:	73 07       	cpc	r23, r19
    27e2:	84 07       	cpc	r24, r20
    27e4:	38 f0       	brcs	.+14     	; 0x27f4 <__divsf3_pse+0x26>
    27e6:	9f 5f       	subi	r25, 0xFF	; 255
    27e8:	5f 4f       	sbci	r21, 0xFF	; 255
    27ea:	22 0f       	add	r18, r18
    27ec:	33 1f       	adc	r19, r19
    27ee:	44 1f       	adc	r20, r20
    27f0:	aa 1f       	adc	r26, r26
    27f2:	a9 f3       	breq	.-22     	; 0x27de <__divsf3_pse+0x10>
    27f4:	35 d0       	rcall	.+106    	; 0x2860 <__divsf3_pse+0x92>
    27f6:	0e 2e       	mov	r0, r30
    27f8:	3a f0       	brmi	.+14     	; 0x2808 <__divsf3_pse+0x3a>
    27fa:	e0 e8       	ldi	r30, 0x80	; 128
    27fc:	32 d0       	rcall	.+100    	; 0x2862 <__divsf3_pse+0x94>
    27fe:	91 50       	subi	r25, 0x01	; 1
    2800:	50 40       	sbci	r21, 0x00	; 0
    2802:	e6 95       	lsr	r30
    2804:	00 1c       	adc	r0, r0
    2806:	ca f7       	brpl	.-14     	; 0x27fa <__divsf3_pse+0x2c>
    2808:	2b d0       	rcall	.+86     	; 0x2860 <__divsf3_pse+0x92>
    280a:	fe 2f       	mov	r31, r30
    280c:	29 d0       	rcall	.+82     	; 0x2860 <__divsf3_pse+0x92>
    280e:	66 0f       	add	r22, r22
    2810:	77 1f       	adc	r23, r23
    2812:	88 1f       	adc	r24, r24
    2814:	bb 1f       	adc	r27, r27
    2816:	26 17       	cp	r18, r22
    2818:	37 07       	cpc	r19, r23
    281a:	48 07       	cpc	r20, r24
    281c:	ab 07       	cpc	r26, r27
    281e:	b0 e8       	ldi	r27, 0x80	; 128
    2820:	09 f0       	breq	.+2      	; 0x2824 <__divsf3_pse+0x56>
    2822:	bb 0b       	sbc	r27, r27
    2824:	80 2d       	mov	r24, r0
    2826:	bf 01       	movw	r22, r30
    2828:	ff 27       	eor	r31, r31
    282a:	93 58       	subi	r25, 0x83	; 131
    282c:	5f 4f       	sbci	r21, 0xFF	; 255
    282e:	3a f0       	brmi	.+14     	; 0x283e <__divsf3_pse+0x70>
    2830:	9e 3f       	cpi	r25, 0xFE	; 254
    2832:	51 05       	cpc	r21, r1
    2834:	78 f0       	brcs	.+30     	; 0x2854 <__divsf3_pse+0x86>
    2836:	0c 94 d9 14 	jmp	0x29b2	; 0x29b2 <__fp_inf>
    283a:	0c 94 24 15 	jmp	0x2a48	; 0x2a48 <__fp_szero>
    283e:	5f 3f       	cpi	r21, 0xFF	; 255
    2840:	e4 f3       	brlt	.-8      	; 0x283a <__divsf3_pse+0x6c>
    2842:	98 3e       	cpi	r25, 0xE8	; 232
    2844:	d4 f3       	brlt	.-12     	; 0x283a <__divsf3_pse+0x6c>
    2846:	86 95       	lsr	r24
    2848:	77 95       	ror	r23
    284a:	67 95       	ror	r22
    284c:	b7 95       	ror	r27
    284e:	f7 95       	ror	r31
    2850:	9f 5f       	subi	r25, 0xFF	; 255
    2852:	c9 f7       	brne	.-14     	; 0x2846 <__divsf3_pse+0x78>
    2854:	88 0f       	add	r24, r24
    2856:	91 1d       	adc	r25, r1
    2858:	96 95       	lsr	r25
    285a:	87 95       	ror	r24
    285c:	97 f9       	bld	r25, 7
    285e:	08 95       	ret
    2860:	e1 e0       	ldi	r30, 0x01	; 1
    2862:	66 0f       	add	r22, r22
    2864:	77 1f       	adc	r23, r23
    2866:	88 1f       	adc	r24, r24
    2868:	bb 1f       	adc	r27, r27
    286a:	62 17       	cp	r22, r18
    286c:	73 07       	cpc	r23, r19
    286e:	84 07       	cpc	r24, r20
    2870:	ba 07       	cpc	r27, r26
    2872:	20 f0       	brcs	.+8      	; 0x287c <__divsf3_pse+0xae>
    2874:	62 1b       	sub	r22, r18
    2876:	73 0b       	sbc	r23, r19
    2878:	84 0b       	sbc	r24, r20
    287a:	ba 0b       	sbc	r27, r26
    287c:	ee 1f       	adc	r30, r30
    287e:	88 f7       	brcc	.-30     	; 0x2862 <__divsf3_pse+0x94>
    2880:	e0 95       	com	r30
    2882:	08 95       	ret

00002884 <__fixsfsi>:
    2884:	0e 94 49 14 	call	0x2892	; 0x2892 <__fixunssfsi>
    2888:	68 94       	set
    288a:	b1 11       	cpse	r27, r1
    288c:	0c 94 24 15 	jmp	0x2a48	; 0x2a48 <__fp_szero>
    2890:	08 95       	ret

00002892 <__fixunssfsi>:
    2892:	0e 94 09 15 	call	0x2a12	; 0x2a12 <__fp_splitA>
    2896:	88 f0       	brcs	.+34     	; 0x28ba <__fixunssfsi+0x28>
    2898:	9f 57       	subi	r25, 0x7F	; 127
    289a:	98 f0       	brcs	.+38     	; 0x28c2 <__fixunssfsi+0x30>
    289c:	b9 2f       	mov	r27, r25
    289e:	99 27       	eor	r25, r25
    28a0:	b7 51       	subi	r27, 0x17	; 23
    28a2:	b0 f0       	brcs	.+44     	; 0x28d0 <__fixunssfsi+0x3e>
    28a4:	e1 f0       	breq	.+56     	; 0x28de <__fixunssfsi+0x4c>
    28a6:	66 0f       	add	r22, r22
    28a8:	77 1f       	adc	r23, r23
    28aa:	88 1f       	adc	r24, r24
    28ac:	99 1f       	adc	r25, r25
    28ae:	1a f0       	brmi	.+6      	; 0x28b6 <__fixunssfsi+0x24>
    28b0:	ba 95       	dec	r27
    28b2:	c9 f7       	brne	.-14     	; 0x28a6 <__fixunssfsi+0x14>
    28b4:	14 c0       	rjmp	.+40     	; 0x28de <__fixunssfsi+0x4c>
    28b6:	b1 30       	cpi	r27, 0x01	; 1
    28b8:	91 f0       	breq	.+36     	; 0x28de <__fixunssfsi+0x4c>
    28ba:	0e 94 23 15 	call	0x2a46	; 0x2a46 <__fp_zero>
    28be:	b1 e0       	ldi	r27, 0x01	; 1
    28c0:	08 95       	ret
    28c2:	0c 94 23 15 	jmp	0x2a46	; 0x2a46 <__fp_zero>
    28c6:	67 2f       	mov	r22, r23
    28c8:	78 2f       	mov	r23, r24
    28ca:	88 27       	eor	r24, r24
    28cc:	b8 5f       	subi	r27, 0xF8	; 248
    28ce:	39 f0       	breq	.+14     	; 0x28de <__fixunssfsi+0x4c>
    28d0:	b9 3f       	cpi	r27, 0xF9	; 249
    28d2:	cc f3       	brlt	.-14     	; 0x28c6 <__fixunssfsi+0x34>
    28d4:	86 95       	lsr	r24
    28d6:	77 95       	ror	r23
    28d8:	67 95       	ror	r22
    28da:	b3 95       	inc	r27
    28dc:	d9 f7       	brne	.-10     	; 0x28d4 <__fixunssfsi+0x42>
    28de:	3e f4       	brtc	.+14     	; 0x28ee <__fixunssfsi+0x5c>
    28e0:	90 95       	com	r25
    28e2:	80 95       	com	r24
    28e4:	70 95       	com	r23
    28e6:	61 95       	neg	r22
    28e8:	7f 4f       	sbci	r23, 0xFF	; 255
    28ea:	8f 4f       	sbci	r24, 0xFF	; 255
    28ec:	9f 4f       	sbci	r25, 0xFF	; 255
    28ee:	08 95       	ret

000028f0 <__floatunsisf>:
    28f0:	e8 94       	clt
    28f2:	09 c0       	rjmp	.+18     	; 0x2906 <__floatsisf+0x12>

000028f4 <__floatsisf>:
    28f4:	97 fb       	bst	r25, 7
    28f6:	3e f4       	brtc	.+14     	; 0x2906 <__floatsisf+0x12>
    28f8:	90 95       	com	r25
    28fa:	80 95       	com	r24
    28fc:	70 95       	com	r23
    28fe:	61 95       	neg	r22
    2900:	7f 4f       	sbci	r23, 0xFF	; 255
    2902:	8f 4f       	sbci	r24, 0xFF	; 255
    2904:	9f 4f       	sbci	r25, 0xFF	; 255
    2906:	99 23       	and	r25, r25
    2908:	a9 f0       	breq	.+42     	; 0x2934 <__floatsisf+0x40>
    290a:	f9 2f       	mov	r31, r25
    290c:	96 e9       	ldi	r25, 0x96	; 150
    290e:	bb 27       	eor	r27, r27
    2910:	93 95       	inc	r25
    2912:	f6 95       	lsr	r31
    2914:	87 95       	ror	r24
    2916:	77 95       	ror	r23
    2918:	67 95       	ror	r22
    291a:	b7 95       	ror	r27
    291c:	f1 11       	cpse	r31, r1
    291e:	f8 cf       	rjmp	.-16     	; 0x2910 <__floatsisf+0x1c>
    2920:	fa f4       	brpl	.+62     	; 0x2960 <__floatsisf+0x6c>
    2922:	bb 0f       	add	r27, r27
    2924:	11 f4       	brne	.+4      	; 0x292a <__floatsisf+0x36>
    2926:	60 ff       	sbrs	r22, 0
    2928:	1b c0       	rjmp	.+54     	; 0x2960 <__floatsisf+0x6c>
    292a:	6f 5f       	subi	r22, 0xFF	; 255
    292c:	7f 4f       	sbci	r23, 0xFF	; 255
    292e:	8f 4f       	sbci	r24, 0xFF	; 255
    2930:	9f 4f       	sbci	r25, 0xFF	; 255
    2932:	16 c0       	rjmp	.+44     	; 0x2960 <__floatsisf+0x6c>
    2934:	88 23       	and	r24, r24
    2936:	11 f0       	breq	.+4      	; 0x293c <__floatsisf+0x48>
    2938:	96 e9       	ldi	r25, 0x96	; 150
    293a:	11 c0       	rjmp	.+34     	; 0x295e <__floatsisf+0x6a>
    293c:	77 23       	and	r23, r23
    293e:	21 f0       	breq	.+8      	; 0x2948 <__floatsisf+0x54>
    2940:	9e e8       	ldi	r25, 0x8E	; 142
    2942:	87 2f       	mov	r24, r23
    2944:	76 2f       	mov	r23, r22
    2946:	05 c0       	rjmp	.+10     	; 0x2952 <__floatsisf+0x5e>
    2948:	66 23       	and	r22, r22
    294a:	71 f0       	breq	.+28     	; 0x2968 <__floatsisf+0x74>
    294c:	96 e8       	ldi	r25, 0x86	; 134
    294e:	86 2f       	mov	r24, r22
    2950:	70 e0       	ldi	r23, 0x00	; 0
    2952:	60 e0       	ldi	r22, 0x00	; 0
    2954:	2a f0       	brmi	.+10     	; 0x2960 <__floatsisf+0x6c>
    2956:	9a 95       	dec	r25
    2958:	66 0f       	add	r22, r22
    295a:	77 1f       	adc	r23, r23
    295c:	88 1f       	adc	r24, r24
    295e:	da f7       	brpl	.-10     	; 0x2956 <__floatsisf+0x62>
    2960:	88 0f       	add	r24, r24
    2962:	96 95       	lsr	r25
    2964:	87 95       	ror	r24
    2966:	97 f9       	bld	r25, 7
    2968:	08 95       	ret

0000296a <__fp_cmp>:
    296a:	99 0f       	add	r25, r25
    296c:	00 08       	sbc	r0, r0
    296e:	55 0f       	add	r21, r21
    2970:	aa 0b       	sbc	r26, r26
    2972:	e0 e8       	ldi	r30, 0x80	; 128
    2974:	fe ef       	ldi	r31, 0xFE	; 254
    2976:	16 16       	cp	r1, r22
    2978:	17 06       	cpc	r1, r23
    297a:	e8 07       	cpc	r30, r24
    297c:	f9 07       	cpc	r31, r25
    297e:	c0 f0       	brcs	.+48     	; 0x29b0 <__fp_cmp+0x46>
    2980:	12 16       	cp	r1, r18
    2982:	13 06       	cpc	r1, r19
    2984:	e4 07       	cpc	r30, r20
    2986:	f5 07       	cpc	r31, r21
    2988:	98 f0       	brcs	.+38     	; 0x29b0 <__fp_cmp+0x46>
    298a:	62 1b       	sub	r22, r18
    298c:	73 0b       	sbc	r23, r19
    298e:	84 0b       	sbc	r24, r20
    2990:	95 0b       	sbc	r25, r21
    2992:	39 f4       	brne	.+14     	; 0x29a2 <__fp_cmp+0x38>
    2994:	0a 26       	eor	r0, r26
    2996:	61 f0       	breq	.+24     	; 0x29b0 <__fp_cmp+0x46>
    2998:	23 2b       	or	r18, r19
    299a:	24 2b       	or	r18, r20
    299c:	25 2b       	or	r18, r21
    299e:	21 f4       	brne	.+8      	; 0x29a8 <__fp_cmp+0x3e>
    29a0:	08 95       	ret
    29a2:	0a 26       	eor	r0, r26
    29a4:	09 f4       	brne	.+2      	; 0x29a8 <__fp_cmp+0x3e>
    29a6:	a1 40       	sbci	r26, 0x01	; 1
    29a8:	a6 95       	lsr	r26
    29aa:	8f ef       	ldi	r24, 0xFF	; 255
    29ac:	81 1d       	adc	r24, r1
    29ae:	81 1d       	adc	r24, r1
    29b0:	08 95       	ret

000029b2 <__fp_inf>:
    29b2:	97 f9       	bld	r25, 7
    29b4:	9f 67       	ori	r25, 0x7F	; 127
    29b6:	80 e8       	ldi	r24, 0x80	; 128
    29b8:	70 e0       	ldi	r23, 0x00	; 0
    29ba:	60 e0       	ldi	r22, 0x00	; 0
    29bc:	08 95       	ret

000029be <__fp_nan>:
    29be:	9f ef       	ldi	r25, 0xFF	; 255
    29c0:	80 ec       	ldi	r24, 0xC0	; 192
    29c2:	08 95       	ret

000029c4 <__fp_pscA>:
    29c4:	00 24       	eor	r0, r0
    29c6:	0a 94       	dec	r0
    29c8:	16 16       	cp	r1, r22
    29ca:	17 06       	cpc	r1, r23
    29cc:	18 06       	cpc	r1, r24
    29ce:	09 06       	cpc	r0, r25
    29d0:	08 95       	ret

000029d2 <__fp_pscB>:
    29d2:	00 24       	eor	r0, r0
    29d4:	0a 94       	dec	r0
    29d6:	12 16       	cp	r1, r18
    29d8:	13 06       	cpc	r1, r19
    29da:	14 06       	cpc	r1, r20
    29dc:	05 06       	cpc	r0, r21
    29de:	08 95       	ret

000029e0 <__fp_round>:
    29e0:	09 2e       	mov	r0, r25
    29e2:	03 94       	inc	r0
    29e4:	00 0c       	add	r0, r0
    29e6:	11 f4       	brne	.+4      	; 0x29ec <__fp_round+0xc>
    29e8:	88 23       	and	r24, r24
    29ea:	52 f0       	brmi	.+20     	; 0x2a00 <__fp_round+0x20>
    29ec:	bb 0f       	add	r27, r27
    29ee:	40 f4       	brcc	.+16     	; 0x2a00 <__fp_round+0x20>
    29f0:	bf 2b       	or	r27, r31
    29f2:	11 f4       	brne	.+4      	; 0x29f8 <__fp_round+0x18>
    29f4:	60 ff       	sbrs	r22, 0
    29f6:	04 c0       	rjmp	.+8      	; 0x2a00 <__fp_round+0x20>
    29f8:	6f 5f       	subi	r22, 0xFF	; 255
    29fa:	7f 4f       	sbci	r23, 0xFF	; 255
    29fc:	8f 4f       	sbci	r24, 0xFF	; 255
    29fe:	9f 4f       	sbci	r25, 0xFF	; 255
    2a00:	08 95       	ret

00002a02 <__fp_split3>:
    2a02:	57 fd       	sbrc	r21, 7
    2a04:	90 58       	subi	r25, 0x80	; 128
    2a06:	44 0f       	add	r20, r20
    2a08:	55 1f       	adc	r21, r21
    2a0a:	59 f0       	breq	.+22     	; 0x2a22 <__fp_splitA+0x10>
    2a0c:	5f 3f       	cpi	r21, 0xFF	; 255
    2a0e:	71 f0       	breq	.+28     	; 0x2a2c <__fp_splitA+0x1a>
    2a10:	47 95       	ror	r20

00002a12 <__fp_splitA>:
    2a12:	88 0f       	add	r24, r24
    2a14:	97 fb       	bst	r25, 7
    2a16:	99 1f       	adc	r25, r25
    2a18:	61 f0       	breq	.+24     	; 0x2a32 <__fp_splitA+0x20>
    2a1a:	9f 3f       	cpi	r25, 0xFF	; 255
    2a1c:	79 f0       	breq	.+30     	; 0x2a3c <__fp_splitA+0x2a>
    2a1e:	87 95       	ror	r24
    2a20:	08 95       	ret
    2a22:	12 16       	cp	r1, r18
    2a24:	13 06       	cpc	r1, r19
    2a26:	14 06       	cpc	r1, r20
    2a28:	55 1f       	adc	r21, r21
    2a2a:	f2 cf       	rjmp	.-28     	; 0x2a10 <__fp_split3+0xe>
    2a2c:	46 95       	lsr	r20
    2a2e:	f1 df       	rcall	.-30     	; 0x2a12 <__fp_splitA>
    2a30:	08 c0       	rjmp	.+16     	; 0x2a42 <__fp_splitA+0x30>
    2a32:	16 16       	cp	r1, r22
    2a34:	17 06       	cpc	r1, r23
    2a36:	18 06       	cpc	r1, r24
    2a38:	99 1f       	adc	r25, r25
    2a3a:	f1 cf       	rjmp	.-30     	; 0x2a1e <__fp_splitA+0xc>
    2a3c:	86 95       	lsr	r24
    2a3e:	71 05       	cpc	r23, r1
    2a40:	61 05       	cpc	r22, r1
    2a42:	08 94       	sec
    2a44:	08 95       	ret

00002a46 <__fp_zero>:
    2a46:	e8 94       	clt

00002a48 <__fp_szero>:
    2a48:	bb 27       	eor	r27, r27
    2a4a:	66 27       	eor	r22, r22
    2a4c:	77 27       	eor	r23, r23
    2a4e:	cb 01       	movw	r24, r22
    2a50:	97 f9       	bld	r25, 7
    2a52:	08 95       	ret

00002a54 <__gesf2>:
    2a54:	0e 94 b5 14 	call	0x296a	; 0x296a <__fp_cmp>
    2a58:	08 f4       	brcc	.+2      	; 0x2a5c <__gesf2+0x8>
    2a5a:	8f ef       	ldi	r24, 0xFF	; 255
    2a5c:	08 95       	ret

00002a5e <__mulsf3>:
    2a5e:	0e 94 42 15 	call	0x2a84	; 0x2a84 <__mulsf3x>
    2a62:	0c 94 f0 14 	jmp	0x29e0	; 0x29e0 <__fp_round>
    2a66:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <__fp_pscA>
    2a6a:	38 f0       	brcs	.+14     	; 0x2a7a <__mulsf3+0x1c>
    2a6c:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <__fp_pscB>
    2a70:	20 f0       	brcs	.+8      	; 0x2a7a <__mulsf3+0x1c>
    2a72:	95 23       	and	r25, r21
    2a74:	11 f0       	breq	.+4      	; 0x2a7a <__mulsf3+0x1c>
    2a76:	0c 94 d9 14 	jmp	0x29b2	; 0x29b2 <__fp_inf>
    2a7a:	0c 94 df 14 	jmp	0x29be	; 0x29be <__fp_nan>
    2a7e:	11 24       	eor	r1, r1
    2a80:	0c 94 24 15 	jmp	0x2a48	; 0x2a48 <__fp_szero>

00002a84 <__mulsf3x>:
    2a84:	0e 94 01 15 	call	0x2a02	; 0x2a02 <__fp_split3>
    2a88:	70 f3       	brcs	.-36     	; 0x2a66 <__mulsf3+0x8>

00002a8a <__mulsf3_pse>:
    2a8a:	95 9f       	mul	r25, r21
    2a8c:	c1 f3       	breq	.-16     	; 0x2a7e <__mulsf3+0x20>
    2a8e:	95 0f       	add	r25, r21
    2a90:	50 e0       	ldi	r21, 0x00	; 0
    2a92:	55 1f       	adc	r21, r21
    2a94:	62 9f       	mul	r22, r18
    2a96:	f0 01       	movw	r30, r0
    2a98:	72 9f       	mul	r23, r18
    2a9a:	bb 27       	eor	r27, r27
    2a9c:	f0 0d       	add	r31, r0
    2a9e:	b1 1d       	adc	r27, r1
    2aa0:	63 9f       	mul	r22, r19
    2aa2:	aa 27       	eor	r26, r26
    2aa4:	f0 0d       	add	r31, r0
    2aa6:	b1 1d       	adc	r27, r1
    2aa8:	aa 1f       	adc	r26, r26
    2aaa:	64 9f       	mul	r22, r20
    2aac:	66 27       	eor	r22, r22
    2aae:	b0 0d       	add	r27, r0
    2ab0:	a1 1d       	adc	r26, r1
    2ab2:	66 1f       	adc	r22, r22
    2ab4:	82 9f       	mul	r24, r18
    2ab6:	22 27       	eor	r18, r18
    2ab8:	b0 0d       	add	r27, r0
    2aba:	a1 1d       	adc	r26, r1
    2abc:	62 1f       	adc	r22, r18
    2abe:	73 9f       	mul	r23, r19
    2ac0:	b0 0d       	add	r27, r0
    2ac2:	a1 1d       	adc	r26, r1
    2ac4:	62 1f       	adc	r22, r18
    2ac6:	83 9f       	mul	r24, r19
    2ac8:	a0 0d       	add	r26, r0
    2aca:	61 1d       	adc	r22, r1
    2acc:	22 1f       	adc	r18, r18
    2ace:	74 9f       	mul	r23, r20
    2ad0:	33 27       	eor	r19, r19
    2ad2:	a0 0d       	add	r26, r0
    2ad4:	61 1d       	adc	r22, r1
    2ad6:	23 1f       	adc	r18, r19
    2ad8:	84 9f       	mul	r24, r20
    2ada:	60 0d       	add	r22, r0
    2adc:	21 1d       	adc	r18, r1
    2ade:	82 2f       	mov	r24, r18
    2ae0:	76 2f       	mov	r23, r22
    2ae2:	6a 2f       	mov	r22, r26
    2ae4:	11 24       	eor	r1, r1
    2ae6:	9f 57       	subi	r25, 0x7F	; 127
    2ae8:	50 40       	sbci	r21, 0x00	; 0
    2aea:	9a f0       	brmi	.+38     	; 0x2b12 <__mulsf3_pse+0x88>
    2aec:	f1 f0       	breq	.+60     	; 0x2b2a <__mulsf3_pse+0xa0>
    2aee:	88 23       	and	r24, r24
    2af0:	4a f0       	brmi	.+18     	; 0x2b04 <__mulsf3_pse+0x7a>
    2af2:	ee 0f       	add	r30, r30
    2af4:	ff 1f       	adc	r31, r31
    2af6:	bb 1f       	adc	r27, r27
    2af8:	66 1f       	adc	r22, r22
    2afa:	77 1f       	adc	r23, r23
    2afc:	88 1f       	adc	r24, r24
    2afe:	91 50       	subi	r25, 0x01	; 1
    2b00:	50 40       	sbci	r21, 0x00	; 0
    2b02:	a9 f7       	brne	.-22     	; 0x2aee <__mulsf3_pse+0x64>
    2b04:	9e 3f       	cpi	r25, 0xFE	; 254
    2b06:	51 05       	cpc	r21, r1
    2b08:	80 f0       	brcs	.+32     	; 0x2b2a <__mulsf3_pse+0xa0>
    2b0a:	0c 94 d9 14 	jmp	0x29b2	; 0x29b2 <__fp_inf>
    2b0e:	0c 94 24 15 	jmp	0x2a48	; 0x2a48 <__fp_szero>
    2b12:	5f 3f       	cpi	r21, 0xFF	; 255
    2b14:	e4 f3       	brlt	.-8      	; 0x2b0e <__mulsf3_pse+0x84>
    2b16:	98 3e       	cpi	r25, 0xE8	; 232
    2b18:	d4 f3       	brlt	.-12     	; 0x2b0e <__mulsf3_pse+0x84>
    2b1a:	86 95       	lsr	r24
    2b1c:	77 95       	ror	r23
    2b1e:	67 95       	ror	r22
    2b20:	b7 95       	ror	r27
    2b22:	f7 95       	ror	r31
    2b24:	e7 95       	ror	r30
    2b26:	9f 5f       	subi	r25, 0xFF	; 255
    2b28:	c1 f7       	brne	.-16     	; 0x2b1a <__mulsf3_pse+0x90>
    2b2a:	fe 2b       	or	r31, r30
    2b2c:	88 0f       	add	r24, r24
    2b2e:	91 1d       	adc	r25, r1
    2b30:	96 95       	lsr	r25
    2b32:	87 95       	ror	r24
    2b34:	97 f9       	bld	r25, 7
    2b36:	08 95       	ret

00002b38 <__mulsi3>:
    2b38:	db 01       	movw	r26, r22
    2b3a:	8f 93       	push	r24
    2b3c:	9f 93       	push	r25
    2b3e:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <__muluhisi3>
    2b42:	bf 91       	pop	r27
    2b44:	af 91       	pop	r26
    2b46:	a2 9f       	mul	r26, r18
    2b48:	80 0d       	add	r24, r0
    2b4a:	91 1d       	adc	r25, r1
    2b4c:	a3 9f       	mul	r26, r19
    2b4e:	90 0d       	add	r25, r0
    2b50:	b2 9f       	mul	r27, r18
    2b52:	90 0d       	add	r25, r0
    2b54:	11 24       	eor	r1, r1
    2b56:	08 95       	ret

00002b58 <__divmodhi4>:
    2b58:	97 fb       	bst	r25, 7
    2b5a:	07 2e       	mov	r0, r23
    2b5c:	16 f4       	brtc	.+4      	; 0x2b62 <__divmodhi4+0xa>
    2b5e:	00 94       	com	r0
    2b60:	07 d0       	rcall	.+14     	; 0x2b70 <__divmodhi4_neg1>
    2b62:	77 fd       	sbrc	r23, 7
    2b64:	09 d0       	rcall	.+18     	; 0x2b78 <__divmodhi4_neg2>
    2b66:	0e 94 04 16 	call	0x2c08	; 0x2c08 <__udivmodhi4>
    2b6a:	07 fc       	sbrc	r0, 7
    2b6c:	05 d0       	rcall	.+10     	; 0x2b78 <__divmodhi4_neg2>
    2b6e:	3e f4       	brtc	.+14     	; 0x2b7e <__divmodhi4_exit>

00002b70 <__divmodhi4_neg1>:
    2b70:	90 95       	com	r25
    2b72:	81 95       	neg	r24
    2b74:	9f 4f       	sbci	r25, 0xFF	; 255
    2b76:	08 95       	ret

00002b78 <__divmodhi4_neg2>:
    2b78:	70 95       	com	r23
    2b7a:	61 95       	neg	r22
    2b7c:	7f 4f       	sbci	r23, 0xFF	; 255

00002b7e <__divmodhi4_exit>:
    2b7e:	08 95       	ret

00002b80 <__udivmodsi4>:
    2b80:	a1 e2       	ldi	r26, 0x21	; 33
    2b82:	1a 2e       	mov	r1, r26
    2b84:	aa 1b       	sub	r26, r26
    2b86:	bb 1b       	sub	r27, r27
    2b88:	fd 01       	movw	r30, r26
    2b8a:	0d c0       	rjmp	.+26     	; 0x2ba6 <__udivmodsi4_ep>

00002b8c <__udivmodsi4_loop>:
    2b8c:	aa 1f       	adc	r26, r26
    2b8e:	bb 1f       	adc	r27, r27
    2b90:	ee 1f       	adc	r30, r30
    2b92:	ff 1f       	adc	r31, r31
    2b94:	a2 17       	cp	r26, r18
    2b96:	b3 07       	cpc	r27, r19
    2b98:	e4 07       	cpc	r30, r20
    2b9a:	f5 07       	cpc	r31, r21
    2b9c:	20 f0       	brcs	.+8      	; 0x2ba6 <__udivmodsi4_ep>
    2b9e:	a2 1b       	sub	r26, r18
    2ba0:	b3 0b       	sbc	r27, r19
    2ba2:	e4 0b       	sbc	r30, r20
    2ba4:	f5 0b       	sbc	r31, r21

00002ba6 <__udivmodsi4_ep>:
    2ba6:	66 1f       	adc	r22, r22
    2ba8:	77 1f       	adc	r23, r23
    2baa:	88 1f       	adc	r24, r24
    2bac:	99 1f       	adc	r25, r25
    2bae:	1a 94       	dec	r1
    2bb0:	69 f7       	brne	.-38     	; 0x2b8c <__udivmodsi4_loop>
    2bb2:	60 95       	com	r22
    2bb4:	70 95       	com	r23
    2bb6:	80 95       	com	r24
    2bb8:	90 95       	com	r25
    2bba:	9b 01       	movw	r18, r22
    2bbc:	ac 01       	movw	r20, r24
    2bbe:	bd 01       	movw	r22, r26
    2bc0:	cf 01       	movw	r24, r30
    2bc2:	08 95       	ret

00002bc4 <__umulhisi3>:
    2bc4:	a2 9f       	mul	r26, r18
    2bc6:	b0 01       	movw	r22, r0
    2bc8:	b3 9f       	mul	r27, r19
    2bca:	c0 01       	movw	r24, r0
    2bcc:	a3 9f       	mul	r26, r19
    2bce:	70 0d       	add	r23, r0
    2bd0:	81 1d       	adc	r24, r1
    2bd2:	11 24       	eor	r1, r1
    2bd4:	91 1d       	adc	r25, r1
    2bd6:	b2 9f       	mul	r27, r18
    2bd8:	70 0d       	add	r23, r0
    2bda:	81 1d       	adc	r24, r1
    2bdc:	11 24       	eor	r1, r1
    2bde:	91 1d       	adc	r25, r1
    2be0:	08 95       	ret

00002be2 <__muluhisi3>:
    2be2:	0e 94 e2 15 	call	0x2bc4	; 0x2bc4 <__umulhisi3>
    2be6:	a5 9f       	mul	r26, r21
    2be8:	90 0d       	add	r25, r0
    2bea:	b4 9f       	mul	r27, r20
    2bec:	90 0d       	add	r25, r0
    2bee:	a4 9f       	mul	r26, r20
    2bf0:	80 0d       	add	r24, r0
    2bf2:	91 1d       	adc	r25, r1
    2bf4:	11 24       	eor	r1, r1
    2bf6:	08 95       	ret

00002bf8 <__mulshisi3>:
    2bf8:	b7 ff       	sbrs	r27, 7
    2bfa:	0c 94 f1 15 	jmp	0x2be2	; 0x2be2 <__muluhisi3>

00002bfe <__mulohisi3>:
    2bfe:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <__muluhisi3>
    2c02:	82 1b       	sub	r24, r18
    2c04:	93 0b       	sbc	r25, r19
    2c06:	08 95       	ret

00002c08 <__udivmodhi4>:
    2c08:	aa 1b       	sub	r26, r26
    2c0a:	bb 1b       	sub	r27, r27
    2c0c:	51 e1       	ldi	r21, 0x11	; 17
    2c0e:	07 c0       	rjmp	.+14     	; 0x2c1e <__udivmodhi4_ep>

00002c10 <__udivmodhi4_loop>:
    2c10:	aa 1f       	adc	r26, r26
    2c12:	bb 1f       	adc	r27, r27
    2c14:	a6 17       	cp	r26, r22
    2c16:	b7 07       	cpc	r27, r23
    2c18:	10 f0       	brcs	.+4      	; 0x2c1e <__udivmodhi4_ep>
    2c1a:	a6 1b       	sub	r26, r22
    2c1c:	b7 0b       	sbc	r27, r23

00002c1e <__udivmodhi4_ep>:
    2c1e:	88 1f       	adc	r24, r24
    2c20:	99 1f       	adc	r25, r25
    2c22:	5a 95       	dec	r21
    2c24:	a9 f7       	brne	.-22     	; 0x2c10 <__udivmodhi4_loop>
    2c26:	80 95       	com	r24
    2c28:	90 95       	com	r25
    2c2a:	bc 01       	movw	r22, r24
    2c2c:	cd 01       	movw	r24, r26
    2c2e:	08 95       	ret

00002c30 <_exit>:
    2c30:	f8 94       	cli

00002c32 <__stop_program>:
    2c32:	ff cf       	rjmp	.-2      	; 0x2c32 <__stop_program>
